% The master copy of this demo dissertation is held on my filespace
% on the cl file serve (/homes/mr/teaching/demodissert/)

% Last updated by MR on 2 August 2001

\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{fontspec}
\setmainfont{DejaVu Sans}
\setmonofont{DejaVu Sans Mono}
%%% HERE I PUT THE LAGDA THINGY


%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \_}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode".
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray
% environment. It is supposed to be used only inside math mode
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

%%% HERE IT ENDS
\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{2mm}       % adjust margins
\addtolength{\evensidemargin}{-4mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Razvan Kusztos}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Verified functional datastructures in Agda} \\
\vspace*{5mm}
Diploma in Computer Science \\
\vspace*{5mm}
Girton College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Razvan Kusztos                       \\
College:            & \bf Girton College                     \\
Project Title:      & \bf Verified functional datasturcures and algorithm in Agda \\
Examination:        & \bf Part II Project        \\
Word Count:         & \bf 0\footnotemark[1]
(well less than the 12000 limit) \\
Project Originator: & Dr Timothy Griffin                    \\
Supervisor:         & Dr Timothy Griffin                    \\
\end{tabular}
}
\footnotetext[1]{This word count was computed
by {\tt detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}

\newpage
\section*{Declaration}

I, [Name] of [College], being a candidate for Part II of the Computer
Science Tripos [or the Diploma in Computer Science], hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed [signature]}

\medskip
\leftline{Date [date]}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

This document owes much to an earlier version written by Simon Moore
\cite{moore95}.  His help, encouragement and advice was greatly
appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}

\section{Verified Programming}

Formal verification is a way of proving correctness of program, by using a formal mathematical method. This can come in many flavours, from taking code that is already written and showing that it preserves some invariants in another language (as in Hoare logic) to writing mathematical proofs. The former process can greatly benefit from developing computer software that can aid and verify the proving process. There are a lot of such systems, form which one can mention Coq, Isabelle/HOL or Agda.

These environments differ in a number of ways, and for the purpose of this project I have decided to use Agda. 

Firstly, Isabelle is limited to performing 'external' verification, which refers to a clear separation between the code - subject of the proof and the proof itself. This provides a great advantage for readability and code extraction. However, for this project I was particularly interested in the way in which the typing constraints can enforce correctness.

On the other hand, Coq and Agda are both examples of programming languages with dependent types. They are based on Martin Lof intuitionistic type theory. Coq was originally designed as a theorem prover, and is much older than Agda. My initial argument for picking Agda is its relative simplicity and steeper learning curve. By using it, I have also discovered some other advantages, such as allowing mutual definitions, mixfix syntax, and the overall results of building it while regarding interactivity. Coq is however a more powerful environment, as it allows the use of tactics, while in Agda they have to be implemented (I provide an example in Section - - - )



\section{Functional Datastructures}

There has always been an imballance between the use of functional programming versus imperative programming both in
industry, as well as in terms of available resource. Functional programming has often been ruled out in the
past because of it running slow, or simply because it was stigmatised as belonging into academia, regardless of its
properties \cite{landin}. However, this paradigm
is being introduced now at the forefront of business development. This is because of the persistency\footnotemark[0] of data-structures,
useful for the ever-present multicore environment. The reliablity aspect, formal verification and
keeping runtime errors to a minimum have also been relevant.
The issue of the runtime speed has been addressed gracefully by Okasaki \cite{oka}, which, introduced a reusable concept
that can help designers build efficient data structures: the implicit recursive slowdown.

\section{Dependent Typing}

An important breakthrough in writing verifiably correct code is the introduction of dependent types.\cite{achipala}
In this setting the distinction between types and values becomes blurry, allowing us to define types that depend on values.


An immediate practical motivation is performing the sum of two vectors.
The usual programming paradigm would be (in pseudocode): \\

\begin{verbatim}
def sum (l1, l2):
  if (l1.length != l2.length)
    raise ListsNotEqualException;
  ...
\end{verbatim}

This can cause a runtime error and arguably disrupts the logical flow of the program. In a program that
supports dependent types, we can construct lists that are both parametrized by a variable (as in the usual
polymorphic programming), but also 'indexed'.

The usual definiton of lists would be (in Agda - but easily any functional language)

\begin{verbatim}
  data List (A : Set) : Set where
    nil : List A
    _∷_ : A → List A → List A
 \end{verbatim}

Compare this with the dependent definition:

\begin{verbatim}
  data Vec (A : Set) : ℕ → Set where
    nil : Vec A 0
    _∷_ : ∀ {n : ℕ} → A → Vec A n → Vec A (n + 1)
\end{verbatim}

This allows us to write functions that require a 'proof' that the two arguments are of equal length.

\begin{verbatim}
  sum : ∀ {n : ℕ} → Vec ℕ n → Vec ℕ n → Vec ℕ n
  sum xs ys = ?
\end{verbatim}

If this is not obvious from the context, the program will not type check.
The developer is forced to only write correct programs.

Further details about agda syntax will be provided in section (Introduction to Agda)

\section{Nested Types}

Another way of maintaing invariants throughout the program is the trick or 'irregular'
or 'nested' datatypes. They allow forcing strong structural invariants on the datastructure
and have gained interest because of their practical implications, allowing definitions of
circular datastructures \cite{circular} or de bruijin indexes \cite{birdmeertens}.
Some difficulties come up in recursive calls or inductive proofs, fact which will be
covered and discussed in section (TODO implementation/section\_nest\_example).
For example, consider the next data structure, introduced by Bird and Meertens \cite{birdmeertens}
, with a slight modification that makes future examples easier to understand.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Nest}\;\{\mskip1.5mu \Varid{a}\mathbin{:}\Conid{Level}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\mathbin{:}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{nilN}{}\<[9]%
\>[9]{}\mathbin{:}\Conid{Nest}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{consN}\mathbin{:}(\Conid{A}\mathbin{×}\Conid{A})\mathbin{→}\Conid{Nest}\;(\Conid{A}\mathbin{×}\Conid{A})\mathbin{→}\Conid{Nest}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This can be thought of as the levels of a full binary tree (with the exeption of the binary tree with only
one element, which I am ruling out for simplicity)


Another example, with a more interesting application is:

\begin{verbatim}
  data BinTree (A : Set) : Set where
    empty : BinTree A
    single : A → BinTree A
    deep :  BinTree (Node A) → BinTree A
\end{verbatim}
Where Node is simply:
\begin{verbatim}
  data Node (A : Set) : Set where
    node : A → A → Node A
\end{verbatim}

It can be seen from the declaration that the structure will be forced to be a sequence of deep
constructors, followed by either a single (Nodeⁿ A) or an empty constructor. The number
of elements stored in it has to be a power of two (2ⁿ) making it equivalent to the leafs of a full
binary tree.

This dissertation is mostly concerned with 2-3 trees, the basis for the FingerTrees, which
will be studied in detail in the Implementation section. They are an example to show arising problems
when proving properties of nested and dependent typed structures, what limits are imposed and how
some of them can be overcome.

\section{Introduction to Agda}

Agda is a dependently typed programming language, developed in the spirit of Haskell, kept as
simple as possible \cite{ulf}.
All the previous examples are written in Agda, and their syntax and the newly introduced syntax
will be described as we go on.
Along other programming languages like Coq \cite{coq} or Isabelle \cite{isabelle}, Agda is used as
an interactive (or automatic) theorem prover. What makes it different from the two previously
mentioned system is the ability to write the code and the proofs in the same environment. Its relative
simplicity also motivated its use in this project.

\subsection{Types as Values}

As said before, a dependently typed environment allows types to be not only arguments to functions,
as it is the case in generic data structures, but also returned values.

In Agda, the base for all types is called Set, which can be simplistically though of as the type of types.

I will use, as a running example throughout this section, the construction of natural numbers and lists. They
should be sufficient for introducing most of the concepts that will be needed throughout this
dissertation.

\subsection{Declaring Data Structures}

Data structures in agda follow the ADT (Algebraic Data Types) paradigm. They group together
constructors that can introduce the given structure.
Each constructor should be thought of as a function which returns an instance of the data structure.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{ℕ}\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{zero}\mathbin{:}\Conid{ℕ}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{suc}\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{ℕ}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We declare the type of natural numbers, which is of type Set. It has only two constructors;
zero, which takes no argument, and suc (successor) which, provided a natural number, can
construct the next natural number.\\

As you probably noticed, Agda has full unicode support. This makes writing proofs
about mathematical objects nice and readable since you can use the conventional symbols. \\

Another piece of elegant syntax is the presence of mixfix operators. Most unicode characters
can be used in the name of the operator, and by \_ you tell agda that's where you want
to put an argument \begin{verbatim} (Example: _+_, if_then_else_, [_])
\end{verbatim}

\subsection{Agda's interactive help}

Before writing the implementation of a function, as you stumble upon the equals(=) sign,
you can tell agda to place a hole ({! !}) instead of an implementation. Here, you can
perform a number of operations:
  \begin {itemize}
  \item{See the types and values of variables in the scope}
  \item{Case-split} \\
    For example, consider the addition of natural numbers. \\
    \begin{hscode}\SaveRestoreHook
    \column{B}{@{}>{\hspre}l<{\hspost}@{}}%
    \column{3}{@{}>{\hspre}l<{\hspost}@{}}%
    \column{E}{@{}>{\hspre}l<{\hspost}@{}}%
    \>[3]{}\anonymous \mathbin{+\char95 }\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{ℕ}\mathbin{→}\Conid{ℕ}{}\<[E]%
    \\
    \>[3]{}\Varid{n}\mathbin{+}\Varid{m}\mathrel{=}\{\mskip1.5mu \mathbin{!}\mathbin{!}\mskip1.5mu\}{}\<[E]%
    \ColumnHook
    \end{hscode}\resethooks
    Performing a case-split on the variable n shows me all the possible ways in which a natural number can be constructed. \\
    \begin{hscode}\SaveRestoreHook
    \column{B}{@{}>{\hspre}l<{\hspost}@{}}%
    \column{3}{@{}>{\hspre}l<{\hspost}@{}}%
    \column{19}{@{}>{\hspre}l<{\hspost}@{}}%
    \column{20}{@{}>{\hspre}c<{\hspost}@{}}%
    \column{20E}{@{}l@{}}%
    \column{E}{@{}>{\hspre}l<{\hspost}@{}}%
    \>[3]{}\anonymous \mathbin{+\char95 }\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{ℕ}\mathbin{→}\Conid{ℕ}{}\<[E]%
    \\
    \>[3]{}\Varid{zero}\mathbin{+}\Varid{m}\mathrel{=}\{\mskip1.5mu \mathbin{!}{}\<[19]%
    \>[19]{}\mathbin{!}\mskip1.5mu\}{}\<[E]%
    \\
    \>[3]{}\Varid{suc}\;\Varid{n}\mathbin{+}\Varid{m}\mathrel{=}\{\mskip1.5mu \mathbin{!}{}\<[20]%
    \>[20]{}\mathbin{!}\mskip1.5mu\}{}\<[20E]%
    \ColumnHook
    \end{hscode}\resethooks
    \\
    A consequence of this is that all functions in Agda must be total. If a possible constructor is not present in the definition,
    it will not type-check.
  \item{Refine and Auto} \\
    These provide the automated and interactive ways of theorem-proving. Essentially, Agda looks throughout the environment to find
    an inhabitant (a variable) that has the type of the hole. \\
    They are definitely not as powerfull as any functionality given by Coq of Isabelle, but it can save some typing.

  \end{itemize}

\subsection{Arguments}
  Agda introduces some syntax for various types of arguments you can provide to functions. As you probably saw,
  there is a difference in handling the polymorphic types (in the case of List) and the values given as arguments
  to type constructors (in the case of Vec). \\

  In the declaration of Vec: \\

  \begin{hscode}\SaveRestoreHook
  \column{B}{@{}>{\hspre}l<{\hspost}@{}}%
  \column{3}{@{}>{\hspre}l<{\hspost}@{}}%
  \column{5}{@{}>{\hspre}l<{\hspost}@{}}%
  \column{E}{@{}>{\hspre}l<{\hspost}@{}}%
  \>[3]{}\mathbf{data}\;\Conid{Vec}\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{Set}\;\mathbf{where}{}\<[E]%
  \\
  \>[3]{}\hsindent{2}{}\<[5]%
  \>[5]{}\Varid{nil}\mathbin{:}\Conid{Vec}\;\Conid{A}\;\Varid{zero}{}\<[E]%
  \\
  \>[3]{}\hsindent{2}{}\<[5]%
  \>[5]{}\anonymous \mathbin{∷\char95 }\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}\Conid{A}\mathbin{→}\Conid{Vec}\;\Conid{A}\;\Varid{n}\mathbin{→}\Conid{Vec}\;\Conid{A}\;(\Varid{suc}\;\Varid{n}){}\<[E]%
  \ColumnHook
  \end{hscode}\resethooks

  The first (A : Set) is the type argument for instantiating a polymorphic type, before the :, while the ℕ is the type of the value argument for
  the dependently typed instantiation.

  Another think to notice here is the curly brackets (\{n : ℕ\}) in the declaration of the \_::\_ constructor.
  This is called an implicit argument. Agda will bind n to a value it sees fit in the scope. If there are more possibilities, it will take a guess.

\subsection{Instance Arguments}

  Throughout this dissertation, we will be using some properties of certain types, for example of having a monoid operation associated with them.
  In Haskell, you would accomplish that with the use of type classes \cite{typeclasses} \\
  In order to mimic this behaviour we will use instance arguments. They are declared by using double square brackets, \{\{ \}\} or the unicode
  equivalent. \\
  What Agda does in this case, it looks for a possible instantiation of that type in the current scope, following some predefined rules. \cite{instanceargs}
  It is important there is only one available possibility, otherwise it will fail to type check.

  The use will become obvious in the Implementation section.

\cleardoublepage

\chapter{Preparation}


\section{Programs as proofs}

Agda is a depedently typed programming language, based on the intuitionistic type theory developed by
Per Martin Lof \cite{martinlof}. The power of the typing system is sufficient to express propositions as
types. Finding an inhabitant of each type becomes equivalent to constructing a proof of
the embedded proposition.



\subsection{Some Agda Examples}

Consider for example the proposition describing equality (taken from the standard libray)

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{open}\;\mathbf{import}\;\Conid{Level}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\anonymous \mathbin{≡\char95}\{\mskip1.5mu \Varid{a}\mathbin{:}\Conid{Level}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;(\Varid{x}\mathbin{:}\Conid{A})\mathbin{:}\Conid{A}\mathbin{→}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{refl}\mathbin{:}\Varid{x}\mathbin{≡}\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

(An explanation of the Level and universe polymorphism will be found at the end of the section -- TODO Footnote)

The first thing to notice is that this is a declaration of a dependent data type. It can only be constructed
by calling refl, which tells us that all elements are equal to themselves (reflexivity).

Therefore, constructing an elements of type (a ≡ b) for some a and b becomes a proof that a and b are equal.
This, of course, relates elements by their structural equality and is the version most used in the standard library. This
doesn't stop the developer from defining their own form of equality.

For example, this equality over integers (which is in this case equivalent to ≡)

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{infix}\;\mathrm{4}\;\anonymous \mathbin{==\char95 }{}\<[E]%
\\
\>[3]{}\mathbf{data}\;\anonymous \mathbin{==\char95 }\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{ℕ}\mathbin{→}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{z}\mathbin{:}\Varid{zero}\equiv \Varid{zero}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{s}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\;\Varid{m}\mskip1.5mu\}\mathbin{→}\Varid{n}\equiv \Varid{m}\mathbin{→}(\Varid{suc}\;\Varid{n})\equiv (\Varid{suc}\;\Varid{m}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can already start building up proofs, for example, of the property of zero to be the neutre element to addition:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathrm{0}\mathbin{-}\Varid{left}\mathbin{:}\mathbin{∀}(\Varid{n}\mathbin{:}\Conid{ℕ})\mathbin{→}(\Varid{zero}\mathbin{+}\Varid{n}\equiv \Varid{n}){}\<[E]%
\\
\>[3]{}\mathrm{0}\mathbin{-}\Varid{left}\;\Varid{zero}\mathrel{=}\Varid{z}{}\<[E]%
\\
\>[3]{}\mathrm{0}\mathbin{-}\Varid{left}\;(\Varid{suc}\;\Varid{n})\mathrel{=}\Varid{s}\;(\mathrm{0}\mathbin{-}\Varid{left}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can see that the term zero-left is a proof of the proposition embedded in the type, since it shows us how
the proposition was constructed (by using z or s constructors respectively)

Consider, for example, defining a less then equal operator and the proof of the antisymmetry property

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{infix}\;\mathrm{4}\;\anonymous \mathbin{≤\char95 }{}\<[E]%
\\
\>[3]{}\mathbf{data}\;\anonymous \mathbin{≤\char95 }\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{ℕ}\mathbin{→}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{leq}\mathbin{-}\Varid{zero}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}\Varid{zero}\mathbin{≤}\Varid{n}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{leq}\mathbin{-}\Varid{suc}{}\<[14]%
\>[14]{}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{m}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}\Varid{m}\mathbin{≤}\Varid{n}\mathbin{→}\Varid{suc}\;\Varid{m}\mathbin{≤}\Varid{suc}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{leq}\mathbin{-}\Varid{antisym}\mathbin{:}\mathbin{∀}(\Varid{n}\mathbin{:}\Conid{ℕ})\;(\Varid{m}\mathbin{:}\Conid{ℕ})\mathbin{→}(\Varid{n}\mathbin{≤}\Varid{m})\mathbin{→}(\Varid{m}\mathbin{≤}\Varid{n})\mathbin{→}(\Varid{n}\equiv \Varid{m}){}\<[E]%
\\
\>[3]{}\Varid{leq}\mathbin{-}\Varid{antisym}\;\Varid{zero}\;\Varid{zero}\;\Varid{leq}\mathbin{-}\Varid{zero}\;\Varid{leq}\mathbin{-}\Varid{zero}\mathrel{=}\Varid{z}{}\<[E]%
\\
\>[3]{}\Varid{leq}\mathbin{-}\Varid{antisym}\;\Varid{zero}\;(\Varid{suc}\;\Varid{m})\;\Varid{leq}\mathbin{-}\Varid{zero}\;(){}\<[E]%
\\
\>[3]{}\Varid{leq}\mathbin{-}\Varid{antisym}\;(\Varid{suc}\;\Varid{n})\;(\Varid{suc}\;\Varid{m})\;(\Varid{leq}\mathbin{-}\Varid{suc}\;\Varid{p1})\;(\Varid{leq}\mathbin{-}\Varid{suc}\;\Varid{p2})\mathrel{=}\Varid{s}\;(\Varid{leq}\mathbin{-}\Varid{antisym}\;\Varid{n}\;\Varid{m}\;\Varid{p1}\;\Varid{p2}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This example is important because it shows two important points.

Defining relations properly can allow meaningful case split on the proof object. In the first line, we can see how, if n = 0 and m = 0,
then both (n ≤ m) and (m ≤ n) can only be constructed by leq-zero. Although this case is trivial, one can imagine a case where knowing exactly
what constructor was used provides extra information about the inputs.

Another import point is the absurd pattern (). Agda doesn't allow the definition of partial functions, therefore all the cases of the
input must be analyzed. However, if n = 0 and m > 0, one cannot possibly construct the fourth argument to the function (of type m ≤ n). This case,
therefore cannot be reached in the program.

During most of the project we will use the structural equality. Agda standard library provides a nice, readable way
of constructing such proofs (further down)

\subsection{Curry-Howard Isomorphism}

Although the definitions above seem intuitive, they have strong theoretical underpinnings in Martin Lof's theory \cite{martinlof}, as well as
Curry-Howard isomorphism. The original result by Howard \cite{howard} gives the link between natural deduction in the intutionistic logic theory
and the simply typed lambda calculus. \\
-insert some table here \\

\subsection{with, rewrite}

Agda provides some in-built syntax for making writing proofs more intuitive.
The first such keyword is with. It allows, inspired by the work of McBride and McKinna \cite{viewfromtheleft},
to pattern match on an intermediate computation. This is more or less equivalent to adding an extra argument to
the left of the function, although, that would make the code objectively more unreadable by the never ending
chain or arguments in the type declaration.

We will see how this become particularly nice with Views \cite{wadler}.

Another piece of usefull syntax is rewrite. This is meant to be read as 'rewrite the left hand side
by using the equation on the right hand side'. This makes necessarily use of the builtin equality.

Consider the task of proving the associativity property of natural numbers:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}c<{\hspost}@{}}%
\column{29E}{@{}l@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{open}\;\mathbf{import}\;\Conid{\Conid{Relation}.\Conid{Binary}.PropositionalEquality}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbin{+}\Varid{assoc}\mathbin{:}\mathbin{∀}(\Varid{x}\;\Varid{y}\;\Varid{z}\mathbin{:}\Conid{ℕ})\mathbin{→}(\Varid{x}\mathbin{+}(\Varid{y}\mathbin{+}\Varid{z}))\mathbin{≡}((\Varid{x}\mathbin{+}\Varid{y})\mathbin{+}\Varid{z}){}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{assoc}\;\Varid{zero}\;\Varid{y}\;\Varid{z}\mathrel{=}\Varid{refl}{}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{assoc}\;(\Varid{suc}\;\Varid{x})\;\Varid{y}\;\Varid{z}\mathrel{=}\{\mskip1.5mu \mathbin{!}{}\<[29]%
\>[29]{}\mathbin{!}\mskip1.5mu\}{}\<[29E]%
\ColumnHook
\end{hscode}\resethooks

The hole here has the type: suc (x + (y + z)) ≡ suc ((x + y) + z).
It is therefore suficient to rewrite suc (x + (y + z)) by using the associativity property of x y and z
in order to obtain refl.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{open}\;\mathbf{import}\;\Conid{\Conid{Relation}.\Conid{Binary}.PropositionalEquality}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbin{+}\Varid{assoc}\mathbin{:}\mathbin{∀}(\Varid{x}\;\Varid{y}\;\Varid{z}\mathbin{:}\Conid{ℕ})\mathbin{→}(\Varid{x}\mathbin{+}(\Varid{y}\mathbin{+}\Varid{z}))\mathbin{≡}((\Varid{x}\mathbin{+}\Varid{y})\mathbin{+}\Varid{z}){}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{assoc}\;\Varid{zero}\;\Varid{y}\;\Varid{z}\mathrel{=}\Varid{refl}{}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{assoc}\;(\Varid{suc}\;\Varid{x})\;\Varid{y}\;\Varid{z}\;\Varid{rewrite}\mathbin{+}\Varid{assoc}\;\Varid{x}\;\Varid{y}\;\Varid{z}\mathrel{=}\Varid{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In fact, rewrite is just syntactic sugar for two nested with statements, as described in the official documentation \cite{agdadoc}: \\

\begin{verbatim}
If eqn : a ≡ b, where _≡_ is the builtin equality you can write
  f ps rewrite eqn = rhs
instead of
  f ps with a | eqn
  … | ._ | refl = rhs
\end{verbatim}

-syntax\\
-unimplemented feature of with -- will fit better at difficulties\\
-rewrite explained as a sequence of with statements\\
-rewrite example with +-com

\subsection{Equivalence-Reasoning, inspect}

In order to obtain a proof of a more complex nature, you need to chain quite o few rewrite statements, and checking goal
types in their presence is not always as illuminating as one would imagine, because it is quite hard to keep track of
how the previous rewrites affect the current goal.

This is why the standard library provides a way of chaining such rewriting in a more mathematically friendly manner.
The documentation is freely available online \cite{agdadoc}. To show how it will be used in this project,
I will give an example of a proof done in both ways. The proof is the commutativity property of natural numbers.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{open}\;\mathbf{import}\;\Conid{\Conid{Data}.Nat}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  This imports the standard library version of natural numbers, which is declared in the exactly same way.
  It allows us to use actual digits for their representations, which can enhance readability.

  Further down are some further proofs we need in order to show natural numbers are commutative.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbin{+}\mathrm{0}\mathbin{:}(\Varid{m}\mathbin{:}\Conid{ℕ})\mathbin{→}(\Varid{m}\mathbin{+}\mathrm{0})\mathbin{≡}\Varid{m}{}\<[E]%
\\
\>[3]{}\mathbin{+}\mathrm{0}\;\Varid{zero}\mathrel{=}\Varid{refl}{}\<[E]%
\\
\>[3]{}\mathbin{+}\mathrm{0}\;(\Varid{suc}\;\Varid{m})\;\Varid{rewrite}\mathbin{+}\mathrm{0}\;\Varid{m}\mathrel{=}\Varid{refl}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbin{+}\Varid{suc}\mathbin{:}\mathbin{∀}(\Varid{x}\;\Varid{y}\mathbin{:}\Conid{ℕ})\mathbin{→}(\Varid{x}\mathbin{+}(\Varid{suc}\;\Varid{y}))\mathbin{≡}(\Varid{suc}\;(\Varid{x}\mathbin{+}\Varid{y})){}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{suc}\;\Varid{zero}\;\Varid{y}\mathrel{=}\Varid{refl}{}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{suc}\;(\Varid{suc}\;\Varid{x})\;\Varid{y}\;\Varid{rewrite}\mathbin{+}\Varid{suc}\;\Varid{x}\;\Varid{y}\mathrel{=}\Varid{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Finally, the main proof:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbin{+}\Varid{comm}\mathbin{:}\mathbin{∀}(\Varid{x}\;\Varid{y}\mathbin{:}\Conid{ℕ})\mathbin{→}(\Varid{x}\mathbin{+}\Varid{y})\mathbin{≡}(\Varid{y}\mathbin{+}\Varid{x}){}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{comm}\;\Varid{zero}\;\Varid{y}\;\Varid{rewrite}\mathbin{+}\mathrm{0}\;\Varid{y}\mathrel{=}\Varid{refl}{}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{comm}\;(\Varid{suc}\;\Varid{x})\;\Varid{y}\;\Varid{rewrite}\mathbin{+}\Varid{suc}\;\Varid{x}\;\Varid{y}\mid {}\<[E]%
\\
\>[3]{}\hsindent{24}{}\<[27]%
\>[27]{}\mathbin{+}\Varid{suc}\;\Varid{y}\;\Varid{x}\mid {}\<[E]%
\\
\>[3]{}\hsindent{24}{}\<[27]%
\>[27]{}\mathbin{+}\Varid{comm}\;\Varid{x}\;\Varid{y}\mathrel{=}\Varid{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{open}\mathbin{≡-}\Conid{Reasoning}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  This is the module where all the equivalence reasoning primitives are declared.
  Now, the proof which uses this module.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbin{+}\Varid{comm2}\mathbin{:}\mathbin{∀}(\Varid{x}\;\Varid{y}\mathbin{:}\Conid{ℕ})\mathbin{→}(\Varid{x}\mathbin{+}\Varid{y})\mathbin{≡}(\Varid{y}\mathbin{+}\Varid{x}){}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{comm2}\;\Varid{zero}\;\Varid{y}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Varid{begin}\;{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Varid{zero}\mathbin{+}\Varid{y}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\mathbin{≡⟨}\Varid{sym}\;(\mathbin{+}\mathrm{0}\;\Varid{y})\mathbin{⟩}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Varid{y}\mathbin{+}\Varid{zero}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\mathbin{∎}{}\<[E]%
\\
\>[3]{}\mathbin{+}\Varid{comm2}\;(\Varid{suc}\;\Varid{x})\;\Varid{y}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{begin}\;{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{suc}\;(\Varid{x}\mathbin{+}\Varid{y}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbin{≡⟨}\Varid{cong}\;\Varid{suc}\;(\mathbin{+}\Varid{comm2}\;\Varid{x}\;\Varid{y})\mathbin{⟩}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{suc}\;(\Varid{y}\mathbin{+}\Varid{x}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbin{≡⟨}\Varid{sym}\;(\mathbin{+}\Varid{suc}\;\Varid{y}\;\Varid{x})\mathbin{⟩}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{y}\mathbin{+}\Varid{suc}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbin{∎}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Although it is longer, due to the extra syntax, it allows reading off intermediate results, so that
  proofs become more readable. \\
  It can also aid the proving process. There are cases when you know it's
  possible to prove an equivalence from A to B inside of a bigger proof, but you want to leave that out
  for the moment and come back to it later.
  In this case, you can just introduce a hole in the ≡⟨ {!   !} ⟩ operator, and continue the main proof,
  filling in side lemmas at the end.


\subsection{instance arguments}

-type classes in haskell\\
-the monoid record\\
-how we use it\\

\section{Views}

 The idea of a view was first introduced by Phil Wadler \cite{wadler} http://www.cs.tufts.edu/~nr/cs257/archive/phil-wadler/views.pdf . Originally
   it is meant as a way of reconcilling the conflict between data abstraction and pattern matching. The essence of views is representing an arbitrary
   data type as a newly defined and computationally meaningful algebraic data type. \\
 The cannonical example is 'viewing' a natural number in terms of it's peano representation. \\
 -- Example in haskell maybe?

 
\subsection{Example - Natural Numberss} 
 A more meaningful example is seeing a natural number as an even or odd number in terms of it's representation. That is, a
 natural number is even if it can be represented as n = 2 * k for some natural k and it is odd if it can be represented as
 n = 2 * k + 1.
 I will present some agda code that does exactly this, providing a functional way of checking if a number is even or odd and also
 performe floored division.

%-- here comes the agda code
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Repr}\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{z}{}\<[7]%
\>[7]{}\mathbin{:}\Conid{Repr}\;\mathrm{0}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrm{2}\mathbin{*\char95 }\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}\Conid{Repr}\;\Varid{n}\mathbin{→}\Conid{Repr}\;(\Varid{n}\mathbin{*}\mathrm{2}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrm{2}\mathbin{*\char95 +}\mathrm{1}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}\Conid{Repr}\;\Varid{n}\mathbin{→}\Conid{Repr}\;(\Varid{suc}\;(\Varid{n}\mathbin{*}\mathrm{2})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A few helper functions could help one realise how convenient this representation is in case recursive calls over the binary structure of natural number are needed (e.g. when searching in functional array).

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\anonymous \mathbin{+}\mathrm{1}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}\Conid{Repr}\;\Varid{n}\mathbin{→}\Conid{Repr}\;(\Varid{suc}\;\Varid{n}){}\<[E]%
\\
\>[B]{}\Varid{z}\mathbin{+}\mathrm{1}\mathrel{=}\mathrm{2}\mathbin{*}\Varid{z}\mathbin{+}\mathrm{1}{}\<[E]%
\\
\>[B]{}(\mathrm{2}\mathbin{*}\Varid{m})\mathbin{+}\mathrm{1}\mathrel{=}\mathrm{2}\mathbin{*}\Varid{m}\mathbin{+}\mathrm{1}{}\<[E]%
\\
\>[B]{}\mathrm{2}\mathbin{*}\Varid{m}\mathbin{+}\mathrm{1}\mathbin{+}\mathrm{1}\mathrel{=}\mathrm{2}\mathbin{*}(\Varid{m}\mathbin{+}\mathrm{1}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{repr}\mathbin{:}(\Varid{n}\mathbin{:}\Conid{ℕ})\mathbin{→}\Conid{Repr}\;\Varid{n}{}\<[E]%
\\
\>[B]{}\Varid{repr}\;\Varid{zero}\mathrel{=}\Varid{z}{}\<[E]%
\\
\>[B]{}\Varid{repr}\;(\Varid{suc}\;\Varid{n})\mathrel{=}(\Varid{repr}\;\Varid{n})\mathbin{+}\mathrm{1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Induction with views}
 An important point made \cite{wadler} is that the design of such views should allow inductive programs to be written on them.

 Views become especially usefull when the data type is very hard itself to reason about, such as the case of nested data-type or irregular
 datatypes.

 A simple example of such a view is an implementation of the cyclic list \cite{circular}.\\
 This is a cannonical example of a great structural need satisfied through typing only. 

%-- agda code for definition\\
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Clist}\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Conid{Var}\mathbin{:}\Conid{A}\mathbin{→}\Conid{Clist}\;\Conid{A}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Conid{Nil}\mathbin{:}\Conid{Clist}\;\Conid{A}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Conid{RCons}\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{Clist}\;(\Conid{Maybe}\;\Conid{A})\mathbin{→}\Conid{Clist}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This is a nested datatype, because each recursive invocation of the Rcons constructor will have type $CList (Maybe^{n} A) $ where $n$ is the recursion depth.
The implementations of the functions that operate on such datatype are presented in the Appendix. One would understand the need to view this data structure as a $ A × CList A $ rather than $ A × Clist (Maybe A) $, as unfolding in the latter way would cause unenecessary nestings of the $Maybe$ constructor.

%-- agda code for view\\
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{View}\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Conid{NilV}\mathbin{:}\Conid{View}\;\Conid{A}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Conid{ConsV}\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{Clist}\;\Conid{A}\mathbin{→}\Conid{View}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This is an implementation of a function that iterates through the cyclic list for a given depth which could possibly be used in a simulation. As said before, it is a lot more straight-forward to see the data structure in a flattened way, while keeping strong invariants underneath by the nested type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{unwind}\mathbin{:}\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\mathbin{→}\Conid{ℕ}\mathbin{→}\Conid{Clist}\;\Conid{A}\mathbin{→}\Conid{List}\;\Conid{ℕ}{}\<[E]%
\\
\>[3]{}\Varid{unwind}\;\Varid{\Conid{ℕ}.zero}\;\Varid{c}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[3]{}\Varid{unwind}\;(\Varid{\Conid{ℕ}.suc}\;\Varid{n})\;\Varid{c}\;\Varid{with}\;\Varid{view}\;\Varid{c}{}\<[E]%
\\
\>[3]{}\Varid{unwind}\;(\Varid{\Conid{ℕ}.suc}\;\Varid{n})\;\Varid{c}\mid \Conid{NilV}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[3]{}\Varid{unwind}\;(\Varid{\Conid{ℕ}.suc}\;\Varid{n})\;\Varid{c}\mid \Conid{ConsV}\;\Varid{x}\;\Varid{x₁}\mathrel{=}\Varid{x}\mathbin{∷}\Varid{unwind}\;\Varid{n}\;\Varid{x₁}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\section{Termination checking}

Checking whether a program terminates is, by a well-known result, undecidable. Hence, Agda and other theorem provers must rely on
heuristics that can rule out all the programs that do not terminate. Due to the undecidability of the halting problem, all such
heuristics will also reject programs that are correct. This dissertation was inspired by noticing how certain constructions in Agda,
although usefull from an implementation point of view, do not pass this termination check. We will be exploring ways to get
arround it.

Since we are interested not only in computing things, but also in checking that they are correct, termination is a mandatory aspect.
One can imagine very easily (false) proofs in terms of their type, but with no meaning.

\begin{verbatim}
--
  bad-proof : forall a b -> P a b
  bad-proof a b = bad-proof a b
--
\end{verbatim}

The heuristic used in Agda revolves around the concept of a structurally smaller argument. That is, every recursive call must have a structurally smaller argument (has less layers of constructors wrapped around eachother) in order to pass the termination check.



\subsection{Example - Regular Data Type} 
Consider, for example, this simple pathological case:

%-- list example
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{append}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\mathbin{→}\Conid{A}\mathbin{→}\Conid{List}\;\Conid{A}\mathbin{→}\Conid{List}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\Varid{append}\;\Varid{x}\;\Varid{xs}\;\Varid{with}\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\Varid{append}\;\Varid{x}\;\Varid{xs}\mid [\mskip1.5mu \mskip1.5mu]\mathrel{=}\Conid{\Conid{Data}.List}\mathbin{\circ}[\mskip1.5mu \Varid{x}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{append}\;\Varid{x}\;\Varid{xs}\mid \Varid{y}\mathbin{∷}\Varid{ys}\mathrel{=}\Varid{y}\mathbin{∷}\Varid{append}\;\Varid{x}\;\Varid{ys}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

One could argue that this fails because 'with' forgets where ys originally came from, as we have seen before. However, this is not the case: 

%-- list-inspect example
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{open}\;\mathbf{import}\;\Conid{\Conid{Relation}.\Conid{Binary}.PropositionalEquality}{}\<[E]%
\\
\>[B]{}\Varid{append2}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\mathbin{→}\Conid{A}\mathbin{→}\Conid{List}\;\Conid{A}\mathbin{→}\Conid{List}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\Varid{append2}\;\Varid{x}\;\Varid{xs}\;\Varid{with}\;\Varid{xs}\mid \Varid{inspect}\;(\Varid{λ}\;\Varid{x}\mathbin{→}\Varid{x})\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\Varid{append2}\;\Varid{x}\;\Varid{xs}\mid [\mskip1.5mu \mskip1.5mu]\mid [\mskip1.5mu \Varid{eq}\mskip1.5mu]\mathrel{=}\Conid{\Conid{Data}.List}\mathbin{\circ}[\mskip1.5mu \Varid{x}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{append2}\;\Varid{x}\;\Varid{xs}\mid \Varid{y}\mathbin{∷}\Varid{ys}\mid \Conid{Reveal\char95 }\mathbin{·\char95 }\Varid{is\char95 }\mathbin{\circ}[\mskip1.5mu \Varid{refl}\mskip1.5mu]\mathrel{=}\Varid{y}\mathbin{∷}(\Varid{append2}\;\Varid{x}\;\Varid{ys}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This is a proof that the 'with' construct in agda doens't interact well with Agda's termination checker. However, Having a structurally recursive dependent typing scheme actually works for this instance - in this case we will use Nat indexing, but this scheme will become more general in the implementation phase. We can extend the List data type and index it on the length, as seen before when we introduced dependent types:

%-- vec example
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{open}\;\mathbf{import}\;\Conid{\Conid{Data}.Vec}{}\<[E]%
\\
\>[B]{}\Varid{append3}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}\Conid{A}\mathbin{→}\Conid{Vec}\;\Conid{A}\;\Varid{n}\mathbin{→}\Conid{Vec}\;\Conid{A}\;(\Varid{suc}\;\Varid{n}){}\<[E]%
\\
\>[B]{}\Varid{append3}\;\Varid{x}\;\Varid{xs}\;\Varid{with}\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\Varid{append3}\;\Varid{x}\;\Varid{xs}\mid [\mskip1.5mu \mskip1.5mu]\mathrel{=}\Varid{x}\mathbin{∷}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{append3}\;\Varid{x}\;\Varid{xs}\mid \Varid{y}\mathbin{∷}\Varid{ys}\mathrel{=}\Varid{y}\mathbin{∷}(\Varid{append3}\;\Varid{x}\;\Varid{ys}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Example - Nested Data Type} 
As stated by Adam Chipala \cite{adm-ind}, there is no deep theoretical reason for which the termination checking should fail in the presence of such nested datatype, other that the termination checker is incomplete (refering to Coq, but is applicable in this context as well). As seen above, a simple solution to it is simply transfigurating the typing to a dependent one.

This is the declaration of Nest, as seen before. 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Nest}\;\{\mskip1.5mu \Varid{a}\mathbin{:}\Conid{Level}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\mathbin{:}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{nilN}{}\<[9]%
\>[9]{}\mathbin{:}\Conid{Nest}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{consN}\mathbin{:}(\Conid{A}\mathbin{×}\Conid{A})\mathbin{→}\Conid{Nest}\;(\Conid{A}\mathbin{×}\Conid{A})\mathbin{→}\Conid{Nest}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In this case, I am artificially creating a function with the sole purpose of creating a smaller datatype. It essentially reduces the tree by performing a given operation which takes as argument the pairs present in the leaves of the tree. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{compact}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mathbin{:}\Conid{Level}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\mathbin{→}\Conid{Nest}\;(\Conid{A}\mathbin{×}\Conid{A})\mathbin{→}(\Conid{A}\mathbin{×}\Conid{A}\mathbin{→}\Conid{A})\mathbin{→}\Conid{Nest}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\Varid{compact}\;\Varid{nilN}\;\Varid{op}\mathrel{=}\Varid{nilN}{}\<[E]%
\\
\>[B]{}\Varid{compact}\;(\Varid{consN}\;\Varid{p}\;\Varid{ns})\;\Varid{op}\mathrel{=}\Varid{consN}\;(\Varid{lift}\mathbin{-}\Varid{op}\;\Varid{op}\;\Varid{p})\;(\Varid{compact}\;\Varid{ns}\;(\Varid{lift}\mathbin{-}\Varid{op}\;\Varid{op})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 
The lift operation is just a map operation on the Product type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{lift}\mathbin{-}\Varid{op}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mathbin{:}\Conid{Level}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\mathbin{→}(\Conid{A}\mathbin{×}\Conid{A}\mathbin{→}\Conid{A})\mathbin{→}((\Conid{A}\mathbin{×}\Conid{A})\mathbin{×}(\Conid{A}\mathbin{×}\Conid{A}))\mathbin{→}(\Conid{A}\mathbin{×}\Conid{A}){}\<[E]%
\\
\>[B]{}\Varid{lift}\mathbin{-}\Varid{op}\;\Varid{op}\;(\Varid{proj₁},\Varid{proj₂})\mathrel{=}(\Varid{op}\;\Varid{proj₁},\Varid{op}\;\Varid{proj₂}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We introduce, as we did in the case of CList, a flattened view, together with a function that can convert between the two:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{View}\;\{\mskip1.5mu \Varid{a}\mathbin{:}\Conid{Level}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\mathbin{:}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{nilL}\mathbin{:}\Conid{View}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{consL}\mathbin{:}\Conid{A}\mathbin{→}\Conid{Nest}\;\Conid{A}\mathbin{→}\Conid{View}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{view}\mathbin{:}\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\mathbin{→}\Conid{Clist}\;\Conid{A}\mathbin{→}\Conid{View}\;\Conid{A}{}\<[E]%
\\
\>[3]{}\Varid{view}\;(\Conid{Var}\;\Varid{x})\mathrel{=}\Conid{NilV}{}\<[E]%
\\
\>[3]{}\Varid{view}\;\Conid{Nil}\mathrel{=}\Conid{NilV}{}\<[E]%
\\
\>[3]{}\Varid{view}\;(\Conid{RCons}\;\Varid{x}\;\Varid{cl})\mathrel{=}\Conid{ConsV}\;\Varid{x}\;(\Varid{csnoc}\;\Varid{x}\;\Varid{cl}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


It is not hard to infer, given the previous examples, that such a declaration would fail to pass the termination checker in case there is a recursive call. Therefore, we are modifying the code the same way we did with List, by declaring an index

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Varid{dNest}\;\{\mskip1.5mu \Varid{a}\mathbin{:}\Conid{Level}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{dnilN}\mathbin{:}\Varid{dNest}\;\Conid{A}\;\Varid{zero}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{dconsN}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}(\Conid{A}\mathbin{×}\Conid{A})\mathbin{→}\Varid{dNest}\;(\Conid{A}\mathbin{×}\Conid{A})\;\Varid{n}\mathbin{→}\Varid{dNest}\;\Conid{A}\;(\Varid{suc}\;\Varid{n}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Varid{dView}\;\{\mskip1.5mu \Varid{a}\mathbin{:}\Conid{Level}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\mathbin{:}\Conid{ℕ}\mathbin{→}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{dnilV}\mathbin{:}\Varid{dView}\;\Conid{A}\;\Varid{zero}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{dconsV}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{n}\mathbin{:}\Conid{ℕ}\mskip1.5mu\}\mathbin{→}\Conid{A}\mathbin{→}\Varid{dNest}\;\Conid{A}\;\Varid{n}\mathbin{→}\Varid{dView}\;\Conid{A}\;(\Varid{suc}\;\Varid{n}){}\<[E]%
\end{hscode}\resethooks


However, in the presence of a nested type, the structural recursive indexing fails to satisfy the type-checker.

\section{Well-Founded relations and Induction}

A well-founded relation is a relation R, (R ⊂ X×X) such that there is no infinite sequence x0, x1, x2, ... of elements of X such that xn+1 R xn. A less than
relation with this property can be used to implement a terminating induction definition, since we know that we cannot ever have an infinite sequence of
decreasing argument sizes in the call stack.
Tools for proving that a relation is Well-Founded and helper functions for defining recursive definitions are present in the standard library.

%think of a simple example to use the framework.
%what is well-founded induction \\ tb to larry paulson's paper: http://citeseerx.ist.psu.edu/viewdoc/download %doi=10.1.1.14.8921&rep=rep1&type=pdf \\ agda's standard library provides the tools \\

\chapter{Implementation}

Data structure design in functional programming has been greately improved by the publications of Okasaki \cite{okasaki} and those of Ross Patterson and Ralph Hinze. These papers introduce a number of concepts which has made possible a great efficiency speed-up in functional algorithms. The observation that the construction of numbers is equivalent to the construction of containers that hold that number of elements \cite{numerical} \cite{okasaki} has also provided developers with a general way of designing such constructors. However, implementing such data structures and proving correctness at the same time introduce some difficulties\\

In this section, I will present a dependently typed implementation of the Finger Tree\cite{rpat} and prove correctness of some methods. I will then instantiate the data structure to allow more specific uses. Next, I will point out the issues caused by the incomplete termination checker and provide a solution. Finally, I will 
bring Finger Trees into a larger context and show how these problems are not specific.    

\section{Finger Trees - Introduction} 

Finger Trees are a data structure introduced by Ralph Hinze and Robert Patinsson, based on Okasaki's principle of implicit recursive slowdown. \\ 
Initially meant as a double ended queue with constant amortized time append, their structure, together with the cached measurements, allow specialization to Random Access Sequences, or Priority Queues by simple instantiation. \\ 

%FIGURE 

The efficiency is achieved by keeping two invariants on the data structure:
\begin{itemize}
	\item The tree is full and all the leaves occur on the last level. 
	\item The measurements are correct\footnote{•}
\end{itemize}

Working in Agda, a dependently typed language, which moreover allows the use of nested types, we can keep these invariants soley in the type of the Finger Tree. More specifically,
\begin{itemize}
	\item The nested typing will ensure fullness of the tree.
	\item Choosing measurements as the type index ensures their correctness.  
\end{itemize} 

Moreover, the measurement as a type index greatly simplifies proofs when the measurement function is chosen carefully.

\section{Previous work on Finger Trees} 
Finger Trees have been previously implemented and proved correct. I will outline some previous results, as well as their limitations, providing more incentives for this dissertation. I have included all related implementations I could find and I do not guarantee they are the only ones.

\begin{itemize}
\item Basic Implementation in Agda. \\
This version can be found on GitHub\footnote{•}. Its mentioned intention is to closely follow the original paper. It also uses introduces the idea of Sizing, although only in the type declaration (and constructors). Since the constraints are not present in functions that modify the data type, they do not really aid correctness proofs. It has no proofs associated with it, and it didn't type check on my machine.
\item Implementation in Coq. \\
This implementation is provided by Matthiew Souzeau\cite{coq} as a proof of concept for '.i forgot what it's called.', a Coq extension. I have drawn great inspiration from that paper, and I was particularly drawn by its small caveat, onto which I will return at the end of this chapter. Although a full and working implementation, I argue that this dissertation is valuable in its own, given my aforementioned reasons for choosing Agda as the programming language, and providing a solution to some caveats.
\item Implementation in Isabelle. \\
Another working implementation has been done in Isabelle. However, this implementation diverges from the original specification of the data structure, removing the nesting. The two invariants that I have mentioned are maintained explicitly. The paper follows an external verification paradigm, whereas I aimed for an internally verified one.\\ 
The implementation of this data structure in both Coq and Isabelle, two established theorem provers might argue both for the complexity involved, and for its interesting particularities.
\end{itemize}

\section{Finger Trees - Implementation}

This is the main section, where implementation of key points is presented and discussed\footnote{For a full implementation refer to the Appendix}


\subsection{Data type declaration} 

The Finger Tree is originally polymorphic in two types:
\begin{itemize}

\item \textbf{A} : this is the type of the elements that are contained in the Finger Tree 
\item \textbf{V} : this is the type of the measures of the elements. 

\end{itemize} 


In the attempt to mimic Haskell's typeclasses, I have carried around, for each A and V, two constructs:

\begin{itemize} 
\item \textbf{Monoid\footnote{see AlgebraStructures.agda} V}: which contains a neutral element(\textbf{ε}), a binary operator(\textbf{∙}), and the monoid axioms, and a comparison operator.
\item \textbf{Measured A V} : which consists of a norm function  :  \textbf{$\Vert \Vert : \nolinebreak A \rightarrow V$}
I am also constraining this measurement function, so that $\forall x \in A, \Vert x \Vert \geq \varepsilon $. This is to further ensure that, for some Finger Tree ft, if $ \Vert ft \Vert \geq \varepsilon$, then $ft \neq Empty$ 
In the section 3.whatever I will show how this can be abstracted away from the user. 


\end{itemize} 


\textbf{Node} corresponds to nodes in the underlying 2-3 tree implementation, having two constructors that contain two and respectively three items. Moreover, \textbf{Node}s can only be constructed if provided with a measurement tag and a correctness proof.
  
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Node}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\;(\Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}\mathbin{:}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Node2}\mathbin{:}(\Varid{v}\mathbin{:}\Conid{V})\mathbin{→}(\Varid{x}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{y}\mathbin{:}\Conid{A})\mathbin{→}{}\<[E]%
\\
\>[3]{}\hsindent{8}{}\<[11]%
\>[11]{}(\Varid{v}\mathbin{≡}\mathbin{∥}\Varid{x}\mathbin{∥}\mathbin{∙}\mathbin{∥}\Varid{y}\mathbin{∥})\mathbin{→}\Conid{Node}\;\Conid{A}\;\Conid{V}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Node3}\mathbin{:}(\Varid{v}\mathbin{:}\Conid{V})\mathbin{→}(\Varid{x}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{y}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{z}\mathbin{:}\Conid{A})\mathbin{→}{}\<[E]%
\\
\>[3]{}\hsindent{8}{}\<[11]%
\>[11]{}(\Varid{v}\mathbin{≡}\mathbin{∥}\Varid{x}\mathbin{∥}\mathbin{∙}\mathbin{∥}\Varid{y}\mathbin{∥}\mathbin{∙}\mathbin{∥}\Varid{z}\mathbin{∥})\mathbin{→}\Conid{Node}\;\Conid{A}\;\Conid{V}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 
\textbf{Digit}s were in presented in the original paper as lists, but this definition limits them to have one to four elements.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Digit}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\mathbin{:}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{One}{}\<[9]%
\>[9]{}\mathbin{:}\Conid{A}\mathbin{→}\Conid{Digit}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Two}{}\<[9]%
\>[9]{}\mathbin{:}\Conid{A}\mathbin{→}\Conid{A}\mathbin{→}\Conid{Digit}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Three}\mathbin{:}\Conid{A}\mathbin{→}\Conid{A}\mathbin{→}\Conid{A}\mathbin{→}\Conid{Digit}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Four}{}\<[9]%
\>[9]{}\mathbin{:}\Conid{A}\mathbin{→}\Conid{A}\mathbin{→}\Conid{A}\mathbin{→}\Conid{A}\mathbin{→}\Conid{Digit}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Finally, the \textbf{FingerTree} is a family of types, indexed by a measurement $\mu$. The measurement's correctness is enforced in all the constructors. Note the nested type and the universal quantification over possible sizes for the recursive call. Apart from the measurement addition, the rest corresponds to the original paper.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}c<{\hspost}@{}}%
\column{10E}{@{}l@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{59}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{FingerTree}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\;(\Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{17}{}\<[17]%
\>[17]{}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}\mathbin{:}{}\<[59]%
\>[59]{}\{\mskip1.5mu \Varid{μ}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Empty}{}\<[10]%
\>[10]{}\mathbin{:}{}\<[10E]%
\>[13]{}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{ε}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Single}\mathbin{:}{}\<[13]%
\>[13]{}(\Varid{e}\mathbin{:}\Conid{A})\mathbin{→}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \mathbin{∥}\Varid{e}\mathbin{∥}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Deep}{}\<[10]%
\>[10]{}\mathbin{:}{}\<[10E]%
\>[13]{}\{\mskip1.5mu \Varid{s}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}{}\<[E]%
\\
\>[13]{}(\Varid{pr}\mathbin{:}\Conid{Digit}\;\Conid{A})\mathbin{→}\Conid{FingerTree}\;(\Conid{Node}\;\Conid{A}\;\Conid{V})\;\Conid{V}\;\{\mskip1.5mu \Varid{s}\mskip1.5mu\}\mathbin{→}(\Varid{sf}\mathbin{:}\Conid{Digit}\;\Conid{A})\mathbin{→}{}\<[E]%
\\
\>[13]{}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{pr}\mathbin{∙}\Varid{s}\mathbin{∙}\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{sf}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsection{\textit{Cons} and \textit{Snoc}}

The dependent typing allows a fine intertwining between coding and proofs, and this is an example where Agda's simplicity is best seen.

Implementing a cons(\textbf{◁})\footnote{appends an element to the left of the Finger Tree} operator is also accompanied by a proof that the result's measure will be equal to the sum of the argument's measure.

I will give the type declaration and some necessary axioms\footnote{the full implementation is in the Appendix}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{infixr}\;\mathrm{5}\;\anonymous \mathbin{◁\char95 }{}\<[E]%
\\
\>[B]{}\anonymous \mathbin{◁\char95 }\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\{\mskip1.5mu \Varid{s}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}(\Varid{x}\mathbin{:}\Conid{A})\mathbin{→}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\mathbin{⦃}\Varid{mo}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{⦄}\{\mskip1.5mu \Varid{s}\mskip1.5mu\}\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\mathbin{⦃}\Varid{mo}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{⦄}\{\mskip1.5mu \mathbin{∥}\Varid{x}\mathbin{∥}\mathbin{∙}\Varid{s}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As in the Vec example, the type is indicative of what the function is doing, and a function of this signature
ensures that the output will have the correct measure. We can further prove that it also contains the expected elements, and I will do this in the Evaluation as an external verification procedure.

By performing a case split on the FingerTree, and further on the prefix Digit (in the Deep constructor), we have to implement the function for six cases. I will show the implementation of a simple case and that of the recursive case in detail.


-- cons-deep-one
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{a}\mathbin{◁}\Conid{Deep}\;(\Conid{One}\;\Varid{b})\;\Varid{ft}\;\Varid{sf}\;\Varid{rewrite}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\mathbin{∙-}\Varid{assoc}\;(\mathbin{∥}\Varid{a}\mathbin{∥})\;(\mathbin{∥}\Varid{b}\mathbin{∥})\;(\Varid{measure}\mathbin{-}\Varid{tree}\;\Varid{ft}\mathbin{∙}\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{sf}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathrel{=}\Conid{Deep}\;(\Conid{Two}\;\Varid{a}\;\Varid{b})\;\Varid{ft}\;\Varid{sf}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The result of this computation is identical to the one in the original paper. However, in order for it to type check, I had to include a proof of correctness, in the form of a rewrite statement, by using the associativity   property of the monoid.

-- cons--deep-four
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{a}\mathbin{◁}\Conid{Deep}\;(\Conid{Four}\;\Varid{b}\;\Varid{c}\;\Varid{d}\;\Varid{e})\;\Varid{ft}\;\Varid{sf}\;\Varid{rewrite}\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{assoc}\mathbin{-}\Varid{lemma2}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{d}\;\Varid{e}\;(\Varid{measure}\mathbin{-}\Varid{tree}\;\Varid{ft})\;(\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{sf}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathrel{=}\Conid{Deep}\;(\Conid{Two}\;\Varid{a}\;\Varid{b})\;((\Varid{node3}\;\Varid{c}\;\Varid{d}\;\Varid{e})\mathbin{◁}\Varid{ft})\;\Varid{sf}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This case is the recursive case, and the proof in this case turned out to be more verbose.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{assoc}\mathbin{-}\Varid{lemma2}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}(\Varid{a}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{b}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{c}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{d}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{e}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{s}\mathbin{:}\Conid{V})\mathbin{→}(\Varid{f}\mathbin{:}\Conid{V})\mathbin{→}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}(\Varid{mo}\mathbin{\Conid{Monoid}.∙}\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{a})\;{}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}((\Varid{mo}\mathbin{\Conid{Monoid}.∙}{}\<[E]%
\\
\>[15]{}\hsindent{2}{}\<[17]%
\>[17]{}(\Varid{mo}\mathbin{\Conid{Monoid}.∙}\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{b}){}\<[E]%
\\
\>[15]{}\hsindent{2}{}\<[17]%
\>[17]{}((\Varid{mo}\mathbin{\Conid{Monoid}.∙}\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{c}){}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}((\Varid{mo}\mathbin{\Conid{Monoid}.∙}\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{d})\;(\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{e})))){}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}((\Varid{mo}\mathbin{\Conid{Monoid}.∙}\Varid{s})\;\Varid{f})){}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\mathbin{≡}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}(\Varid{mo}\mathbin{\Conid{Monoid}.∙}(\Varid{mo}\mathbin{\Conid{Monoid}.∙}\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{a})\;(\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{b}))\;{}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}((\Varid{mo}\mathbin{\Conid{Monoid}.∙}{}\<[E]%
\\
\>[15]{}\hsindent{1}{}\<[16]%
\>[16]{}(\Varid{mo}\mathbin{\Conid{Monoid}.∙}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{}(\Varid{mo}\mathbin{\Conid{Monoid}.∙}\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{c}){}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{}((\Varid{mo}\mathbin{\Conid{Monoid}.∙}\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{d})\;(\mathbin{\Conid{Measured}.∥}\Varid{m}\mathbin{∥}\Varid{e}))){}\<[E]%
\\
\>[15]{}\hsindent{1}{}\<[16]%
\>[16]{}\Varid{s}){}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


A lot of the textual complexity can be reduced by using infix notation. The reason I have left it like this is because the type signature has been generated by Agda. If left without the rewrite statement, Agda prompts us with an error, which is also what remains to be proved. 

The \textbf{Snoc} operator has the same structure, but it appends the new element to the right. Its type is analogous.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\anonymous \mathbin{▷\char95 }\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\{\mskip1.5mu \Varid{s}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}(\Varid{x}\mathbin{:}\Conid{A})\mathbin{→}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{s}\mskip1.5mu\}\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{s}\mathbin{∙}\mathbin{∥}\Varid{x}\mathbin{∥}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Deconstructing sequences -- Views}

Our goal is to extract the first element of the Finger Tree (from the Left here), while also returning a correct tail. This is equivalent to defining a convenient View\cite{wadler} on the tree. Some extra work has to be done in order to maintain the invariant of the measurement. Specifically, the Finger Tree and its view should have the same measure.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{ViewL}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\;(\Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a})\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}\mathbin{:}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\{\mskip1.5mu \Varid{s}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{NilL}\mathbin{:}{}\<[11]%
\>[11]{}\Conid{ViewL}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{ε}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ConsL}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{z}\mathbin{:}\Conid{V}\mskip1.5mu\}\;(\Varid{x}\mathbin{:}\Conid{A})\mathbin{→}(\Varid{xs}\mathbin{:}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{z}\mskip1.5mu\})\mathbin{→}{}\<[E]%
\\
\>[3]{}\hsindent{8}{}\<[11]%
\>[11]{}\Conid{ViewL}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \mathbin{∥}\Varid{x}\mathbin{∥}\mathbin{∙}\Varid{z}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The ConsL constructor is similar to the Cons operator declared before, and this similarity can be seen in the measurement. 
Ensuring the the finger tree and it view will have the same measurement is done with the correct instatiation of the viewL function: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{viewL}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\{\mskip1.5mu \Varid{i}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{i}\mskip1.5mu\}\mathbin{→}\Conid{ViewL}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{i}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The cases where the prefix has length greater than one are trivial. Deconstructing the tree is just a matter of returning the head of the Digit and calling the Deep constructor with the tail of the digit. However, for the case when the tail is empty, a special constructor needs to be implemented.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{deepL}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\{\mskip1.5mu \Varid{s}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{pr}\mathbin{:}\Conid{Maybe}\;(\Conid{Digit}\;\Conid{A}))\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{ft}\mathbin{:}\Conid{FingerTree}\;(\Conid{Node}\;\Conid{A}\;\Conid{V})\;\Conid{V}\;\{\mskip1.5mu \Varid{s}\mskip1.5mu\})\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{sf}\mathbin{:}\Conid{Digit}\;\Conid{A})\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{measure}\mathbin{-}\Varid{maybe}\mathbin{-}\Varid{digit}\;\Varid{pr}\mathbin{∙}\Varid{s}\mathbin{∙}\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{sf}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Splitting}

The \textbf{Split} data type is a more generalized version of the previously declared ViewL. In this case the Finger Tree is deconstructed somewhere in the middle, and packed in a container that keeps the left sequence, the middle element and the right sequence. 

We need to make sure to preserve the measurement of this data type. As before, we will continue to use V-indexing. 

One can see from this declaration, together with the constraint on the norm operator, that there cannot be a split of size $\varepsilon$

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Split}\mathbin{-}\Varid{d}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a})\;(\Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a})\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}\mathbin{:}{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}\{\mskip1.5mu \Varid{μ}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}\Conid{Set}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{split}\mathbin{-}\Varid{d}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{μ₁}\mathbin{:}\Conid{V}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{μ₂}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}(\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{μ₁}\mskip1.5mu\})\mathbin{→}{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}(\Varid{x}\mathbin{:}\Conid{A})\mathbin{→}{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}(\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{μ₂}\mskip1.5mu\})\mathbin{→}{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}\Conid{Split}\mathbin{-}\Varid{d}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{μ₁}\mathbin{∙}\mathbin{∥}\Varid{x}\mathbin{∥}\mathbin{∙}\Varid{μ₂}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The splitting function is supplied with a boolean predicate \textbf{p} and a starting value \textbf{i}, which indicate where the split occurs. 

We begin to iterate through the finger tree, by cummulating the norm of elements as we go along. The procedure continues until the accumulated value turns the predicate true, in which case the element we needed has been found.

Although it seems to be an expensive operation, the cached measurements, together with the associativity property, make this operation logarithmic. We do not need to go through all the leaves in a \textbf{Digit} or \textbf{Node} to find what their cummulated measure is.

As an example, we can find the ViewL construction by setting $p(x) = true$ for all x.


Next, I will present the split operation which is a bit lengthy. The implementation could have been written more concisely by using the 'with' construction. However, a small shortcoming of Agda's typechecker in its presence can cause some important information to be lost on the way. This makes the measurement correctness unprovable, and thus the whole split function, since one requires the other.

I have therefore created a new function for each case and passed the 'current information' as Equivalence relations in the argument, similar to the \textbf{Node} constructors.



\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{split}\mathbin{-}\Conid{Tree}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  type class information}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\{\mskip1.5mu \Varid{μ}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Varid{p}\mathbin{:}\Conid{V}\mathbin{→}\Conid{Bool})\mathbin{→}(\Varid{i}\mathbin{:}\Conid{V})\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  predicate and inital value}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Varid{ft}\mathbin{:}\Conid{FingerTree}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{μ}\mskip1.5mu\})\mathbin{→}\Conid{Maybe}\;(\Conid{Split}\mathbin{-}\Varid{d}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu \Varid{μ}\mskip1.5mu\}){}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  argument and proof that the split has the same size}{}\<[E]%
\\
\>[B]{}\Varid{split}\mathbin{-}\Conid{Tree}\;\Varid{p}\;\Varid{i}\;\Conid{Empty}\mathrel{=}\Varid{nothing}{}\<[33]%
\>[33]{}\mbox{\onelinecomment  cannot split an empty tree}{}\<[E]%
\\
\>[B]{}\Varid{split}\mathbin{-}\Conid{Tree}\mathbin{⦃}\Varid{mo}\mathbin{⦄}\Varid{p}\;\Varid{i}\;(\Conid{Single}\;\Varid{e})\mathrel{=}\Varid{just}\;(\Varid{split}\mathbin{-}\Conid{Tree}\mathbin{-}\Varid{single}\;\Varid{p}\;\Varid{i}\;\Varid{e}){}\<[E]%
\\
\>[B]{}\Varid{split}\mathbin{-}\Conid{Tree}\;\Varid{p}\;\Varid{i}\;(\Conid{Deep}\;\Varid{pr}\;\Varid{ft}\;\Varid{sf})\mathrel{=}\Varid{just}\;(\Varid{split}\mathbin{-}\Conid{Tree}\mathbin{-}\mathbf{if}\;\Varid{p}\;\Varid{i}\;\Varid{pr}\;\Varid{ft}\;\Varid{sf}\;\Varid{vpr}\;\Varid{refl}\;\Varid{vft}\;\Varid{refl}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{vpr}\mathrel{=}\Varid{p}\;(\Varid{i}\mathbin{∙}(\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{pr})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{vft}\mathrel{=}\Varid{p}\;((\Varid{i}\mathbin{∙}\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{pr})\mathbin{∙}\Varid{measure}\mathbin{-}\Varid{tree}\;\Varid{ft}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The interesting case here is the Deep one. The \textbf{split-tree-if} function does the case analysis for the cummulated measurements. We need to pass it the what would be cummulated at the end of the prefix (\textbf{vpr}), as well as what is cummulated and the beginning of the suffix (\textbf{vft}). We also need to show the called method that their values represent what we intended.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{split}\mathbin{-}\Conid{Tree}\mathbin{-}\mathbf{if}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{V}\mathbin{:}\Conid{Set}\;\Varid{a}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mathbin{⦃}\Varid{mo}\mathbin{:}\Conid{Monoid}\;\Conid{V}\mathbin{⦄}\mathbin{⦃}\Varid{m}\mathbin{:}\Conid{Measured}\;\Conid{A}\;\Conid{V}\mathbin{⦄}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  type class information}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\{\mskip1.5mu \Varid{μ}\mathbin{:}\Conid{V}\mskip1.5mu\}\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Varid{p}\mathbin{:}\Conid{V}\mathbin{→}\Conid{Bool})\mathbin{→}(\Varid{i}\mathbin{:}\Conid{V})\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  predicate and initial value}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Varid{pr}\mathbin{:}\Conid{Digit}\;\Conid{A})\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Varid{ft}\mathbin{:}\Conid{FingerTree}\;(\Conid{Node}\;\Conid{A}\;\Conid{V})\;\Conid{V}\;\{\mskip1.5mu \Varid{μ}\mskip1.5mu\})\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Varid{sf}\mathbin{:}\Conid{Digit}\;\Conid{A})\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  flattened deep constructor}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Varid{vpr}\mathbin{:}\Conid{Bool})\mathbin{→}(\Varid{vpr}\mathbin{≡}\Varid{p}\;(\Varid{i}\mathbin{∙}\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{pr}))\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  passing the cummulated value at the prefix + proof of not cheating}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Varid{vft}\mathbin{:}\Conid{Bool})\mathbin{→}(\Varid{vft}\mathbin{≡}\Varid{p}\;((\Varid{i}\mathbin{∙}\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{pr})\mathbin{∙}(\Varid{measure}\mathbin{-}\Varid{tree}\;\Varid{ft})))\mathbin{→}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  passing the cummulated value at the suffix + proof of not cheating}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\Conid{Split}\mathbin{-}\Varid{d}\;\Conid{A}\;\Conid{V}\;\{\mskip1.5mu (\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{pr})\mathbin{∙}\Varid{μ}\mathbin{∙}(\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{sf})\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\mbox{\onelinecomment  giving back the correct-sized split}{}\<[E]%
\\
\>[B]{}\Varid{split}\mathbin{-}\Conid{Tree}\mathbin{-}\mathbf{if}\;\Varid{p}\;\Varid{i}\;\Varid{pr}\;\Varid{ft}\;\Varid{sf}\;\Varid{false}\;\Varid{pr1}\;\Varid{false}\;\Varid{pr2}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{split}\mathbin{-}\Conid{Tree2}\;\Varid{p}\;((\Varid{i}\mathbin{∙}\Varid{measure}\mathbin{-}\Varid{digit}\;\Varid{pr})\mathbin{∙}(\Varid{measure}\mathbin{-}\Varid{tree}\;\Varid{ft}))\;\Varid{pr}\;\Varid{ft}\;\Varid{sf}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mbox{\onelinecomment  case2 : predicate becomes true in suffix or it doesn't become true at all}{}\<[E]%
\\
\>[B]{}\Varid{split}\mathbin{-}\Conid{Tree}\mathbin{-}\mathbf{if}\;\Varid{p}\;\Varid{i}\;\Varid{pr}\;\Varid{ft}\;\Varid{sf}\;\Varid{false}\;\Varid{pr1}\;\Varid{true}\;\Varid{pr2}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{split}\mathbin{-}\Conid{Tree3}\;\Varid{p}\;\Varid{i}\;\Varid{pr}\;\Varid{ft}\;\Varid{sf}\;(\Varid{sym}\;\Varid{pr1})\;(\Varid{sym}\;\Varid{pr2}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mbox{\onelinecomment  case3 : predicate becomes true in tree}{}\<[E]%
\\
\>[B]{}\Varid{split}\mathbin{-}\Conid{Tree}\mathbin{-}\mathbf{if}\;\Varid{p}\;\Varid{i}\;\Varid{pr}\;\Varid{ft}\;\Varid{sf}\;\Varid{true}\;\Varid{pr1}\;\Varid{vft}\;\Varid{pr2}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{split}\mathbin{-}\Conid{Tree1}\;\Varid{p}\;\Varid{i}\;\Varid{pr}\;\Varid{ft}\;\Varid{sf}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mbox{\onelinecomment  case1 : predicate becomes true in prefix}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

I have numbered the cases in the same way they were numbered in the original paper. 

-- SHOULD I GO THROUGH EACH CASE?



































\section{Numerical Representations -- Move these guys at the end of implementation -- since they are extra stuff anyway}
The treatment of containers as natural numbers has been studied in depth\cite{okasaki}. The basic idea is that simple numerical operations correspond naturally to operations on containers. For example:

\vspace{5mm} %5mm vertical space 
\begin{tabular}{lcl}
increasing a number & corresponds to & adding an element\\
decreasing a number & corresponds to & removing an element \\
adding two numbers & corresponds to & merging to containers \\
\end{tabular} 
\clearpage 

This treatment of numbers, represented in various numerical basis, allows the constructions the obey the implicit recursive slowdown, presented by okasaki. This allows in lazy languages like Haskell, implementation of operations such as insertion and deletion in ammortised O(1) cost -- which represented a breakthrough in functional programming languages.

\section{Random Access Sequences -- move this lower}

In this section, I will present a data structure as implemented by Ralph Hinze\cite{numerical} and show the issues that could arise because of the termination checker in more detail. 

Consider the trivial implementation of a binary tree in a functional programming language:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{module}\;\Varid{bush}\;\mathbf{where}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{data}\;\Conid{Bush}\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Leaf}\mathbin{:}\Conid{A}\mathbin{→}\Conid{Bush}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Fork}\mathbin{:}\Conid{Bush}\;\Conid{A}\mathbin{→}\Conid{Bush}\;\Conid{A}\mathbin{→}\Conid{Bush}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In order to stay consistent with the original implementation, the data structure above will be split in two different types that represent the constructors \cite{numerical}.

%-- constructors.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{module}\;\Varid{ral}\;\mathbf{where}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{data}\;\Conid{Leaf}\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{LEAF}\mathbin{:}\Conid{A}\mathbin{→}\Conid{Leaf}\;\Conid{A}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{data}\;\Conid{Fork}\;(\Conid{B}\mathbin{:}\Conid{Set}\mathbin{→}\Conid{Set})\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{FORK}\mathbin{:}(\Conid{B}\;\Conid{A})\mathbin{→}(\Conid{B}\;\Conid{A})\mathbin{→}\Conid{Fork}\;\Conid{B}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


We can now refer to the Random Access Sequence implementation.
They are a numerical representation based on base two of natural numbers, however, rather than the 0-1 system, the author prefers to use the 1-2 system for a number of effiency reasons.

\begin{center}
	\begin{tabular}{lcl}
	$inc(\epsilon$) & = & $1$ \\
	$inc(1a)$ & = & $2a$ \\ 
	$inc(2a)$ & = & $1inc(a)$ \\
	\end{tabular} 
\end{center}

This $inc$ operator should correspond analogously to the 'Cons' operators in the data structure:

%--RAL
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{data}\;\Conid{RandomAccessList}\;(\Conid{B}\mathbin{:}\Conid{Set}\mathbin{→}\Conid{Set})\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Nil}\mathbin{:}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{One}\mathbin{:}(\Conid{B}\;\Conid{A})\mathbin{→}(\Conid{RandomAccessList}\;(\Conid{Fork}\;\Conid{B})\;\Conid{A}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Two}\mathbin{:}(\Conid{Fork}\;\Conid{B}\;\Conid{A})\mathbin{→}(\Conid{RandomAccessList}\;(\Conid{Fork}\;\Conid{B})\;\Conid{A}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


Now, by implemending the function $incr$, we can see the similarity between the adding an element to the left and the number representation 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{incr}\mathbin{:}\{\mskip1.5mu \Conid{B}\mathbin{:}\Conid{Set}\mathbin{→}\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\mathbin{→}(\Conid{B}\;\Conid{A})\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\Varid{incr}\;\Varid{b}\;\Conid{Nil}\mathrel{=}\Conid{One}\;\Varid{b}\;\Conid{Nil}{}\<[E]%
\\
\>[5]{}\Varid{incr}\;\Varid{b}\;(\Conid{One}\;\Varid{b₂}\;\Varid{ds})\mathrel{=}\Conid{Two}\;(\Conid{FORK}\;\Varid{b}\;\Varid{b₂})\;\Varid{ds}{}\<[E]%
\\
\>[5]{}\Varid{incr}\;\Varid{b}\;(\Conid{Two}\;\Varid{b₂}\;\Varid{ds})\mathrel{=}\Conid{One}\;\Varid{b}\;(\Varid{incr}\;\Varid{b₂}\;\Varid{ds}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can finally declare a sequence, by using the definition of Leaf as a layer of abstraction.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{cons}\mathbin{:}\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\mathbin{→}\Conid{A}\mathbin{→}\Conid{IxSequence}\;\Conid{A}\mathbin{→}\Conid{IxSequence}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\Varid{cons}\;\Varid{a}\;\Varid{s}\mathrel{=}\Varid{incr}\;(\Conid{LEAF}\;\Varid{a})\;\Varid{s}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Example Method}

Here is the implementations of a method that illustrates the sequences' use. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{open}\;\mathbf{import}\;\Conid{\Conid{Data}.List}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\Varid{fromList}\mathbin{:}\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\mathbin{→}\Conid{List}\;\Conid{A}\mathbin{→}\Conid{IxSequence}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\Varid{fromList}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\Conid{Nil}{}\<[E]%
\\
\>[5]{}\Varid{fromList}\;(\Varid{x}\mathbin{∷}\Varid{xs})\mathrel{=}\Varid{cons}\;\Varid{x}\;(\Varid{fromList}\;\Varid{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsection{Defining a view} 

We can then implement the $front$ method, which returns a view of the list in terms of the first element and a continutation. Our goal is to abstract away the intricacy of the type declaration, so we can implement methods  easily. First, we need to declare the return type, wrapped in a view data structure.

%--View %--front

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{open}\;\mathbf{import}\;\Conid{\Conid{Data}.Product}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathbf{data}\;\Conid{View}\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Vnil}\mathbin{:}\Conid{View}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{VCns}\mathbin{:}\Conid{A}\mathbin{×}\Conid{IxSequence}\;\Conid{A}\mathbin{→}\Conid{View}\;\Conid{A}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\Varid{front}\mathbin{:}\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\mathbin{→}\Conid{IxSequence}\;\Conid{A}\mathbin{→}\Conid{View}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\Varid{front}\;\Conid{Nil}\mathrel{=}\Conid{Vnil}{}\<[E]%
\\
\>[5]{}\Varid{front}\;(\Conid{One}\;(\Conid{LEAF}\;\Varid{x})\;\Varid{ds})\mathrel{=}\Conid{VCns}\;(\Varid{x},\Varid{zero}\;\Varid{ds}){}\<[E]%
\\
\>[5]{}\Varid{front}\;(\Conid{Two}\;(\Conid{FORK}\;(\Conid{LEAF}\;\Varid{a})\;\Varid{b})\;\Varid{ds})\mathrel{=}\Conid{VCns}\;(\Varid{a},\Conid{One}\;\Varid{b}\;\Varid{ds}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The zero method is a restructuring method, as we will find in the Finger Tree implementation.

%-zero 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{zero}\mathbin{:}\{\mskip1.5mu \Conid{B}\mathbin{:}\Conid{Set}\mathbin{→}\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\mathbin{→}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{RandomAccessList}\;(\Conid{Fork}\;\Conid{B})\;\Conid{A}\mathbin{→}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\Varid{zero}\;\Conid{Nil}\mathrel{=}\Conid{Nil}{}\<[E]%
\\
\>[5]{}\Varid{zero}\;(\Conid{One}\;\Varid{b}\;\Varid{ds})\mathrel{=}\Conid{Two}\;\Varid{b}\;(\Varid{zero}\;\Varid{ds}){}\<[E]%
\\
\>[5]{}\Varid{zero}\;(\Conid{Two}\;(\Conid{FORK}\;\Varid{b₁}\;\Varid{b₂})\;\Varid{ds})\mathrel{=}\Conid{Two}\;\Varid{b₁}\;(\Conid{One}\;\Varid{b₂}\;\Varid{ds}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Example termination failure}

Here, Agda termination checker will fail. We will try to implement an append function, which is a straightforward process given the methods previously declared:

%-append
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{append}\mathbin{:}\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\mathbin{→}\Conid{A}\mathbin{→}\Conid{IxSequence}\;\Conid{A}\mathbin{→}\Conid{IxSequence}\;\Conid{A}{}\<[E]%
\\
\>[5]{}\Varid{append}\;\Varid{x}\;\Varid{seq}\;\Varid{with}\;\Varid{front}\;\Varid{seq}{}\<[E]%
\\
\>[5]{}\Varid{append}\;\Varid{x}\;\Varid{seq}\mid \Conid{Vnil}\mathrel{=}\Varid{cons}\;\Varid{x}\;\Conid{Nil}{}\<[E]%
\\
\>[5]{}\Varid{append}\;\Varid{x}\;\Varid{seq}\mid \Conid{VCns}\;(\Varid{head},\Varid{tail})\mathrel{=}\Varid{cons}\;\Varid{head}\;(\Varid{append}\;\Varid{x}\;\Varid{tail}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Using sized types}

Sized types are agda's response to fixing such issues. However, trying to come up with an implementation that type checks, even in this relatively simple case seems to be very difficult. The intuition in this case is that we need to convince agda that FORK a b is bigger than any individual a b in the context of the RAL constructors. However, sized types are only relative, not on an absolute scale.

%-- size code, cannot be completed
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{module}\;\Varid{ral}\mathbin{-}\Varid{sized}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{open}\;\mathbf{import}\;\Conid{Size}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{data}\;\Conid{Leaf}\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{LEAF}\mathbin{:}\Conid{A}\mathbin{→}\Conid{Leaf}\;\Conid{A}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{data}\;\Conid{Fork}\;(\Conid{B}\mathbin{:}\Conid{Set}\mathbin{→}\Conid{Set})\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{FORK}\mathbin{:}(\Conid{B}\;\Conid{A})\mathbin{→}(\Conid{B}\;\Conid{A})\mathbin{→}\Conid{Fork}\;\Conid{B}\;\Conid{A}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\\
\>[5]{}\mathbf{data}\;\Conid{RandomAccessList}\;(\Conid{B}\mathbin{:}\Conid{Set}\mathbin{→}\Conid{Set})\;(\Conid{A}\mathbin{:}\Conid{Set})\mathbin{:}\{\mskip1.5mu \Varid{i}\mathbin{:}\Conid{Size}\mskip1.5mu\}\mathbin{→}\Conid{Set}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Nil}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{i}\mskip1.5mu\}\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}\;\{\mskip1.5mu \Varid{i}\mskip1.5mu\}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{One}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{i}\mskip1.5mu\}\mathbin{→}(\Conid{B}\;\Conid{A})\mathbin{→}(\Conid{RandomAccessList}\;(\Conid{Fork}\;\Conid{B})\;\Conid{A}\;\{\mskip1.5mu \Varid{i}\mskip1.5mu\}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}\;\{\mskip1.5mu \mathbin{↑}\Varid{i}\mskip1.5mu\}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Two}\mathbin{:}\mathbin{∀}\{\mskip1.5mu \Varid{i}\mskip1.5mu\}\mathbin{→}(\Conid{Fork}\;\Conid{B}\;\Conid{A})\mathbin{→}(\Conid{RandomAccessList}\;(\Conid{Fork}\;\Conid{B})\;\Conid{A}\;\{\mskip1.5mu \Varid{i}\mskip1.5mu\}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}\;\{\mskip1.5mu \mathbin{↑}\mathbin{↑}\Varid{i}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{IxSequence}\mathbin{:}\Conid{Set}\mathbin{→}\{\mskip1.5mu \Varid{i}\mathbin{:}\Conid{Size}\mskip1.5mu\}\mathbin{→}\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{IxSequence}\mathrel{=}\Conid{RandomAccessList}\;\Conid{Leaf}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{incr}\mathbin{:}\{\mskip1.5mu \Conid{B}\mathbin{:}\Conid{Set}\mathbin{→}\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mathbin{:}\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{i}\mathbin{:}\Conid{Size}\mskip1.5mu\}\mathbin{→}(\Conid{B}\;\Conid{A}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}\;\{\mskip1.5mu \Varid{i}\mskip1.5mu\}\mathbin{→}\Conid{RandomAccessList}\;\Conid{B}\;\Conid{A}\;\{\mskip1.5mu \mathbin{↑}\Varid{i}\mskip1.5mu\}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{incr}\;\Varid{b}\;\Conid{Nil}\mathrel{=}\Conid{One}\;\Varid{b}\;\Conid{Nil}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{incr}\;\Varid{b}\;(\Conid{One}\;\Varid{b₂}\;\Varid{ds})\mathrel{=}\Conid{Two}\;(\Conid{FORK}\;\Varid{b}\;\Varid{b₂})\;\Varid{ds}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{incr}\;\Varid{b}\;(\Conid{Two}\;\Varid{b₂}\;\Varid{ds})\mathrel{=}\{\mskip1.5mu \mathbin{!}{}\<[31]%
\>[31]{}\mathbin{!}\mskip1.5mu\}{}\<[35]%
\>[35]{}\mbox{\onelinecomment  One b (incr b₂ ds)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


Consider the implementation of \textit{incr}. The problem arises when we are recursively calling \textit{incr b ds} . This is where the complication of nested types arose in the first place. incr is a polymorphic function, so in the second interation it would be instantiated with 
\begin{center}
$ B' = FORK B$ \\
$ A' = A $ \\
\end{center}
Now, it is obvious that inserting an element of type Fork B A should increase the size of the container by more than inserting an element of type A would. Under this polymorphism however, the two operations are equivalent.
The solution to this problem would require a size scaled on the type, so that\textit{ size(Fork B A) > size(A)}. However, this needs to be hardcoded for specific type, as Agda has no way of differentiating between different types of type Set, so no general method is available.
We will implement a custom-made size function by enhancing the type with a measurement, in the context of Finger Trees.


\section{FingerTrees in general}

-what are they \\
-previous work: isabelle, coq, agda. \\

\section{FingerTrees in Agda}

-without measurement - quite boring \\
-with measurment \\
-view from the left is not working because of termination check (pointer to coq paper) \\
-trying to solve the issue by defining a well-founded induction \\
-use the measurement info, since it's already there \\

\section{Random Access Sequences as an easier example}

-size and entry \\
-trying to prove the well-foundedness \\
-boom, we fail because we didn't follow a dependently typed implementation \\

\section{Dependently typed FingerTrees}

- implementing dependently typed fingertrees ensures that there cannot be malformed trees in the program.
- I will use the measurement V for the index, since it's mostly been implemented in the previous section. \\

- defining a well founded induction on V will allow ordering trees as well, an therefore ensure termination
checking on this recursion. \\

- (all is well until node) \\

- A full dependent implemenatation seemed harder to envision. By full, I mean that I move the measure
labels from the nodes to the type as well. However, I don't see how we allow trees to have differently
sized nodes since their constructor only takes an instance of Node A V {size}, size which must be
specified in advanced. \\

- I am cheating this using postulates. We can guarantee no bad nodes are added in the tree since the
user never actually needs to call the constructor of the node, it should be a completely hidden
concept. \\

- The approach with the view doesn't work as expected, even when Agda can see that the types are
becoming smaller. I am providing the examples in node2.agda \\

- Complain about the with operator \\

- All this to simplify recursion and inductive definitions on FingerTrees.

\section {Random Access Sequences with dependently typed FingerTrees}



\section{Verbatim text}

Verbatim text can be included using \verb|\begin{verbatim}| and
\verb|\end{verbatim}|. I normally use a slightly smaller font and
often squeeze the lines a little closer together, as in:

{\renewcommand{\baselinestretch}{0.8}\small\begin{verbatim}
GET "libhdr"

GLOBAL { count:200; all  }

LET try(ld, row, rd) BE TEST row=all
                        THEN count := count + 1
                        ELSE { LET poss = all & ~(ld | row | rd)
                               UNTIL poss=0 DO
                               { LET p = poss & -poss
                                 poss := poss - p
                                 try(ld+p << 1, row+p, rd+p >> 1)
                               }
                             }
LET start() = VALOF
{ all := 1
  FOR i = 1 TO 12 DO
  { count := 0
    try(0, 0, 0)
    writef("Number of solutions to %i2-queens is %i5*n", i, count)
    all := 2*all + 1
  }
  RESULTIS 0
}
\end{verbatim}
}

\section{Tables}

\begin{samepage}
Here is a simple example\footnote{A footnote} of a table.

\begin{center}
\begin{tabular}{l|c|r}
Left      & Centred & Right \\
Justified &         & Justified \\[3mm]
%\hline\\%[-2mm]
First     & A       & XXX \\
Second    & AA      & XX  \\
Last      & AAA     & X   \\
\end{tabular}
\end{center}

\noindent
There is another example table in the proforma.
\end{samepage}

\section{Simple diagrams}




\cleardoublepage

\chapter{Evaluation}

\section{Printing and binding}

If you have access to a laser printer that can print on two sides, you
can use it to print two copies of your dissertation and then get them
bound by the Computer Laboratory Bookshop. Otherwise, print your
dissertation single sided and get the Bookshop to copy and bind it double
sided.


Better printing quality can sometimes be obtained by giving the
Bookshop an MSDOS 1.44~Mbyte 3.5" floppy disc containing the
Postscript form of your dissertation. If the file is too large a
compressed version with {\tt zip} but not {\tt gnuzip} nor {\tt
compress} is acceptable. However they prefer the uncompressed form if
possible. From my experience I do not recommend this method.

\subsection{Things to note}

\begin{itemize}
\item Ensure that there are the correct number of blank pages inserted
so that each double sided page has a front and a back.  So, for
example, the title page must be followed by an absolutely blank page
(not even a page number).

\item Submitted postscript introduces more potential problems.
Therefore you must either allow two iterations of the binding process
(once in a digital form, falling back to a second, paper, submission if
necessary) or submit both paper and electronic versions.

\item There may be unexpected problems with fonts.

\end{itemize}

\section{Further information}

See the Computer Lab's world wide web pages at URL:

{\tt http://www.cl.cam.ac.uk/TeXdoc/TeXdocs.html}


\cleardoublepage
\chapter{Conclusion}

I hope that this rough guide to writing a dissertation is \LaTeX\ has
been helpful and saved you time.


\end{document}
%
% \cleardoublepage
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % the bibliography

 \addcontentsline{toc}{chapter}{Bibliography}
 \bibliography{refs}
 \cleardoublepage

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % the appendices
% \appendix
%
% \chapter{Latex source}
%
% \section{diss.tex}
% {\scriptsize\verbatiminput{diss.tex}}
%
% \section{proposal.tex}
% {\scriptsize\verbatiminput{proposal.tex}}
%
% \section{propbody.tex}
% {\scriptsize\verbatiminput{propbody.tex}}
%
%
%
% \cleardoublepage
%
% \chapter{Makefile}
%
% \section{\label{makefile}Makefile}
% {\scriptsize\verbatiminput{makefile.txt}}
%
% \section{refs.bib}
% {\scriptsize\verbatiminput{refs.bib}}
%
%
% \cleardoublepage
%
% \chapter{Project Proposal}
%
% \input{propbody}
%
% \end{document}
