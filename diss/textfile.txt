




 
 a4paper
total170mm257mm
 left20mm
 top20mm
 













L1
0ptm1
C1
0ptm1
R1
0ptm1




TeX Gyre Pagella
DejaVu Sans
DejaVu Sans
DejaVu Sans














































































































































































































































































16 This is epsftex v274 14 February 2011




















 1bp        
 0pt       
 0pt       
 0pt 
 04pt 


    72
    72
    540
    720
    
    1
    
         
    
         
    
    1











   2 3 4 5 

   
   6
   6



    1
    1







    
    16 1
    
        Could not open file 1 ignoring it
    
        
            
            
            
             12
            
            
              10
            
            
            
                to 
                
                
            
                 

            
            
            
            
            
                
                    16 No BoundingBox comment found in 
                                         file 1 using defaults
                
            
        
        
    
    
    1
    16 



 clip
clip











     
     by 
      0
       
       PSfilepsdraftps1
llx
lly
urx
ury
rwi

               
     
       
       by 
       PSfilepsdraftps1
llx
lly
urx
ury
rwi
rhi

               
     







 
  







 environment works by adjusting TeXs
    
    
    
    
    
    
    
    
    
    
    
  
  
  0  1
  0  0                                
  0 by 2
  0 by 2
  
  
    
    
      height depth 0pt
      to 0
      

width 
0 
width 

      
      height 0pt depth 
    
  
  




   
   
   
   
   
   
   
   
   
     
     to
     
        
            
            
            to 1
        
            
            to
               
               
               
                  
                  1
               
               
               
            
            
        
     
   
   
   
   
   
    0pt
    0pt







    
   by 
    
   by 




    
    0
       0
 
         
 0pt





      
 
        by 
 
        by 
by 
        by 
 

        by 
        by 2
 0
    
           
      
              
           

 0pt
      
   
      0
        
       by 
        
       by 
       by 
       by 
        
       
 by 
 by 2
        0
   
          
     by 
             by 
          
       
        0pt
     
        
     
   





   
     16 1 BoundingBox
  llx  lly  
  urx  ury  
     16 1 scaled width  
  scaled height  
   






atend























   2
   1
       
            3    

            
                
            
                
                
                    
                
                
            
       
   






   1
      2 3 4 5 

   2
   34








 

                            









1000
1000

       


    
                                        




arrows


  treenodestyle  aligncenter inner sep0pt text centered
    font
  arnnstyle  treenode circle black font drawblack
    fillwhite text width15em
  arnrstyle  treenode circle red drawblack 
    text width15em very thick minimum height02em
  arnxstyle  treenode rectangle drawblack
    minimum width05em minimum height07em
  deepstyle  treenode circle red drawBrown
  minimum width05em minimum height07em fillBrown
  nodestyle  treenode circle green drawPeach
  minimum width05em minimum height07em fillPeach
  digitstyle  treenode white drawCerulean 
  minimum width04em minimum height04em fillCerulean
  leafstyle  treenode white draw  Cerulean 
  circle minimum width  04em minimum height  04em fillCerulean






  LabelStylestyle   rectangle rounded corners draw
                        minimum width  2em fill  yellow50
                        text  red font  
  VertexStyleappend style   inner sep5pt
                                font  
  EdgeStyleappend style   bend left 









plain








Razvan Kusztos




Verified functional data structures in Agda 


Part II Project in Computer Science


Girton College 










15



1
roman


Proforma


ll
Name                Razvan Kusztos                       

College             Girton College                     

Project Title       Verified functional data structures and algorithms in Agda 

Examination         Part II Project        

Word Count          01
well less than the 12000 limit 

Project Originator  Dr Timothy Griffin                    

Supervisor          Dr Timothy Griffin                    



1This word count was computed
by detex disstex  tr cd 09AZaz n  wc w

footnote


Declaration

I Razvan Kusztos of Girton College being a candidate for Part II of the Computer
Science Tripos hereby declare
that this dissertation and the work described in it are my own work
unaided except as may be specified below and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose


Signed signature


Date date








Acknowledgements





                        

1
arabic



Introduction






Verified Programming

Verification of program correctness is paramount to any successful application There are many paradigms used in industry that enforce this idea Most commonly hardcoded tests are run against the program In this project I will focus on formal verification that is checking that a program is correct under some formal mathematical modeling rather than through its behaviour

Formal verification has had successful application in areas such as cryptography Cryptol  hardware specification The verification system in Verilog or compiler construction CompCert 
A more general approach implies verifying arbitrary software programs Automated theorem provers such as Coq Isabelle or Agda achieve this goal Although the principles they use have been around for decades their industrial application remains still niche CompCert is an example project using Coq Isabelles open archive of proofs contains mainly proofs concerned with mathematical objects with very few example of algorithms or data structures   

Languages like Agda have been designed first and foremost as general programming languages with formal verification capacities secondary Their development is in a relatively early stage and are mainly employed for research 

Functional Data Structures

In the context of data structures and algorithms there are two main paradigms in use a stateful approach used in most imperative programming languages and a stateless approach seen in pure functional programming

The formal treaty of these environments is different In stateful code functions can alter the state of the program and return different results at different times even when fed the same arguments In this context verification has to be done separately using specific system such as Hoare Logic

Functional programming languages enforce the idea of statelessness bringing functions as close as possible to mathematical functions They have to always return the same result for a given argument regardless of when and where the call occurs This concept is rebecoming popular in the industry due to the advantages it brings in concurrent programming
 
Functional data structures have been long thought to be inefficient and belonging solely to academia The work of Okasaki  namely his bookPurely Functional Data Structures has gone a great way in solving the imbalance between functional data structures and the vast collection of efficient imperative structures His discussion of implicit recursive slowdown and numerical representations of types has inspired the advent of many data structures An example at which I will come back later is the Finger Tree

The main constraining property of functional data structure is that they are persistent That is any destructive operation such as updating an element in a list is expected to preserve in memory both the previous version and the new version This constraint is not de facto in imperative implementation consider updating an element in a C array Solutions for achieving this goal in an imperative environment are tedious and incur and extra cost 

By working functionally we need to work on top of this constraint and techniques like implicit recursive slowdown can help achieve comparable runtimes Furthermore the lack of side effects makes reasoning about functions a more tractable problem and therefore aids coming up with verified programs

Traditionally the verification of computer programs is a standalone task and takes the form of performing proofs in a separate environment Most commonly this environment is pen and paper Agda is part of a family of programming languages which alongside with Coq or Idris is based on the theory of dependent types In these environments types and values are part of the same grammar forming terms The expressivity this brings allows reasoning about code and proofs in the same environment under the Curry Howard isomorphism  

In this dissertation I aim to show some approaches of verifying data structures and algorithms using the expressive power of Agda I have chosen as a running example the implementation of the FingerTree The original paper presents an implementation of this data structure in Haskell and describes the main operations that such a data type must support 

FingerTrees are a slight modification of a 23 tree   which allows efficient appending at either end Its abstract data type is that of a doubleended queue Furthermore the FingerTrees can be associated with a measurement function and an operator described in section whatever that allows the specialization to other abstract data types such as Random Access Sequences Priority Queues or Interval Trees


 











































 



The work of implementing the Finger Tree in a dependent environment has been carried out by Matthiew Souzeau in his paper  focused on introducing Russel a framework to facilitate code writing in Coq The goal of this dissertation is to see to what extent the same result can be achieved in Agda experimenting with various patterns for proving correctness


Summary

In the next section I will introduce Agda explain how logic reasoning fits tightly with the theoretical basis of Agda and the FingerTree data structure 

In the implementation section I will present a dependent implementation of FingerTree which ensures correctness as well as proofs related to this data structure I will show how specializations of the FingerTree to a Random Access Sequences maintains the correctness properties This can be seen as a software engineering approach using dependent types 
Finally I will outline some difficulties arising because of Agdas totality and show some ways of overcoming them

In the evaluation section I will analyze the runtime difference and compare the effort of implementing a dependent data structure versus a non dependent one I will discuss how the current implementation achieves the goals set in the Coq implementation
 
Preparation

Starting Point

Pink Book


Agda

Agda is a dependently typed programming language based on the predicative Martin Lof type theory It was introduced in Ulf Norells Phd thesis  as a bridge between practical programming and the world of wellestablished automated theorem provers like Coq 

I have chosen to implement this project in Agda for a number of reasons 


dependent types
simplicity both in available features and the syntax
a suitable learning curve
lack of predefined tactics which makes it easier to observe patterns in programming errors or issues 
specifically for implementing Finger Trees for reasons that I will come back to in section whatever


Dependent Types 

In traditional functional programming languages such as SML Ocaml or Haskell there is a clear barrier between types and values In a dependently typed programming language such as Agda Coq or Idris this distinctions fades away Types and values are placed under the same grammar introducing general terms 
Careful use of this expressive power can aid the user by reducing much of the runtime checks needed to ensure proper execution of the program 

Curry Howard Isomorphism

Traditionally proofs about the programs are presented in a separate environment most commonly pen and paper Since we allow types to depend on values we can reason about both code and proofs in the same environment 
The main mechanism employed in computer assisted proofs with dependent types is the observation due to Curry that there exists a onetoone correspondence between propositions in formal logic and types The original example given by Howard is the bijection between the intuitionistic natural deduction and the simply typed lambda calculus
Using this principle the predicative quantifier  for all corresponds to a dependent product enabled by dependent types


















Although a comparison between CiC Calculus of Inductive Constructions and ITT Intuitionistic Type Theory would be interesting I could not find any literature on this topic The development of Coq was influenced by Martin Lofs theory through the presence of inductive types A notable difference is that Coqs sort system differentiates between Prop the type of propositions and Typei whereas Agda only has a family Seti A side by side comparison of Agda and Coq is present on the Agda website  

In Agda the Curry Howard relations introduce the following recipes for generating proofs

















 

The proof of a proposition in this logic is equivalent to building a term that has the corresponding type

Proofs in Agda

A very important family of types in Agda is the propositional equality




data  a A  Set a x  A  A  Set a where


022
2refl  x  x



Having a single constructor it corresponds to the proposition that two elements of the same type can only be equal if they are in fact the same element 
This is the basis of all the proofs in this dissertation Constructing a term of type a  b represents a statement that a and b are equivalent

Associativity of Natural Numbers
Consider proving some properties of the natural numbers such as associativity 





022
2assoc   x y z    x  y  z  x  y  z


022
2assoc zero y z  refl


022
2assoc suc x y z rewrite assoc x y z  refl



The type indicates what is being proved whereas the definition consists of an example proof

Induction

As in the previous example we can see that induction is a key means of proof In this example we perform a structural induction on the possible constructor of z as a natural number





data   Set where


022
2zero  


022
2suc 7
7   


 


 In the second case we also perform a natural mathematical induction step Assuming that assoc a b c holds for some a b and c we want to show that assoc a  1 b c holds

Further Example  List reverse properties
Consider the following implementation of reverse using a helper function rev as the reverse with accumulator 




rev  A  Set  List A  List A  List A


rev  ys  ys


rev x  xs ys  rev xs x  ys





rev  A  Set  List A  List A


rev xs  rev xs 




The main goal of this exercise is to prove that  We first need to prove some helper statements about reverse of which I have included the type declarations 




revrev   A


01010
10 xs  List A


01010
10 ys  List A


01010
10 rev xs ys  rev xs  ys







revapplemma  A  Set


21414
14 xs  List A


21414
14 ys  List A


21414
14 rev xs  ys  rev ys  rev xs




Finally the main proof is presented using the Equational Reasoning module which aids writing more readable proofs This is the format in which most proofs are written throughout the dissertation I have indented the code such that in between begin 
 the extraindented lines correspond to successive transformations of the lefthand side of our formula using lemmas provided inside the triangular brackets   




revlemma  A  Set


21010
10 xs  List A


21010
10 rev rev xs  xs


revlemma   refl


revlemma x  xs 


022
2begin


244
4rev rev xs x  


022
2 cong rev revrev xs x   


244
4rev rev xs  x  


022
2 revapplemma rev xs x   


244
4x  rev rev xs


022
2 cong  a  x  a revlemma xs 


244
4x  xs


022
2



It is worth emphasizing the dual use of the typing system both for proving correctness and providing abstraction The type declaration is many times sufficient for understanding the purpose of the implementation


Totality

Agda and Coq are both examples of total function programming languages This constrains all the defined functions to be total 


In a mathematical sense this means that they must be defined for all inputs Consider the declaration of the head of a list




head   A  List A  A


head x  xs  x




This function doesnt type check in many languages however some languages could allow runtime errors to be thrown if a nonexistent case is reached In Agda to mitigate this constraint it is straightforward to use the Maybe monad

In a computational sense however functions must also be strongly terminating on all the inputs This has to do with the logical consistency We trade off the Turing completeness for ensuring that all constructed terms correspond to valid proofs

However due to a well known result termination checking is an undecidable problem For this reason Agda and Coq have to use heuristics to determine whether recursive calls will eventually terminate

The way Agda deals with this problem is by ensuring that with every call to the function in a recursion stack its argument becomes structurally smaller  The ordering relation is recursively defined by 
i  Natw  Seti w  Cw


where C is an inductive data type constructor

Sized types

One can very simply imagine operations that hide this structural lessthan relation For this reason the concept of Sized types has been introduced   Under this paradigm the data structure should be indexed by a type   for which the structural relation is obvious at all times 

The difficulty of using Size becomes apparent in the context of Finger Trees this is particularly a problem with nested type which I am explaining the the Appendix  However it is worth noting here that the incompleteness   of the termination checker is making programming unnecessarily hard in some cases 

Correct Data Structures in Agda

Much of the effort in programming goes to preserving invariants ie facts the programmer needs to ensure about data structures in order for them to behave as expected 
That is we need to make sure that the following statements hold

the constructors can only produce correct instances ie that respects some arbitrary assumption
any function that takes as input a correct instance can only output a correct instance


If the type of the data structure ensures the invariants we want both these propositions become true via the Curry Howard isomorphism

Sorting Lists

Consider for example implementing a function that sorts lists That is the input is a normal list and the output should be a sorted list containing all the elements in the argument list
We can provide a type encoding of what it means to be a sorted list containing some set of elements 



022
2data SortedList  n    Vec A n  Set where


244
4  SortedList 


244
4  x  A  SortedList x  


244
4   n   ys  Vec A n zs


41010
10 x  A


41010
10 xs  SortedList ys


41010
10 all  a  x  a ys  true


41010
10 x ins ys  zs


41010
10 SortedList zs




Here the all function tests whether a predicate holds in the entirety of a list and the ins operator should be read as If x ins xs  ys then I can insert x somewehre in xs to obtain ys

In order to define a correct sorting function we assign the following type signature  




022
2sort   n    xs  Vec A n  SortedList xs




This definition can be read in two ways From a logical point of view it is a proof that all lists can be sorted However from a computational point of view it represents the type signature of all sorting functions that can be coded in Agda  

This example should prove the expressiveness that dependent typing makes available as well as its capacity for abstraction In implementing the Finger Trees I will aim for a similar verification method

Nested Types

In order to move on to the Finger Trees I first have to introduce an alternative way through which a certain family of invariants could be kept true without using dependent types 

Nested types also known as irregular types or polymorphic recursions can aid in enforcing structure in data types such as full binary trees cyclic structures  or square matrices  The idea is that when declaring an inductive data structure occurrences of the type on the right hand side are allowed to appear with different type parameters

Agda is particularly expressive since it allows declaring functions on such data types as opposed to SML and older versions of Haskell

List is an example of a regular data type The recursive call to List is restricted to the type parameter A




data List A  Set  Set where


022
2  List A


022
2  A  List A  List A




A slight modification which recursively calls Lists with the type parameter A x A is used to represent a full binary tree this has been introduced as Nest 




data Nest A  Set  Set where


022
2Nil  Nest A


022
2Cons  A  Nest A  A  Nest A







example  Nest 


example  Cons 1 Cons 2  3 Cons 4  5  6  7 Nil























The same principles apply in the case of Finger Trees which is based on a full 23 tree with labels in the leafs only

As an aside I believe that the presence of these nested types make termination checking an even harder task in many cases The problems that occur in the implementation of the Finger Tree are not limited to this context I have provided the implementation of yet another data structure that suffers the same limitations in the Appendix 



23 Trees 

At the base of the FingerTree is a 23 tree with a further constraint that all the leaves must occur on the last level Using the concept of nested types presented in the previous section we can encode this constraint in the type system 






































Instead of using the pair  we declare a new data type that can contain both two and three elements 




data Node A  Set  Set where


022
2Node2  A  A  Node A


022
2Node3  A  A  A  Node A




To declare the tree we use a nested type The constructor are called Zero and Succ in the original paper to signal the origin of the idea as Okasakis numerical representations see Appendix 




data Tree A  Set  Set where


022
2Zero  A  Tree A


022
2Succ  Tree Node A  Tree A




As an example Figure  could be written in Agda as follows indented in an attempt to clarity




testtree  Tree 


testtree  SuccSuccSuccZero


21414
14Node2


141818
18Node3


182020
20Node3 1 2 3


182020
20Node2 4 5


182020
20Node2 6 7


01818
18Node2


182020
20Node3 8 9 10


182020
20Node2 11 12
 

Finger Trees 

Finger Trees are a data structure introduced by Ralph Hinze and Robert Patinsson based on Okasakis principle of implicit recursive slowdown 
 
Initially designed as a double ended queue with constant amortized time append their structure together with the cached measurements allow specialization to Random Access Sequences or Priority Queues by simple instantiation  
 
 The underlying structure is that of a full 23 tree with labels solely at the leafs For efficient appending the tree is surrounded by buffers at each level which amortize the cost Furthermore the data structure is accompanied by a measurement function and a binary operator such that the reduced measures of all nodes in a subtree is cached in all the joints These are necessary for searching or splitting

Measurements and the Monoid

The generality of the Finger Tree as a data structures comes from its association with a set of measurements V The measure of the tree   is mapping a finger tree to an element of the set V

The construction of this map requires two building blocks First we need a function that maps elements of the finger tree to elements of the set V Secondly we need the set V to be the carrier of a Monoid

That is we pick a function in infix notation 
 
  V V V 
 
And a element in V which will be called the neutral element such that the next axioms hold 

x V x  x  neutralleft

x V x  x  neutralright 

x yz V x y z  x y z assoc 



We define the measure of the tree to be therefore the result of recursively reducing each branch and accumulating the result using the operator As the base case an Empty tree should correspond to the neutral element and leaves in the tree should be mapped using the measurement function

A further consideration we need to make is that of the efficiency Recomputing these values would incur a linear time cost for every operation We can amortize this cost by keeping cached measurements in all the joints of the tree ie the constructors of the data types that constitute it

Invariants

The efficiency is achieved by keeping two invariants on the data structure

The tree is full and all the leaves occur on the last level 
The measurements are correct 


Working in Agda a dependently typed language which moreover allows the use of nested types we can keep these invariants soley in the type signature of the Finger Tree More specifically

The nested typing will ensure fullness of the tree
Choosing measurements as the type index ensures their correctness  
 

Previous Work

Finger Trees have been previously implemented and proved correct I will outline some previous results as well as their limitations providing more incentives for this dissertation I have included all related implementations I could find and I do not guarantee they are the only ones


Basic Implementation in Agda 

This version can be found on GitHub  Its mentioned intention is to closely follow the original paper It also uses introduces the idea of Sizing although only in the type declaration and constructors Since the constraints are not present in functions that modify the data type they do not really aid correctness proofs It has no proofs associated with it and it didnt type check on my machine
Implementation in Coq 

This implementation is provided by Matthiew Souzeau as a proof of concept for Russell a Coq extension I have drawn great inspiration from that paper and I was particularly drawn by a small caveat related to termination checking  

My dissertation proceeds in a similar manner implementing the finger tree and tackling the invariants in the same way In addition I am also proving further properties of the operations as well as presented a working solution to the termination issue

Implementation in Isabelle 

Another working implementation has been done in Isabelle However this implementation diverges from the original specification of the data structure removing the nesting The two invariants that I have mentioned are maintained explicitly due to the lack of dependent types
 

The implementation of this data structure in both Coq and Isabelle two established theorem provers might argue both for the complexity involved and for its interesting particularities


Abstract Operations





















































Some of the properties on the rightmost column are being presented in the implementation There are properties which could not be proven due to problems with the with operator which I am presenting in section 

The properties related to size  are proven internally as part of the implementation The others are proven externally by defining terms of types that express those properties 

Notes


add the stuff about starting point requirements and whatever everyone talks about


Implementation



Finger Trees  Implementation

Data type declaration

The Finger Tree is originally polymorphic in two types

A  this is the type of the elements that are contained in the Finger Tree 
V  this is the type of measures 
 


In order to to mimic Haskells typeclasses I have carried around for each A and V two constructs

 
Monoid  V which contains a neutral element a binary operator and the monoid axioms and a comparison operator
Measured A V  which consists of a norm function    
 


Node corresponds to nodes in the underlying 23 tree implementation having two constructors that contain two and respectively three items Moreover Nodes can only be constructed if provided with a measurement tag and a correctness proof
  



data Node a A  Set aV  Set a 


01010
10 mo  Monoid V 


01010
10 m  Measured A V   Set a where


022
2Node2  v  V


288
8 x  A  y  A


288
8 11
11v   x    y 


288
8 Node A V


022
2Node3  v  V


288
8 x  A  y  A  z  A


288
8 v   x    y    z 


288
8 Node A V



Digits were in presented in the original paper as lists but this definition limits them to have one to four elements




data Digit a A  Set a Set a where


022
2One 8
8 A  Digit A


022
2Two 8
8 A  A  Digit A


022
2Three  A  A  A  Digit A


022
2Four 8
8 A  A  A  A  Digit A



Finally the FingerTree is a family of types indexed by a measurement  The measurements correctness is enforced in all the constructors Note the nested type and the universal quantification over possible sizes for the recursive call Apart from the measurement addition the rest corresponds to the original paper





data FingerTree a A  Set aV  Set a


21616
16 mo  Monoid V 


21616
16 m  Measured A V  


21616
16  V  Set a where


022
2Empty 9
9 12
12FingerTree A V 


022
2Single  12
12e  A  FingerTree A V  e 


022
2Deep 9
9 12
12s  V


21010
10 pr  Digit A


21010
10 FingerTree Node A V V s


21010
10 sf  Digit A


21010
10 FingerTree A V measuredigit pr  s  measuredigit sf




Smart Constructors
We also build smart constructors that fill in the measurement provided with the appropriate number of elements




node2   a A  Set aV  Set a 


088
8 mo  Monoid V 


088
8 m  Measured A V 


088
8 A  A  Node A V


node2 x y  Node2  x    y  x y refl





node3   a A  Set aV  Set a 


088
8 mo  Monoid V 


088
8 m  Measured A V 


088
8 A  A  A  Node A V


node3 x y z  Node3  x    y    z  x y z refl




Considering Figure  I have colourcoded the nodes as follows
























Indexing on the measurement

The reason for indexing on the measurement is twofold Firstly we index on the measurement in order to verify the correctness of the measurement in operations such as appending an element or splitting Secondly the index was chosen in order to allow implementing a size that depends on all elements in the finger tree 

Consider a sizing that would take into account the shape of the tree only as it is the case of Size described previously 






































 

In Figures  and  it is an ambiguous question which of the two trees should be considered to have a bigger size Size implements a partial order between data types with no definite reference points whereas here we are concerned with an absolute order 

As suggested by Matthew Souzeau  a sizing that reflects the number of elements is ideal We can use the already existing measurement index to achive this goal

Cons and Snoc

Cons is the operator that appends an element to the left of the finger tree 

The implementation is straight forward if there is room in the leftmost digit Otherwise we have to recursively insert and reform parts of the finger tree

Ultimately for the correctness part we are concerned whether the output tree is a correct finger tree enforced by the type with a correct measurement 

That is by inserting an element x
x ft  x ft 






























































   a A  Set a V  Set a


266
6 mo  Monoid V 


266
6 m  Measured A V 


266
6s  V


266
6 x  A


266
6 FingerTree A V  mo   m  s


266
6 FingerTree A V  mo   m   x   s



Each case in the definition is accompanied by a proof that the measurement of the output finger tree is correct with respect to the topmost definition These proofs are all derived from monoid properties imposed on the operation


 
 l A V  mo  a Empty


022
2rewrite Monoidright mo  a 


022
2 Single lAV a


 l A V  mo   m   e  a Single e


022
2rewrite assoclemma1  mo   m  a e


022
2 Deep One a Empty One e


a  Deep One b ft sf


022
2rewrite assoc  a   b  measuretree ft  measuredigit sf


022
2 Deep Two a b ft sf


a  Deep Two b c ft sf


022
2rewrite assoc  a   b    c  measuretree ft  measuredigit sf


022
2 Deep Three a b c ft sf


a  Deep Three b c d ft sf


022
2rewrite assoc  a   b    c    d  measuretree ft  measuredigit sf


022
2 Deep Four a b c d ft sf


a  Deep Four b c d e ft sf


022
2rewrite assoclemma2 a b c d e measuretree ft measuredigit sf


022
2 Deep Two a b node3 c d e  ft sf




The Finger Tree operations are symmetric on the middle so the construction of the snoc operator is exactly dual Its implementation is provided in the source code

toList

We will need to prove properties of the finger trees with respect to the elements they contain and their relative position Therefore it is handy to be able to transform them to lists as they encode these properties simply


This is the conversion between a finger tree and a list 
 




toListft   aA  Set aV  Set a 


01010
10 mo  Monoid V 


01010
10 m  Measured A V  s  V


01010
10 FingerTree A V s


01010
10 List A


toListft Empty  


toListft Single x  x  




Proving correctness of the cons operator

Assuming that the implementation of list is correct we can define the correctness of the cons operator as follows 




conscorrect   aA  Set aV  Set a 


688
8 mo  Monoid V 


688
8 m  Measured A V 


688
8v  V 


688
8x  A 


688
8ft  FingerTree A V v 


688
8toListft x  ft  x    toListft ft


 

View from the LeftRight

As suggested in the original paper the structure of the finger tree is complicated and users can benefit from a higher level representation Furthermore we have no mechanism yet of deconstructing a sequence

In this case we will view each finger tree as the product between an element and the remaining finger tree 






data ViewL aA  Set aV  Set a


81010
10 mo  Monoid V 


81010
10 m  Measured A V  


81010
10s  V  Set a where


022
2NilL  10
10ViewL A V 


022
2ConsL   z


21010
10x  A


21010
10 xs  FingerTree A V z


21010
10 ViewL A V  x   z


 

This data type also enforces the correctness of the measurement being indexed in the same way as the finger tree 

We need to implement a procedure that transforms between the two

As it is the case of the Cons operator most cases are superfluous The complicated case arises when the leftmost digit contains a single entry



















































As you can see the composition of cons and viewL is not a noop but they both preserve the order of the elements




mutual





022
2viewL   a A  Set aV  Set a 


21010
10 mo  Monoid V 


21010
10 m  Measured A V 


21010
10i  V  FingerTree A V i


21010
10 ViewL A V i


022
2viewL Empty  NilL


022
2viewL  mo   m  Single x


244
4rewrite sym Monoidright mo  x 


244
4 ConsL x Empty


022
2viewL  mo   m  Deep pr ft sf


244
4rewrite measuredigitlemma1  mo   m  pr ft sf


244
4 ConsL headdig pr deepL tailsdig pr ft sf











022
2deepL   aA  Set aV  Set a 


288
8 mo  Monoid V 


288
8 m  Measured A V 


288
8s  V


288
8 pr  Maybe Digit A


288
8 ft  FingerTree Node A V V s


288
8 sf  Digit A


288
8 FingerTree A V measuremaybedigit pr  s  measuredigit sf


022
2 deepL pr ft sf     


022
2deepL just x ft sf  Deep x ft sf


022
2deepL nothing ft sf with viewL ft


022
2deepL  mo   m  nothing ft sf  NilL


244
4rewrite Monoidleft mo   measuredigit sf


41010
10 Monoidleft mo measuredigit sf


044
4 toTreedig sf


022
2deepL nothing ft sf  ConsL Node2 x x x r x


244
4rewrite r


41010
10 assoclemma3 x x measuretree x sf


044
4 Deep Two x x x sf  Deep Two x x x sf


022
2deepL nothing ft sf  ConsL Node3 x x x x r x


244
4rewrite r


41010
10 assoclemma4 x x x measuretree x sf


044
4 Deep Three x x x x sf  Deep Three x x x x sf




Proving Correctness of viewL

We can proceed in an analogous way to the correctness of cons by constructing an appropriate tolist conversion for views and then proving that the list representations coincide
























However we stumble upon simple property that is unnecessarily hard to prove

That is we would like to prove that  This fact is obvious given the associated definitions Unfortunately Propositional Equality cannot allow a term of this form since for an arbitrary  FingerTree A V  does not have the same type as Empty ie FingerTree A V 

Changing the statement of the problem slightly to  ft  FingerTree A V   allows the definition However the typechecker will get stuck in trying to pattern match on ft The reason is that it cannot find terms in V to satisfy the constrained indexing

Indeed if we try to prove this statement on a simpler version of FingerTree that is indexed by Size   it is a straightforward exercise 




viewlemma3   aA  Set a V  Set a 


21414
14 mo  Monoid V 


21414
14 m  Measured A V 


21414
14 ft  FingerTree A V


21414
14 viewL ft  NilL


21414
14 ft  Empty


viewlemma3 Empty p  refl


viewlemma3 Single x 


viewlemma3 Deep x x ft x 




A solution to this issue was suggested by McKinna using an alternate implemenation of equality  Heterogeneous Equality which works across types 

Using heterogeneous equality we can now write the type of the original statement in Agda as well as patternmatch on the finger tree However some problems related to the with construct resurface

with and rewrite

The implementation abounds in use of with and rewrite statements with allows inspired by the work of McBride and McKinna  to pattern match on an intermediate computation rewrite replaces an expression on the left hand side by making use of a supplied equality relation

Their use could not be avoided in the implementation of operators that act on indexed data types As part of the type checking Agda has to unify the expected type of the result and the actual type of the result 

Example Consider the implementation of append on Vectors but with a slight difference in terms of the index of the result We return a vector of size  instead of  The typechecker cannot prove that   commutes since it is not superfluous This does not typecheck




append   a n m  A  Set a


466
6 Vec A n


466
6 Vec A m


466
6 Vec A m  n


append  ys  ys


append x  xs ys  x  append xs ys




The same situation arises in the proofs about correctness of the measure semantics We have to provide the proof Due to the nature of the BuiltinEquality relation I could not find a way to expand the functions appropriately as suggested in the documentation  


Discussion about withThere is a number of issues related to the with statement that I have stumbled upon


Computing terms that are hidden behind a with statement requires recomputation of the expression present in the with clause In the FingerTree case this occurs because of the rewrite statements present throughout the implementation of cons viewL deepL etc This causes a mild inconvenience by having to reiterate the same rewrites whenever one writes proofs about those definitions

Whenever an argument of a function is hidden by a with abstraction the definition of that function cannot use further with statement containing the abstracted expression of the argument This is discussed in the documentation Illtyped withabstraction   

This is the reason proving correctness of ViewL seemed complicated

The type of terms hidden by with abstraction is not available as the feature of type checking in this conditions has not been implemented

There are cases in which the terminationchecker is confused in the presence of with

Consider this example where we try to append an element at the end of a list




snoc   A  A  List A  List A


snoc x xs with xs


snoc x xs    x  


snoc x xs  y  ys  y  snoc x ys


 



Taking this issues into account I have tried to come up with solutions to some of them I will present them after finishing the main implementation of the Finger Tree

I should note here that the proofs that I am making are still providing a powerful verification since

The FingerTree maintains all invariants
The measurement semantics are preserved an used sanely


Folding

We can further implement the fold operation and show its correctness I will only present as an example the foldleft implementation

On lists foldl f s x y z  f f f s x y z We can extend this to FingerTrees Defining folds on Node and Digit is trivial since they are just length constrained lists

As a helper function I define an operation to flatten a list of nodes 




flattenlist   aA  Set aV  Set a 


61414
14 mo  Monoid V 


61414
14 m  Measured A V 


61414
14 List Node A V


61414
14 List A


flattenlist   


flattenlist x  xs  toListnode x  flattenlist xs




We can then implement the foldl on finger trees as




foldl   a A  Set a V  Set a


288
8W  Set a


288
8 mo  Monoid V 


288
8 m  Measured A V 


288
8s  V


288
8 W  A  W


288
8 W


288
8 FingerTree A V s


288
8 W


foldl f i Empty  i


foldl f i Single e  f i e


foldl W  W f i Deep pr ft sf 


022
2foldldig f foldl foldlnode f foldldig f i pr ft sf




Proving correctness of Fold Left

Next we will show that the previous implementation is sane by seeing whether folding over a finger tree is equivalent to folding over its list representation




foldlcorrect   a A  Set aV  Set a


21414
14W  Set a


21414
14 mo  Monoid V 


21414
14 m  Measured A V 


21414
14 s  V


21414
14 f  W  A  W


21414
14   W


21414
14 ft  FingerTree A V s


21414
14 foldl f  ft  DataListfoldl f  toListft ft





Furthermore foldleft has some interesting properties when it comes to its relation to the measurement We can prove that if we fold over the finger tree using the Monoid and the Measure  over which it is instantiated we obtain the same result as the measure This result is important as a sanity check of the measure semantics we are trying to preserve throughout the implementation




foldllemma0   a A  Set a V  Set a


21414
14 mo  Monoid V 


21414
14 m  Measured A V 


21414
14 s  V


21414
14 v  V


21414
14 ft  FingerTree A V s


21414
14 foldl foldfun v ft  v  s




Splitting

Splitting is an extension of the ViewL paradigm by allowing extraction of elements arbitrarily deep in the FingerTree It consists of a left side a middle element and a right side 

The same issues occur as it was the case of viewL I have tried in this implementation to keep the usage of with at a minimum This turned out to be a very difficult task so correctness of this method can only be provided in terms of its measure which is being taken care of by the indexing

The split is done over a boolean predicate  and a starting value  The method iterates through the FingerTree element by element at each step increasing  by the measure of the current element  The split is done when the value of the predicate  and the element at which this change occurs becomes the middle


As with ViewL we create an additional datatype that will represent the result It is indexed by the measurement ensuring correctness




data Splitd a A  Set a V  Set a


21212
12 mo  Monoid V 


21212
12 m  Measured A V  


21212
12  V  Set a where


022
2splitd     V   V


21010
10 FingerTree A V  35
35 left side


21010
10 x  A 35
35 middle


21010
10 FingerTree A V  35
35 right side


21010
10 Splitd A V    x   




Since this implementation is long a full of necessary proofs about the types I will only provide the most important snippets

Discussion This implementation was also made difficult because of the partiality of the function in the original paper Wrapping things in the Maybe monad can confuse the typechecker at times

The main procedure pattern matches on the constructors for the Finger Tree provided as argument Notice that the typing already maintains the invariant




022
2splitTree   a A  Set a V  Set a


21414
14 mo  Monoid V 


21414
14 m  Measured A V 


21414
14  V  type class information


21414
14 p  V  Bool  i  V  predicate and inital value


21414
14 ft  FingerTree A V   argument


21414
14 Maybe Splitd A V 


022
2splitTree p i Empty


244
4 nothing 15
15 cannot split an empty tree


022
2splitTree p i Single e


244
4 just splitTreesingle p i e  superfluous case


022
2splitTree p i Deep pr ft sf


244
4 just splitTreeif p i pr ft sf vpr refl vft refl  recursive case


244
4where


466
6vpr  p i  measuredigit pr


466
6vft  p i  measuredigit pr  measuretree ft






The splitTreeif function splits the computation in three cases depending where the predicate changes to True This could happen after the during the prefix pr during the nested finger tree ft or during the suffix sf 






022
2splitTreeif   a A  Set a V  Set a


21616
16 mo  Monoid V 


21616
16 m  Measured A V 


21616
16  V


21616
16 p  V  Bool  i  V 44
44 predicate and initial value


21616
16 pr  Digit A 45
45 prefix


21616
16 ft  FingerTree Node A V V   nested tree


21616
16 sf  Digit A 43
43 suffix


21616
16 vpr  Bool 43
43 value of predicate after prefix


21616
16 vpr  p i  measuredigit pr  correctness check


21616
16 vft  Bool 43
43 value of predicate after tree


21616
16 vft  p i  measuredigit pr  measuretree ft  check


21616
16 Splitd A V measuredigit pr    measuredigit sf


022
2splitTreeif p i pr ft sf false pr1 false pr2


244
4 splitTree2 p i  measuredigit pr  measuretree ft pr ft sf


244
4 case2  predicate becomes true in suffix or not at all


022
2splitTreeif p i pr ft sf false pr1 true pr2


244
4 splitTree3 p i pr ft sf sym pr1 sym pr2


244
4 case3  predicate becomes true in tree


022
2splitTreeif p i pr ft sf true pr1 vft pr2


244
4 splitTree1 p i pr ft sf


244
4 case1  predicate becomes true in prefix




The full implementation requires more advanced agda syntax as well as the implementation of the ViewR and deepR It is present in the Appendix

Other recursive definitions

The difficulties of writing a recursive function that outputs a value of a type dependent on one of the arguments become apparent with the example of reversing

The implementation of reverse is straightforward in terms of folding We could ideally reverse a FingerTree simply by 


reverse ft  foldl  Empty ft


However declaring this in this form is impossible because of two resons


 is a dependent function incompatible with our definition of foldl  

It is possible to implement an analogous dependent version of foldl Doing so will however yield a specific solution to the reverse function of the FingerTree
Transforming the FingerTree first to a list and then folding it is another strategy for achieving a similar result Unfortunately this will incur an unnecessary computational cost
 
The index of the output FingerTree depends on the argument as well yielding in this case 

measureft reverse ft  foldl foldfun  Listreverse toListft ft



In this example the cost of dependent types becomes very clear and can be avoided by providing a nondependent interface

Reverse

The nondependent interface is constructed through a dependent pair The function pack makes the transformation and the conspair is simply the extension of cons to the pair



reverseft   a A  Set a V  Set a


21010
10 mo  Monoid V 


21010
10 m  Measured A V 


21010
10  V  v  FingerTree A V v


21010
10  V  v  FingerTree A V v


reverseft a A V pair 


022
2foldlpair conspair packft A  A V  V Empty pair



 

Note that this implementation no longer constrains the result to the argument The only verified property of this is that the result will itself be a correctly constructed FingerTree

Random Access Sequences

By proper instantiation of the measurement function and monoid we can specialize the Finger Tree to various data structures The first suggested on is the Random Access Sequence

The measurement function will assign the value of 1 to any element and the monoid is simply that of the natural numbers with addition For convenience I will wrap both the size and the entries is special types to aid with the use of instance arguments

SizeW and Entry

The SizeW is simply a wrapper around Nat  





022
2data SizeW a  Set a 26
26where


244
4size   n    SizeW a


022
2   a  Level  SizeW a


022
2  size 0





022
2  9
9 a  SizeW a  SizeW a  SizeW a


022
2size n  size m  size n  m




The properties of the Nat carries directly toSizeW so that we can populate a Monoid SizeW




022
2instance sizemonoid   a  Monoid SizeW a


022
2sizemonoid  monoid     assoc 




Entry A is a wrapper around elements of type A given by the constructor entry





022
2measure   aA  Set a  x  Entry A  SizeW a


022
2measure x  SizeWsize 1





022
2instance entrymeasure  aA  Set a  Measured Entry A SizeW


022
2entrymeasure  measured measure


Seq Instance

The Sequence instance is simply an alias for a Finger Tree instantiated with an arbitrarily typed Entry and the SizeW monoid




044
4Seq   aA  Set a SizeW  Set a


044
4Seq a A s  FingerTree Entry A SizeW a s




Retrieving the nth element  
 
The naive implementation would simply call the viewL n times yielding an amortized linear cost

However we can find an  implementation by using split The predicate checks whether the current value is smaller than n and we will start iterating from 0


044
4   aA  Set as  SizeW  Seq A s    Maybe A


044
4seq  n with splitTree  x  size n  x size 0 seq


044
4seq  n  just splitd  x   just getEntry x


044
4seq  n  nothing  nothing




The call to split allows us to view the nth element as well as the sequences that remain to the left and to the right

Setting an element  

This also suggests a possible implementation for setting an element which is rather inefficient but provided for completeness using Finger Tree concatenation

 


044
4set   aA  Set as  SizeW  Seq A s    A  Seq A s


044
4set seq n y with splitTree  x  size n SizeW x SizeW seq


044
4set seq n y  just splitd left x right


466
6rewrite assoc measuretree left


62222
22size 1


62222
22measuretree right


066
6 concat entry y  left right


044
4set seq n y  nothing  seq




Writing recursive definitions

As mentioned in section whatever the use of with can sometimes confuse the termination checker This combined with the nature of the viewL makes it hard to make us of the abstraction brought by deconstructing FingerTrees as we would deconstruct normal Linked Lists

In fact Agdas termination checker cannot prove that for any finger tree ft viewL x cons ft is structurally bigger than ft The reason is that the cons operator has to be performed before the call to viewL
 
It has been suggested in Matthiew Souzeaus paper  that to overcome this problem one must find a suitable indexing that reflects the number of elements in the Finger Tree This is exactly what the Random Access Sequence achieves

Well founded induction

In order to write a recursive definition against these constraints we need to convert an arbitrary well founded relation to a structural lessthan relation 

In this case concerning SizeW the well founded relation comes free from the natural ordering of Nat 

According to the definition used in this context   we say that a binary relation is wellfounded if all elements in the carrier set are Accessible For an element to be Accessible we require inductively that all the smaller elements are themselves Accessible

By implementing the accessibility relation in Agda we transform any given order into the structural order which Agda recognizes

Packing the Sequence

The ordering of the sizes naturally extends to an ordering of the Sequences so that removing an element from a Sequence necessarily yields a smaller Sequence

In this case we can use Larry Paulsons results   to construct a WellFounded relation on Sequences it is sufficient to have a WellFounded relation on the Sizes

 


466
6 comparing Seqpairs is just comparing the size component


466
6   a A  Set a  Seqpair A  Seqpair A  Set a


466
6   on tosize





466
6open Inverseimage


688
8A  Seqpair A


688
8  


688
8tosize


688
8renaming wellfounded to wf









044
4 the comparison of the Seqpair is wellfounded


466
6WF  wf WF


466
6open WFAll WF renaming wfRec to rec








Having obtained a proof of the wellfoundeness we can proceed by creating a recursor object and writing a recursive definition

Reversing  Until a better example is found

We have already implemented the reverse for the FingerTree through the fold 

 


066
6rev  Seqpair A  Seqpair A


066
6rev   rec a  go 


688
8module Rev where


688
8go   s   p  p  s  Seqpair A  Seqpair A


688
8go  fst  snd  rec with viewL snd


688
8go  size 0  snd  rec  NilL  pack Empty


688
8go    snd  rec  ConsL x xs 


81212
12rec pack xs onesteplemma measuretree xs  x




It is arguable whether this is actually a solution to the abstraction problem We have indeed been able to write a definition of the reverse function using an abstract view However the solution itself is probably less readable than a solution that reverses directly on the Finger Tree

Furthermore in this form we no longer work with dependently typed functions since the indexes have been covered up by the dependent pair No correctness is enforced by the typing system Trying to prove correctness of this function brings back the problems caused by with In particular we have an induction proving mechanism but we are stopped by the inability to prove an inductive step on viewL

For simple properties it is sufficient to output a new dependent type that enforces those property As a concrete examples we want to show that the size of the reversed sequence is equal to that of the original sequence

Let SameSizeSeq be a family indexed by the Seqpair with a constructor enforcing this property  




466
6data SameSizeSeq  s  SizeW a  Set a where


688
8ssseq   s z  Seq A s  Seq A z  s  z  SameSizeSeq s





Reimplementing the rev method with this output type is straightforward and achieves the correctness goal It is presented in the Appendix

For arbitrary properties a powerful approach would be to make the induction process obvious




066
6property  Seqpair A  Set a




The problem that remains is proving the inductive step This seemed impossible to me because of the limitations of the view operation




066
6inductivestep   s  SizeW


61616
16 seq  Seq A size 1  s


61616
16 x  Entry A


61616
16 xs  Seq A s


61616
16 viewL seq  ConsL x xs


61616
16 property pack xs


61616
16 property pack seq



Notes

 add concatenation in the finger tree implementation with all the proofs 

 start thinking about evaluation 


Evaluation

In the previous sections I have experimented with various ways to implement and prove correct a data structure using Agda 

The running example was the implementation of the FingerTree chosen because of the combination of many concepts in a single data structure


The data structure is used extensively in functional programming being part of the Haskell standard library  

It is based on the existence of a monad and a measurement function whose assumptions provide interesting starting points for proofs

It is a nested type therefore not widely supported in functional languages  

It allowed a nontrivial index in the dependent implementation namely the measure

It is a good example to outline the limitations of languages like agda with respect to the termination checker


This project was originally intended as an supportive argument towards the use of dependent types and understanding what causes the unpopularity in industry

I will therefore compare two instances of the Random Access Sequence one using the implementation of the FingerTree as presented in the Implementation section and the other one using a version with a trivial index Size with no correctness enforced through dependent types

Runtime

The first comparison that could be made is too see whether the dependent typing incurs an additional cost on the programming This is not per se an evaluation of the code but more of the extraction process and the compilation 

The current version of Agda 2511 makes available three compilers all tagged as experimental ghc js and uhc Unfortunately the two last ones did not work on my machine causing it to crash or filling up all the available RAM 16GB

I have only used my machine for these experiments with specifications detailed in table To reduce the error in the results I have limited the related processes usage to a single core

Furthermore I have repeated each experiment between 10 and 1000 times limiting each measurement to approx 10 minutes and only reported the smallest value which could be read as a lower bound of the runtime















 

cons

For the first experiment I am evaluating the runtime of consing  elements to a sequence  is limited by the available memory of the system 

For this purpose I have implemented a simple recursive consing function and forced  its evaluation by a tab operation  The output is done via the Haskelllike Monad way




044
4bigseq  n    Seq  size n


044
4bigseq zero  Empty


044
4bigseq suc n  entry n  bigseq n







044
4main  putStrLn toCostring Hello 


41212
12 x  return bigseq 1024 


41212
12 x  putStrLn toCostring showmaybex  1 


41212
12 x  return 1


 

Bellow is a plot of the runtimes for the dependent and the nondependent versions on a loglog scale 














































split

This experiment is an extension of the previous one The difference is that we require tab operation that depends on the length of the sequence I have chosen for this purpose to identify the middle element

Also since we require creating a bigsequence to start with I have subtracted the results from the previous experiment so the values are the minimum time to extract the middle element from an increasingly long sequences


















































I is clear from both these experiments that the dependent versions incurs a higher computational cost Moreover the ends show that the divergence between the two depends on the input size  However this is not a limitation of dependent types but of the compiler and extracting tools All the type annotations could be removed without damaging correctness

reversing and problems with the compiler

I have tried to repeat the same type of experiment comparing the runtime of the reverseft method implemented using foldl and the rev method which uses the ViewL

Unfortunately the compilation of the latter method was not successful Whereas the normalization tool always returns the correct result running a compiled version has caused a Segmentation Fault error This is quite damaging to the application since a compiler that doesnt preserve the semantics of the code doesnt necessarily preserve correctness 

Heuristics for Effort

There is no doubt that creating a dependent and verified version of a particular algorithm or data structure incurs an additional cost In this section I will try to explore the effort ratio between the implementing a simplistic solution versus a formally verified one 

It is worth emphasizing that although computing or estimating efforts is in general an illdefined task some heuristics could help compare the different versions of the same data structure and see if the figures carry on across data structures

I have suggested using two heuristics one computing the explosion in SLOC  and the other one quantifying the axiom and lemma content in the definitions

Lines of code

I will present the ratio between the lengths of different versions commenting on what they achieve Although arguably counting lines of code is not always representative in this case it seems suitable since 

All the presented code has been written by a single programmer 
I have been consistent with jumping to new lines


I will make a clear distinction between internal verification and external verification  By the former I mean properties that are made clear through the type of the definitions themselves eg the use of measure as an index while the latter refers to proofs which are carried outside of the definition eg foldlcorrect

For this metric I have decided to discard all the externally verified properties since there is no bound on their number On the other hand internal verification directly affects the implementations difficulty

Furthermore I will separate all lines into three categories type annotations proofs related to type checking and the actual implementation

Selection Sort

The selection sort procedure presented in section whatever is an example of a fully formally verified procedure as all that can be expected of a sorting function is encoded in the type system This differs from the FingerTree implementation which only enforces correctness of the measurement

















The unverified example in this case does not run in Agda It would require proofs of termination I have only presented this as a reference point for the Finger Tree example

Finger Tree
















 

It is interesting to see the same ratios remaining consistent As a sanity check the code related to implementation has stayed constant The proofs carry around half of the code for a verified version This depends of course on the number of invariants we are trying to maintain A further increase in the lines that express type signature lead to an overall 25 factor of explosion in the code

As a side note the effort as illustrated here is not directly related to difficulty since the more expressive types in verified versions make the goals of implementation clearer

Lemma Usage

The previous examples did not include any metric about the externally verified properties 
Performing this evaluation experiment showed that all the lemmas are constructed from calls to our assumptions base lemmas


about the equivalence relation refl sym cong and trans
about the monoid relation associativity  is neutral element
about List associativity of  and  is neutral element
 

I have performed an analysis of what lemmas are being used by each declaration followed by a flattening of the result to the base lemmas The final numbers can be seen as a metric of effort but also such an analysis could potentially be helpful to refactoring A summary of results if given below

















 

This graph suggests two things First of all due to the declaration of the monoid operator as infixl the operations that have a rightassociative structure tend to be easier to prove This constrasts cons and viewL to snoc and viewR 

I believe that the split operation is even more difficult because apart from taking over the difficulties of both viewL and viewR it also combines two different types of logic statements 

Although we rely only on the Curry Howard Isomorphism it also incorporates the Boolean data type and its associated operations and or negation Instead of proceeding as before using 
 



022
2proofistrue   a  property a


022
2proofisfalse   a  property a  


 

We now also make use of 




022
2predistrue   a  predicate a  true


022
2predisfalse   a  predicate a  false




This inconvenience became more noticeable when I tried to port the Isabelle implementation  which is not based on dependent types Although they can be fully encoded the proofs become unnecessarily long due to the lack of type checking support This would perhaps be a start point for some future work

Discussion

As part of the introduction we proposed a question related to how far Agdas expressivity can take us in the implementation of a functional data structure

In relation to Matthieu Souzeaus paper  I have completed the implementations of all the operations he suggested Furthermore I have presented an Agda way to deal with the termination checking problem discussed in his section 441 Dependence Hell 
It is interesting to note that this problem is not strictly related to Agda but to a wider family of dependently typed languages 

In addition I have also explicitly proven axioms that relate Finger Trees to their list representation





Appendix

Numerical Representations

The treatment of containers as natural numbers has been studied in depth The basic idea is that simple numerical operations correspond naturally to operations on containers For example

 
lcl
increasing a number  corresponds to  adding an element

decreasing a number  corresponds to  removing an element 

adding two numbers  corresponds to  merging to containers 

 


This treatment of numbers represented in various numerical basis allows the constructions the obey the implicit recursive slowdown presented by okasaki This allows in lazy languages like Haskell implementation of operations such as insertion and deletion in ammortised O1 cost  which represented a breakthrough in functional programming languages

Further example of the termination checking limitation

In this section I will present a data structure as implemented by Ralf Hinze and show the issues that could arise because of the termination checker in more detail 

Consider the trivial implementation of a binary tree in a functional programming language




244
4data Bush A  Set  Set where


466
6Leaf  A  Bush A


466
6Fork  Bush A  Bush A  Bush A




In order to stay consistent with the original implementation the data structure above will be split in two different types that represent the constructors 





244
4data Leaf A  Set  Set where


466
6LEAF  A  Leaf A





044
4data Fork B  Set  SetA  Set  Set where


466
6FORK  B A  B A  Fork B A





We can now refer to the Random Access Sequence implementation
They are a numerical representation based on base two of natural numbers however rather than the 01 system the author prefers to use the 12 system for a number of effiency reasons


lcl
     

     
 
     

 


This  operator should correspond analogously to the Cons operators in the data structure





044
4data RandomAccessList B  Set  Set A  Set  Set where


466
6Nil  RandomAccessList B A


466
6One  B A  RandomAccessList Fork B A  RandomAccessList B A


466
6Two  Fork B A  RandomAccessList Fork B A  RandomAccessList B A




Now by implemending the function  we can see the similarity between the adding an element to the left and the number representation 




044
4incr  B  Set  Set A  Set  B A  RandomAccessList B A  RandomAccessList B A


044
4incr b Nil  One b Nil


044
4incr b One b ds  Two FORK b b ds


044
4incr b Two b ds  One b incr b ds



We can finally declare a sequence by using the definition of Leaf as a layer of abstraction




044
4IxSequence  Set  Set


044
4IxSequence  RandomAccessList Leaf




044
4cons  A  Set  A  IxSequence A  IxSequence A


044
4cons a s  incr LEAF a s




Defining a view 

We can then implement the  method which returns a view of the list in terms of the first element and a continutation Our goal is to abstract away the intricacy of the type declaration so we can implement methods  easily First we need to declare the return type wrapped in a view data structure






044
4data View A  Set  Set where


466
6Vnil  View A


466
6VCns  A  IxSequence A  View A





044
4front  A  Set  IxSequence A  View A


044
4front Nil  Vnil


044
4front One LEAF x ds  VCns x  zero ds


044
4front Two FORK LEAF a b ds  VCns a  One b ds




The zero method is a restructuring method as we will find in the Finger Tree implementation




044
4zero  B  Set  Set A  Set 


466
6RandomAccessList Fork B A 


466
6RandomAccessList B A


044
4zero Nil  Nil


044
4zero One b ds  Two b zero ds


044
4zero Two FORK b b ds  Two b One b ds


 

Example termination failure

Here Agda termination checker will fail We will try to implement an append function which is a straightforward process given the methods previously declared




044
4append  A  Set  A  IxSequence A  IxSequence A


044
4append x seq with front seq


044
4append x seq  Vnil  cons x Nil


044
4append x seq  VCns head  tail  cons head append x tail




Using sized types

Sized types are agdas response to fixing such issues However trying to come up with an implementation that type checks even in this relatively simple case seems to be very difficult The intuition in this case is that we need to convince agda that FORK a b is bigger than any individual a b in the context of the RAL constructors However sized types are only relative not on an absolute scale




044
4data RandomAccessList B  Set  SetA  Set  i  Size  Set where


466
6Nil   i  RandomAccessList B A i


466
6One   i  B A  RandomAccessList Fork B A i  RandomAccessList B A  i


466
6Two   i  Fork B A  RandomAccessList Fork B A i  RandomAccessList B A   i




044
4incr  B  Set  Set A  Set i  Size  B A  RandomAccessList B A i  RandomAccessList B A  i


044
4incr b Nil  One b Nil


044
4incr b One b ds  Two FORK b b ds


044
4incr b Two b ds      34
34 One b incr b ds





Consider the implementation of incr The problem arises when we are recursively calling incr b ds  This is where the complication of nested types arose in the first place incr is a polymorphic function so in the second interation it would be instantiated with 

 

 


Now it is obvious that inserting an element of type Fork B A should increase the size of the container by more than inserting an element of type A would Under this polymorphism however the two operations are equivalent
The solution to this problem would require a size scaled on the type so that sizeFork B A  sizeA However this needs to be hardcoded for specific type as Agda has no way of differentiating between different types of type Set so no general method is available

Other Agda Syntax and Terminology

Agdas interactive help

Before writing the implementation of a function as you stumble upon the equals sign
you can tell agda to place a hole   instead of an implementation Here you can
perform a number of operations
  
  See the types and values of variables in the scope
  Casesplit 

    For example consider the addition of natural numbers 

    
    

      


m  n  
    
    Performing a casesplit on the variable n shows me all the possible ways in which a natural number can be constructed 

   
   

      


zero  n  


suc m  n  


  Refine and Auto 

    These provide the automated and interactive ways of theoremproving Essentially Agda looks throughout the environment to find
    an inhabitant a variable that has the type of the hole 

    They are definitely not as powerfull as any functionality given by Coq of Isabelle but it can save some typing

  

Implicit Arguments
  Agda introduces some syntax for various types of arguments you can provide to functions As you probably saw
  there is a difference in handling the polymorphic types in the case of List and the values given as arguments
  to type constructors in the case of Vec 


  In the declaration of Vec 



data Vec A  Set    Set where


022
2 6
6 Vec A zero


022
2   n  A  Vec A n  Vec A suc n 45
45



  The first A  Set is the type argument for instantiating a polymorphic type before the  while the  is the type of the value argument for
  the dependently typed instantiation

  Another think to notice here is the curly brackets n   in the declaration of the  constructor
  This is called an implicit argument Agda will bind n to a value it sees fit in the scope If there are more possibilities it will take a guess

Instance Arguments

  Throughout this dissertation we will be using some properties of certain types for example of having a monoid operation associated with them
  In Haskell you would accomplish that with the use of type classes  

  In order to mimic this behaviour we will use instance arguments They are declared by using double square brackets   or the unicode
  equivalent 

  What Agda does in this case it looks for a possible instantiation of that type in the current scope following some predefined rules 
  It is important there is only one available possibility otherwise it will fail to type check

  The use will become obvious in the Implementation section






