\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{textcomp}
\usepackage{docmute}   % only needed to allow inclusion of proposal.tex
\usepackage{enumitem}
\usepackage{listings}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{shapes,backgrounds,arrows,automata}

\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{mathdots}
\usepackage{xcolor}
\usepackage{parskip}
\usepackage{agda}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
language=Haskell,
aboveskip=5pt,
belowskip=5pt,
showstringspaces=false,
%columns=flexible,
columns=fullflexible,
keepspaces=true,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{black},
frame=none,
keywordstyle=\color{black},
commentstyle=\color{black},
stringstyle=\color{black},
breaklines=true,
breakatwhitespace=true,
xleftmargin=20pt,
xrightmargin=0pt,
tabsize=4}

\newcommand{\C}{\AgdaInductiveConstructor}
\newcommand{\D}{\AgdaDatatype}
\newcommand{\F}{\AgdaFunction}
\newcommand{\K}{\AgdaKeyword}

\usepackage{mathtools}
\usepackage{tabu}
\usepackage{tabularx}
\usepackage{hyperref}

\newcommand{\textdelta}{$\delta$}
\renewcommand{\chapterautorefname}{\S\!\!}
\renewcommand{\sectionautorefname}{\S\!\!}
\renewcommand{\subsectionautorefname}{\S\!\!}

\definecolor{AgdaComment}      {HTML}{B22222}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\DeclareUnicodeCharacter{8759}{$\dblcolon$}
\DeclareUnicodeCharacter{8343}{$_l$}
\DeclareUnicodeCharacter{8336}{$_a$}
\DeclareUnicodeCharacter{737}{$^\textrm{l}$}
\DeclareUnicodeCharacter{8344}{$_m$}
\DeclareUnicodeCharacter{7522}{$_i$}
\usepackage[english]{babel}
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}[section]


\setlength{\mathindent}{0cm}
\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


 \pagestyle{empty}
 
 \rightline{\LARGE \textbf{Swaraj Dash}}
 
 \vspace*{60mm}
 \begin{center}
 \Huge
 \textbf{On the Formal Unification of Parsers and Pretty Printers} \\[5mm]
 Computer Science Tripos -- Part II \\[5mm]
 Trinity Hall \\[5mm]
 
 13 May, 2016  % today's date
 \end{center}
 
 \definecolor{orange}{rgb}{1,0.5,0}
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % Proforma, table of contents and list of figures
 
 \pagestyle{plain}
 
 \chapter*{Proforma}
 
 \vspace{-3em}
 {\large
 \begin{tabular}{l p{4.3in}}
 Name:               & \bf Swaraj Dash                       \\
 College:            & \bf Trinity Hall                     \\
 Project Title:      & \bf On the Formal Unification of Parsers and Pretty Printers \\
 Examination:        & \bf Computer Science Tripos -- Part II \\
 Word Count:         & \bf 11980\\
 Project Originators: & Dr Dominic Mulligan and Dr Jeremy Yallop                    \\
 Supervisors:         & Dr Dominic Mulligan and Dr Jeremy Yallop       \\ 
 \end{tabular}
 }
 \stepcounter{footnote}
 
 \vspace{-1em}
 \section*{Original Aims of the Project}
 
 The project aims to create a library for describing parsers and pretty printers via a single definition, along with built-in mechanically verified proofs of correctness in the dependently typed programming language Agda. This extends previous unverified work in unifying parsing and pretty printing.
 
 \section*{Work Completed}
 
 I have met all my proposed success criteria and have implemented one extension. I successfully formalised partial isomorphisms and implemented combinators for parsing and pretty printing. Following this milestone, I proved the correctness of my parser and printer combinators by showing that they are inverses of each other, and used these combinators to describe the syntax of primitive recursive functions and arithmetic expressions. As an extension, I proved my combinators to satisfy a set of algebraic laws, demonstrating their well-behavedness as algebraic objects. I have extended prior research by proving more general properties to hold for my implementation.
 
 \section*{Special Difficulties}
 
 None.
  
 \newpage
 \section*{Declaration}
 
 I, Swaraj Dash of Trinity Hall, being a candidate for Part II of the Computer
 Science Tripos, hereby declare
 that this dissertation and the work described in it are my own work,
 unaided except as may be specified below, and that the dissertation
 does not contain material that has already been used to any substantial
 extent for a comparable purpose.
 
\bigskip
\leftline{Signed}

\

\leftline{Date \qquad\ \ 11 May, 2016}
 
 \tableofcontents
 
 \listoffigures
 
 \listoftables
 
 \newpage

\pagestyle{headings}

\chapter{Introduction}

Parsers turn strings into structured data; pretty printers turn structured data into strings (Figure \ref{fig:intro}).
This dissertation describes the construction of a library for unified parsing and pretty printing, along with a machine-checked proof of correctness in the dependently typed programming language {\it cum} theorem prover Agda. 
% Formal specifications -- such as those for programming languages and network protocols -- are normally described using a string representation and an abstract syntax. The conversion of string representations to abstract syntax is known as parsing; the reverse process is pretty printing.
It is clear from the dual nature of parsing and pretty printing, and their relation to a common grammar, that specifying them both separately introduces redundancy, which is a source for potential errors and inconsistencies. This redundancy can be avoided if there is a means to specify parsers and printers through a single definition.
This project makes it possible to define a correct-by-construction parser and pretty printer from a single description of the syntax to be parsed and pretty printed.
\begin{figure}[H] 
\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.3]
  \node[circle,draw,minimum size=0.8cm] (1) at (5,-2)  {1};
  \node[circle,draw,minimum size=0.8cm] (2) at (7,-2)  {2};
  \node[circle,draw,minimum size=0.8cm] (3) at (8,-1)  {3};
  \node[circle,draw,minimum size=0.8cm] (4) at (6,-1) {+};
  \node[circle,draw,minimum size=0.8cm] (5) at (7,0) {$\times$};
  \node[draw,minimum size=1.2cm] (6) at (0,-1) {``(1+2) $\times$ 3''};
  \node[minimum size=0.1cm] (6) at (1.5,-0.8)  { };
  \node[minimum size=0.1cm] (7) at (1.5,-1.2)  { };
  \node[minimum size=0.1cm] (8) at (4.6,-0.8)  { };
  \node[minimum size=0.1cm] (9) at (4.6,-1.2)  { };

% \path[line width=0.7mm] (1)  edge [bend right] node {} (2);
  \path[-] (3)  edge node {} (5);
  \path[-] (4)  edge node {} (5);
  \path[-] (1)  edge node {} (4);
  \path[-] (2)  edge node {} (4);
  \path (9)  edge node [below] {Pretty printing} (7);
  \path (6)  edge node [above] {Parsing} (8);
  \end{tikzpicture}
\end{center}
\caption{Parsing and pretty printing}
\label{fig:intro}
\end{figure}
\section{Project summary}

The approach I took to combining parsing and pretty printing is described by Rendel and Ostermann in their paper \emph{Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing} \cite{invert}. In this paper, the authors define a set of combinators (higher-order functions) that make it possible to describe a parser (\autoref{parse}) and a printer (\autoref{print}) via a single definition. These parsers and printers are linked to each other by partial isomorphisms (\autoref{partialiso}), which are functions allowing reversible computation. I describe these concepts in detail in \autoref{chap2}.

I have extended Rendel and Ostermann's \emph{unverified} work by proving the correctness of my implementation in Agda. I accomplished this by providing machine-checked proofs that parsers and printers constructed using the method described in \emph{Invertible Syntax Descriptions} are inverses of each other. That is, I {proved} that any string that is the result of printing some abstract syntax can be parsed to obtain the original abstract syntax unmodified. This guarantee of invertibility is absent in Rendel and Ostermann's implementation.

I have additionally proved my combinators to satisfy the algebraic laws known as functor and monoid laws (\autoref{laws}) as extensions to my project. These laws indicate my combinators to be algebraically well-behaved.

\section{Related work}

{\bf Combined parsing and printing:} Jansson and Jeuring \cite{jj1}\cite{jj2} take an alternative approach for combined parsing and printing by constructing parsers and printers from polytypic functions (a generalisation of polymorphic functions).
%A polytypic function is a function that is defined by induction on the structure of user-defined datatypes.

Alimarine et al. \cite{alimarine} accomplish unified parsing and printing by introducing the notion of bi-arrows, which are invertible functions similar to partial isomorphisms. This approach is different from Rendel and Ostermann's due to the difference in the role invertibility plays. While Alimarine et al. implement their parsers and printers directly as bi-arrows, Rendel and Ostermann define their combinators as a transformation on top of partial isomorphisms.

A proprietary tool used in industry is the DMS Software Reengineering Toolkit\footnote{\tt http://www.semanticdesigns.com/Products/DMS/DMSToolkit.html}, which provides means for defining language grammars such that parsers and pretty printers can automatically be produced.

{\bf Mechanised theorem proving:} Theorem provers based on higher-order logic include Isabelle \cite{isabelle} and HOL4 \cite{hol4}, both of which were originally developed in the Computer Laboratory, Cambridge. Agda \cite{agda}, Coq \cite{coq}, Idris \cite{idris}, and Matita \cite{matita} belong to the family of type-theory based proof assistants.

Parser and printer combinators have been separately formalised in Agda by Danielsson \cite{nad-parse}\cite{nad-print}. In \emph{Total Parser Combinators}, Danielsson constructed a parsing library with termination guarantees, which he accomplished by mixing induction and coinduction (a technique for defining and proving properties of infinite data structures, such as streams). \emph{Correct-by-Construction Pretty-Printing} describes a library for pretty printing in Agda. In this paper Danielsson makes use of dependent types to ensure that, for each abstract syntax, the constructed document is correct with respect to the abstract syntax and a given grammar. This was done by encoding specific properties in the type signatures of the combinators.

As far as I am aware, the only research in mechanically verifying Rendel and Ostermann's work was done by Affeldt, Nowak, and Oiwa \cite{coq-invert}, where they constructed a similar library in Coq. However, while Affeldt et al. prove their statement of invertibility only for unambiguous grammars, the work I describe here generalises their result, and shows invertibility to hold even for ambiguous grammars. Finally, Affeldt et al. only postulate the property of monotonicity (\autoref{mon}) for their parsers, which is a key assumption in the proof of invertibility, and do not prove it. In my implementation I proved all my parsers to be monotonic, and rely on no postulates.

\section{Summary of completed work}

Recall my success criteria (Appendix C):
\begin{itemize}
\item To formally define partial isomorphisms (defined in \autoref{partialiso}).
\item To implement a set of combinators to perform combined parsing and pretty printing (implemented in \autoref{syndesc}).
\item To describe arithmetic expressions and primitive recursive functions using these combinators (done in \autoref{use}).
\item To prove the correctness of my implementation by providing mechanically verified proofs of my parser and printer combinators being inverses of each other (proved in \autoref{invertible}).
\end{itemize}

I have explicitly met all my success criteria for this project.
As an extension I proved that my combinators satisfy algebraic laws known as the functor and monoid laws, which I detail in \autoref{laws}.

\chapter{Preparation} \label{chap2}
\vspace{-1em}
In this Chapter I survey material required to understand the rest of the report.  
I explain the entirety of this report using Agda, which I introduce in \autoref{agda}. In \autoref{parse} and \autoref{print} I detail the concepts of parsing and pretty printing using combinators. Following the introductions I explain the work done by Rendel and Ostermann in unifying parsing and pretty printing in \autoref{unify}.

\section{Agda} \label{agda}

\subsection{Introduction to Agda}

Agda \cite{agda} is a dependently typed purely functional programming language, where types can depend on values. This ability of types to reference values enables more expressive types than those in non-dependently typed languages, by allowing them to encode properties of programs in their type signatures. With dependent types, a range of bugs (such as ``out of bounds'' errors for arrays) can be statically eliminated, simply by ensuring program typeability.  
Under the Curry-Howard correspondence \cite{curry-how}, programs in Agda correspond to proofs in higher-order intuitionistic logic and types correspond to formulae. 

I begin by constructing some familiar algebraic data types (ADTs) in Agda. Agda permits the declaration of {\bf inductive families of types} \cite{idt}. Similar to ADTs, inductive families are characterised by a set of constructors. Unlike ADTs, however, the return types of constructors of inductive families are allowed to depend on values (also called \emph{indexing by values}), and the return type of each constructor may differ.

The type \F{Bool} contains only two constructors, \C{true} and \C{false}.

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{Bool} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{true} \AgdaSymbol{:} \AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{false} \AgdaSymbol{:} \AgdaDatatype{Bool}\<%
\end{code}
\F{Set} is the type of all small types in Agda. I will say no more about this here other than to note that the reader may assume, as an approximation, that it is the type of types.

The type of lists parametrised by type $A$ has two constructors: the empty list $\C{[]}$ and the ``cons'' constructor (\C{$\_\!\!\dblcolon\!\!\_$}), which prepends elements to lists. It is given by the following definition:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{[]} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_∷\_} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A}\<%
\end{code}
The {\bf underscores} surrounding ``$\dblcolon$'' indicate the locations of expected arguments; in our definition, the cons constructor is infix.  
For example, here is a list of three Boolean values:

\begin{code}
\>\AgdaFunction{bool-list-example} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaDatatype{Bool}\<%
\\
\>\AgdaFunction{bool-list-example} \AgdaSymbol{=} \AgdaInductiveConstructor{true} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{false} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{true} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\<%
\end{code}
\F{Maybe} is a polymorphic type in Agda that represents the addition of a new value to a type. I provide its definition, along with two examples, below:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{Maybe} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{just} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{nothing} \AgdaSymbol{:} \AgdaDatatype{Maybe} \AgdaBound{A}\<%
\\
\\
\>\AgdaFunction{maybe-example₁} \AgdaSymbol{:} \AgdaDatatype{Maybe} \AgdaDatatype{Bool}\<%
\\
\>\AgdaFunction{maybe-example₁} \AgdaSymbol{=} \AgdaInductiveConstructor{just} \AgdaInductiveConstructor{true}\<%
\\
\\
\>\AgdaFunction{maybe-example₂} \AgdaSymbol{:} \AgdaDatatype{Maybe} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaDatatype{Bool}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{maybe-example₂} \AgdaSymbol{=} \AgdaInductiveConstructor{just} \AgdaSymbol{(}\AgdaInductiveConstructor{true} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{false} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\end{code}

\F{Maybe} types have two constructors -- \C{just} and \C{nothing} -- and are used as the return type of functions which may or may not return meaningful values as output. Meaningful outputs of type $A$ are wrapped in the \C{just} constructor, whereas non-meaningful values are represented by \C{nothing}. The Standard ML equivalent of \F{Maybe} is {\tt option}, with the constructors {\tt SOME} and {\tt NONE}.

Functions on inductive families can be defined by pattern matching.

\begin{code}
\>\AgdaFunction{not} \AgdaSymbol{:} \AgdaDatatype{Bool} \AgdaSymbol{→} \AgdaDatatype{Bool}\<%
\\
\>\AgdaFunction{not} \AgdaInductiveConstructor{true} \<[10]%
\>[10]\AgdaSymbol{=} \AgdaInductiveConstructor{false}\<%
\\
\>\AgdaFunction{not} \AgdaInductiveConstructor{false} \AgdaSymbol{=} \AgdaInductiveConstructor{true}\<%
\\
%
\\
\>\AgdaFunction{\_∧\_} \AgdaSymbol{:} \AgdaDatatype{Bool} \AgdaSymbol{→} \AgdaDatatype{Bool} \AgdaSymbol{→} \AgdaDatatype{Bool}\<%
\\
\>\AgdaInductiveConstructor{true} \<[6]%
\>[6]\AgdaFunction{∧} \AgdaBound{b} \AgdaSymbol{=} \AgdaBound{b}\<%
\\
\>\AgdaInductiveConstructor{false} \AgdaFunction{∧} \AgdaBound{b} \AgdaSymbol{=} \AgdaInductiveConstructor{false}\<%
\end{code}

The \F{not} and \F{$\_\!\!\land\!\!\_$} functions above pattern match on \F{Bool}.

Recall that the return types of constructors of inductive families can, unlike ADTs, depend on values. A consequence of this feature is the ability to define {\bf propositional equality} in Agda. Two elements of the same type are propositionally equal if they can be shown to reduce to the same value. Consider the following definition:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{\_≡\_} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{refl} \AgdaSymbol{:} \AgdaBound{x} \AgdaDatatype{≡} \AgdaBound{x}\<%
\end{code}
Propositional equality in Agda is defined as an inductive type depending on a value for which we want to show equality. There is only one constructor \C{refl} (short for reflexive), which asserts that all objects are equal to themselves. Terms enclosed in curly braces are known {\bf implicit arguments}, which the type checker should try to infer.  
Here are some examples of propositional equality being shown: 

\begin{code}
\>\AgdaFunction{prf₁} \AgdaSymbol{:} \AgdaNumber{1} \AgdaDatatype{≡} \AgdaNumber{1}\<%
\\
\>\AgdaFunction{prf₁} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>\AgdaFunction{prf₂} \AgdaSymbol{:} \AgdaNumber{3} \AgdaPrimitive{+} \AgdaNumber{4} \AgdaDatatype{≡} \AgdaNumber{7}\<%
\\
\>\AgdaFunction{prf₂} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>\AgdaFunction{prf₃} \AgdaSymbol{:} \AgdaFunction{[} \AgdaNumber{4} \AgdaFunction{]} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaNumber{2} \AgdaPrimitive{+} \AgdaNumber{2}\AgdaSymbol{)} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{prf₃} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}
In each example, Agda's type checker reduces both sides of the equality until they are equal. We use \C{refl} to indicate that both sides reduce to the same value.

The final Agda feature necessary for the understanding of this project is record creation. Records bundle terms and types together in a convenient manner --- they are tuples of named fields where the types of later fields can depend on earlier ones. In this project, I made use of records to define syntax description combinators and partial isomorphisms, and structure them based on their mutual dependencies.

We can construct product types using records. In the example below, the \K{field} keyword introduces the type of each field, and the \K{constructor} keyword introduces syntax to describe our records. I make use of the \K{constructor} syntax in both examples below.

\begin{code}
\>\AgdaKeyword{record} \AgdaRecord{\_×\_} \AgdaSymbol{(}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{constructor}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_,\_}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{fst} \AgdaSymbol{:} \AgdaBound{A}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{snd} \AgdaSymbol{:} \AgdaBound{B}\<%
\\
%
\\
\>\AgdaFunction{pair₁} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaRecord{×} \AgdaDatatype{ℕ}\<%
\\
\>\AgdaFunction{pair₁} \AgdaSymbol{=} \AgdaNumber{1} \AgdaInductiveConstructor{,} \AgdaNumber{5}\<%
\\
\\
\>\AgdaFunction{pair₂} \AgdaSymbol{:} \AgdaDatatype{Bool} \AgdaRecord{×} \AgdaDatatype{ℕ}\<%
\\
\>\AgdaFunction{pair₂} \AgdaSymbol{=} \AgdaInductiveConstructor{false} \AgdaInductiveConstructor{,} \AgdaNumber{0}\<%
\\
\end{code}

\subsection{Curry-Howard correspondence in Agda}

Having introduced a few features of Agda, I list their correspondences to notions in intuitionistic logic in Table \ref{tab:curry}. This is also known as the \emph{propositions-as-types} interpretation of the Curry-Howard correspondence.

\begin{table}[t]
\begin{center}
\begin{tabular}{ r c c c l }
\hline
{\bf Logic} &&$\iff$&& {\bf Type theory} \\
Truth  &$T$&$\iff$&$\top$& Unit type  \\
Falsity  &$F$&$\iff$&$\bot$& Bottom type  \\
Conjunction &$\land$&$\iff$&$\times$& Product type \\
Disjunction &$\lor$&$\iff$&$\uplus$& Sum type \\
Implication &$\implies$&$\iff$&$\to$& Function type \\
Universal quantification &$\forall$&$\iff$&$\Pi$& Dependent function type \qquad \qquad \\
\qquad Existential quantification &$\exists$&$\iff$&$\Sigma$& Dependent pair\\
{\it Modus ponens} &&$\iff$&& Function application \\
Provability &&$\iff$&& Inhabitation \\
\hline
\end{tabular}
\end{center}
\caption{Curry-Howard correspondence for intuitionistic logic}
\label{tab:curry}
\end{table}

This correspondence enables us to use Agda as a theorem prover. I demonstrate some of these correspondences in Agda below. I explain existential quantification in detail in \autoref{isoalg}, and provide a proof involving universal quantification in \autoref{proving}.

The Agda definitions for the type theory equivalent of truth (\F{$\top$}) and falsity (\F{$\bot$}) are given below:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{⊤} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{tt} \AgdaSymbol{:} \AgdaDatatype{⊤}\<%
\\
%
\\
\>\AgdaKeyword{data} \AgdaDatatype{⊥} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\end{code}

\F{$\top$} only has a single constructor, whereas \F{$\bot$} has no constructor at all. This way it is impossible to construct values of type \F{$\bot$} in a consistent context, which ensures the consistency of Agda's logic.

Recall the product type \F{$\_\!\!\times\!\!\_$} shown previously. Given elements of types $A$ and $B$, which here we interpret as being proofs of $A$ and $B$ interpreted as formulae, the type $A\ \F{$\times$}\ B$ represents the conjunction of $A$ and $B$, again interpreted as a formula.

\begin{code}
\>\AgdaFunction{conjunction} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B} \AgdaSymbol{→} \AgdaBound{A} \AgdaDatatype{×} \AgdaBound{B}\<%
\\
\>\AgdaFunction{conjunction} \AgdaBound{a} \AgdaBound{b} \AgdaSymbol{=} \AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\<%
\end{code}

Disjunction corresponds to the sum type in Agda (also known as disjoint union). It is defined as:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{\_⊎\_} \AgdaSymbol{(}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{inj₁} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A} \AgdaDatatype{⊎} \AgdaBound{B}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{inj₂} \AgdaSymbol{:} \AgdaBound{B} \AgdaSymbol{→} \AgdaBound{A} \AgdaDatatype{⊎} \AgdaBound{B}\<%
\end{code}

The constructors \C{inj$_1$} and \C{inj$_2$} correspond to the introduction rules for disjunctions.  
Using these definitions it is possible to prove statements in propositional logic. The following are proofs demonstrating the commutativity of conjunction and disjunction:

\begin{code}
\>\AgdaFunction{×-comm} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{A} \AgdaDatatype{×} \AgdaBound{B} \AgdaSymbol{→} \AgdaBound{B} \AgdaDatatype{×} \AgdaBound{A}\<%
\\
\>\AgdaFunction{×-comm} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{a}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{⊎-comm} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{A} \AgdaDatatype{⊎} \AgdaBound{B} \AgdaSymbol{→} \AgdaBound{B} \AgdaDatatype{⊎} \AgdaBound{A}\<%
\\
\>\AgdaFunction{⊎-comm} \AgdaSymbol{(}\AgdaInductiveConstructor{inj₁} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{inj₂} \AgdaBound{x}\<%
\\
\>\AgdaFunction{⊎-comm} \AgdaSymbol{(}\AgdaInductiveConstructor{inj₂} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{inj₁} \AgdaBound{x}\<%
\end{code}

The proof of commutativity of conjunction is given by constructing an element of type $B\ \F{$\times$}\ A$. This is done by pattern matching on the input element of type $A\ \F{$\times$}\ B$ to result in values $a$ and $b$, which we then swap. The proof for disjunction follows similarly.

% The conjunction of two statements implies their disjunction.
% 
% \begin{code}
% \>\AgdaFunction{and→or} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{A} \AgdaDatatype{×} \AgdaBound{B} \AgdaSymbol{→} \AgdaBound{A} \AgdaDatatype{⊎} \AgdaBound{B}\<%
% \\
% \>\AgdaFunction{and→or} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{inj₁} \AgdaBound{a}\<%
% \end{code}

{\it Modus ponens} is represented as:
$$\dfrac{A \quad  A \to B}{B}$$
To prove {\it modus ponens} we need to construct an element of type $B$ from, say, elements $a$ and $f$ of types $A$ and $A \to B$. We accomplish this by applying $f$ to $a$.
Under the Curry-Howard correspondence, therefore, {\it modus ponens} is equivalent to function application, as demonstrated by the proof below:

\begin{code}
\>\AgdaFunction{modus-ponens} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{B}\<%
\\
\>\AgdaFunction{modus-ponens} \AgdaBound{a} \AgdaBound{f} \AgdaSymbol{=} \AgdaBound{f} \AgdaBound{a}\<%
\end{code}

All the examples above demonstrate that the inhabitation of a type corresponds to provability of the corresponding proposition in logic.

\subsection{Theorem proving in Agda by example} \label{proving}

In this Section I demonstrate how we can prove the property of associativity of list concatenation in Agda. I first present a mathematical proof of this result, which I later translate into a proof in Agda.

Recursively define list concatenation as:

\begin{code}
\>\AgdaFunction{\_++\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A}\<%
\\
\>\AgdaInductiveConstructor{[]} \AgdaFunction{++} \AgdaBound{ys} \AgdaSymbol{=} \AgdaBound{ys}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaFunction{++} \AgdaBound{ys} \AgdaSymbol{=} \AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaSymbol{(}\AgdaBound{xs} \AgdaFunction{++} \AgdaBound{ys}\AgdaSymbol{)}\<%
\end{code}

\begin{lemma}
For all lists $xs$, $ys$, and $zs$, $xs +\!\!+\ (ys +\!\!+\ zs) \equiv (xs +\!\!+\ ys) +\!\!+\ zs$.
\end{lemma}

I prove this lemma by structural induction on $xs$.

{\bf Base case:} In the base case, $xs$ is the empty list. Then we need to demonstrate that $$ys +\!\!+\ zs \equiv ys +\!\!+\ zs,$$ which is true by definition.

{\bf Inductive step:} Let $xs = w \dblcolon ws$. We need to show that --
$$(w \dblcolon ws) +\!\!+\ (ys +\!\!+\ zs) \equiv ((w \dblcolon ws) +\!\!+\ ys) +\!\!+\ zs).$$
By definition of $\_\!\!+\!\!+\_$, the left-hand side is equivalent to
$$w \dblcolon (ws +\!\!+\ (ys +\!\!+\ zs)).$$
Similarly, the right-hand side is equivalent to
$$w \dblcolon ((ws +\!\!+\ ys) +\!\!+\ zs).$$
These expressions are equal since we have by the inductive hypothesis that $$ws +\!\!+\ (ys +\!\!+\ zs) \equiv (ws +\!\!+\ ys) +\!\!+\ zs.$$
This completes the proof by structural induction.
\hfill{$\blacksquare$}

I now present the corresponding proof in Agda, which I detail line-by-line. First, the complete proof:

\begin{code}
\>\AgdaFunction{++-assoc} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaBound{ys} \AgdaBound{zs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{xs} \AgdaFunction{++} \AgdaSymbol{(}\AgdaBound{ys} \AgdaFunction{++} \AgdaBound{zs}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{xs} \AgdaFunction{++} \AgdaBound{ys}\AgdaSymbol{)} \AgdaFunction{++} \AgdaBound{zs}\<%
\\
\>\AgdaFunction{++-assoc} \AgdaInductiveConstructor{[]} \AgdaBound{ys} \AgdaBound{zs} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{++-assoc} \AgdaSymbol{(}\AgdaBound{w} \AgdaInductiveConstructor{∷} \AgdaBound{ws}\AgdaSymbol{)} \AgdaBound{ys} \AgdaBound{zs} \AgdaSymbol{=} \AgdaFunction{cong} \AgdaSymbol{(}\AgdaInductiveConstructor{\_∷\_} \AgdaBound{w}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{++-assoc} \AgdaBound{ws} \AgdaBound{ys} \AgdaBound{zs}\AgdaSymbol{)}\<%
\end{code}

\begin{enumerate}
\item The type signature corresponds to the statement of the lemma. Lists $xs$, $ys$, and $zs$ are universally quantified.
\end{enumerate}
We now pattern match on $xs$ to split it into its two cases:
\begin{enumerate}
\setcounter{enumi}{1}
\item
\begin{code}
\>\AgdaFunction{++-assoc} \AgdaInductiveConstructor{[]} \AgdaBound{ys} \AgdaBound{zs} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}
Agda performs the necessary reductions and finally requires a proof for $ys +\!\!+\ zs \equiv ys +\!\!+\ zs$. This is given by \C{refl}.
\item
\begin{code}
\>\AgdaFunction{++-assoc} \AgdaSymbol{(}\AgdaBound{w} \AgdaInductiveConstructor{∷} \AgdaBound{ws}\AgdaSymbol{)} \AgdaBound{ys} \AgdaBound{zs} \AgdaSymbol{=} \AgdaFunction{cong} \AgdaSymbol{(}\AgdaInductiveConstructor{\_∷\_} \AgdaBound{w}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{++-assoc} \AgdaBound{ws} \AgdaBound{ys} \AgdaBound{zs}\AgdaSymbol{)}\<%
\end{code}
This line makes use of the \F{cong} function from Agda's standard library.

\begin{code}
\>\AgdaFunction{cong} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{≡} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{f} \AgdaBound{x} \AgdaDatatype{≡} \AgdaBound{f} \AgdaBound{y}\<%
\end{code}
\F{cong} states that all Agda functions are well-defined with respect to propositional equality. In other words, applying a transformation $f$ to both sides of an equality preserves the equality. 

Using \F{cong} we arrive at a proof for the inductive step by appending (\F{$\_\!\!\dblcolon\!\!\_$} $w$) to both sides of the inductive hypothesis (given by {\F{++-assoc} $ws$ $ys$ $zs$}).
\end{enumerate}
This proves the lemma of associativity of list concatenation in Agda. \hfill{$\blacksquare$}

From this example we observe that under the Curry-Howard correspondence, {\bf induction corresponds to recursion}. Type-checking the program for \F{++-assoc} corresponds to checking the proof of the given proposition. 

This concludes the brief introduction to Agda, where I showed the relation between proofs and programs and introduced concepts that I make use of in the implementation later on.

\section{Parsing via combinators} \label{parse}

Parser combinators are an approach to building recursive descent parsers by modelling parsers as functions and defining higher-order functions (i.e. combinators) to implement common operations found in formal grammars, such as sequencing and choice.

Work on parser combinators was originally motivated by the idea of recursive descent parsing, and has been popularised by Wadler \cite{wadler-parse}, Hutton \cite{hutton-parse}, and Hutton and Meijer \cite{hm-parse}, amongst others. Implementations of parser combinator libraries include Parsec\footnote{\tt https://hackage.haskell.org/package/parsec} in Haskell, boost::spirit\footnote{\tt http://boost-spirit.com/home/} in C++, and JParsec\footnote{\tt https://github.com/jparsec/jparsec} in Java.

I begin by defining a parser in Agda. As stated earlier, parsers are modelled as functions that take strings as input and return parsed values as output. The Agda definition is based on the following properties of parsers:
\begin{itemize}
\item Ambiguous grammars may have multiple parses.
\item {Parsers may fail.}
\item {Parsers need not return abstract syntax trees and can return any desired data type.}
\item Parsers need not consume all the input.
\end{itemize}

We therefore model parsers using the following type:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{Parser} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{parser} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaFunction{String} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{×} \AgdaFunction{String}\AgdaSymbol{))} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A}\<%
\end{code}

In this definition we parametrise parsers by the type of the value they return. The above property of being able to return multiple results translates to the result being a list of values. The empty list by convention denotes parsing failure -- this enables failure to be handled in terms of list operations. Since parsers are not required to consume the entire input string, each result is given by a pair consisting of the parsed value of type $A$ and the part of the string that remains unconsumed. 

This representation of parsers returning multiple results with their respective unconsumed strings makes it possible to build parsers piecewise from smaller parsers.  
Below I list the type signatures of combinators which allow us to combine parsers together. Each combinator represents a standard operation on formal grammars. I discuss the operations of each combinator in \autoref{unify}.

\begin{table}[t]
\begin{center}
\begin{tabular}{|c|c c l|}
\hline
Pure & \F{pure} &:& $\F{Parser}\ A$ \\
\hline
Token & \F{token} &:& $\F{Parser}$ \F{Char} \\
\hline
Empty & \F{empty} &:& $\F{Parser}\ A$ \\
\hline
Choice & $\_\langle|\rangle\_$ &:& $\F{Parser}\ A \to \F{Parser}\ A \to \F{Parser}\ A$ \\
\hline
Functor
 & $\_\langle\$\rangle\_$ &:& $(A \to B) \to \F{Parser}\ A \to \F{Parser}\ B$ \\
\hline
Sequence & $\_\langle\bullet\rangle\_$ &:& $\F{Parser}\ A \to \F{Parser}\ B \to \F{Parser}\ (A \times B)$ \\
\hline
Repetition & $\ \ \ \! \langle\star\rangle\_$ &:& $\F{Parser}\ A \to \F{Parser}\ (\F{List}\ A)$ \\
\hline
\end{tabular}
\label{tab:parser}
\caption{Parser combinators}
\end{center}
\end{table}

{Functors are families of types with a general ``{\tt map}'' operation. Lists, for example, are an instance of a functor with their \F{map} function. I detail functors in \autoref{laws}.}

As an example, a parser combinator for parsing the grammar $A ::= (\ A\ A\ )\ |\ \varepsilon $ would look like the following:
$$A = \F{token}\ `(`\ \langle\bullet\rangle\ A\ \langle\bullet\rangle A\ \langle\bullet\rangle\ \F{token}\ `)`\ \langle|\rangle\ \F{empty}$$
The code fragment above illustrates the use of combinators in building up parsers. The \F{token} combinator constructs parsers for the single tokens `(' and `)'. The sequence combinator $\langle\bullet\rangle$ runs the first parser on its input and threads the unconsumed string to the second parser. Using this combinator, the parser for $A$ is defined recursively as the sequencing of two parsers for $A$, which are enclosed in the \F{token} combinators to parse the brackets. The \F{empty} token corresponds to $\varepsilon$ in the grammar. These two parsers are finally combined using the choice combinator, which returns the union of the results.

The complete parses of a parser are those values for which the entire string has been consumed. They can be extracted by applying the \F{parse} function to a parser and a string:

\begin{code}
\>\AgdaFunction{parse-filter} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{×} \AgdaFunction{String}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A}\<%
\\
\>\AgdaFunction{parse-filter} \AgdaInductiveConstructor{[]} \AgdaSymbol{=} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{parse-filter} \AgdaSymbol{((}\AgdaBound{x} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{[]}\AgdaSymbol{)} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaFunction{parse-filter} \AgdaBound{xs}\<%
\\
\>\AgdaFunction{parse-filter} \AgdaSymbol{(($x$} \AgdaInductiveConstructor{,} \AgdaSymbol{($y$} \AgdaInductiveConstructor{∷} \AgdaSymbol{$z$))} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{parse-filter} \AgdaBound{xs}\<%
\\
%
\\
\>\AgdaFunction{parse} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaFunction{String} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A}\<%
\\
\>\AgdaFunction{parse} \AgdaSymbol{(}\AgdaInductiveConstructor{parser} \AgdaBound{p}\AgdaSymbol{)} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{parse-filter} \AgdaSymbol{(}\AgdaBound{p} \AgdaBound{s}\AgdaSymbol{)}\<%
\end{code}

\F{parse} applies the internal parser $p$ to the input string $s$, and then filters out results in which the entire string has been consumed using \F{parse-filter} (i.e., when the remainder string is the empty string), returning a list of parsed results of type $A$. I compare the application of $p$ to $s$ with and without \F{parse-filter} in Figure \ref{fig:parse}. We observe in the second case that $ast_n$ is filtered since $str_n$ is non-empty. Compared to the unfiltered case, only those parses where the entire string has been consumed are returned when \F{parse} is applied.

\begin{figure}[t] 
\begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.7]
 \node[circle,draw,minimum size=1.2cm] (1)  at (0,-1)  {$str$};
 \node[dotted,draw,minimum size=1.2cm] (2)  at (2,-1)  {Unfiltered parser};
 \node[minimum size=1.2cm] (3)  at (4.5,0.3)  {($ast_1,[\ ])$};
 \node[minimum size=1.2cm] (7)  at (4.5,-1) {$(ast_k,[\ ])$};
 \node[minimum size=1.2cm] (6)  at (4.5,-2.2) {$(ast_n,str_n)$};
 \node[circle,minimum size=1.2cm] (10) at (4.5,-0.3) {$\vdots$};
 \node[circle,minimum size=1.2cm] (9)  at (4.5,-1.5) {$\vdots$};

 \path (1)  edge node {} (2);
 \path (2)  edge node {} (3);
 \path (2)  edge node {} (7);
 \path (2)  edge node {} (6);
%\path (17) edge node {} (6);
%\path (6)  edge node {} (9);
%\path (9)  edge node {} (10);
 \end{tikzpicture}\\ 
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.7]
 \node[circle,draw,minimum size=1.2cm] (1)  at (0,-1)  {$str$};
 \node[draw,minimum size=1.2cm] (2)  at (2,-1)  {Parser};
 \node[minimum size=1.2cm] (3)  at (4.5,0.3)  {$ast_1$};
 \node[minimum size=1.2cm] (7)  at (4.5,-1) {$ast_k$};
 \node[circle,minimum size=1.2cm] (10) at (4.5,-0.3) {$\vdots$};
 \node[circle,minimum size=1.2cm] (9)  at (4.5,-1.5) {$\vdots$};

 \path (1)  edge node {} (2);
 \path (2)  edge node {} (3);
 \path (2)  edge node {} (7);
%\path (17) edge node {} (6);
%\path (6)  edge node {} (9);
%\path (9)  edge node {} (10);
 \end{tikzpicture}\\ 
\end{center}
\caption{Top: application of unfiltered parser. Bottom: application of {\tt parse}.}
\label{fig:parse}
\end{figure}

The function \F{unParser} extracts the inner parsing function.

\begin{code}
\>\AgdaFunction{unParser} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaFunction{String} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{×} \AgdaFunction{String}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{unParser} \AgdaSymbol{(}\AgdaInductiveConstructor{parser} \AgdaBound{p}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaBound{p}\<%
\end{code}

Parser combinators provide the following benefits over traditional parser implementations:
\begin{itemize}
\item Due to the functional nature of parser combinators, they are very compositional; large complicated parsers can be constructed by combining smaller simpler parsers with different combinators.
\item Unlike parser generators, parser combinators are not separate from programming languages -- they are first-class citizens of the language they have been implemented in. This enables users to define combinators by making full use of the power of the programming language.
\item Parser combinators have been shown to satisfy several algebraic properties (such as having monadic and applicative instances \cite{hm-parse}), which allows us to reason about their behaviour, and aggressively refactor them as they satisfy various algebraic laws.
\end{itemize}

\section{Pretty printing via combinators} \label{print}
A pretty printer turns structured data into strings (for example, converting trees to strings, i.e., ``flattening'' trees).  
Pretty printers are defined as:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{Printer} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{printer} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaPostulate{Char}\AgdaSymbol{))} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A}\<%
\end{code}

\F{Maybe} is the option type introduced in \autoref{agda}. Using it in the definition allows us to handle cases of failure in terms of operating on values of type \F{Maybe} $A$.  
As with parsers, the above definition permits the construction of combinators for printers.  
Work on pretty printer combinators has been popularised by Hughes \cite{hughes-print}, Oppen \cite{oppen-print}, and Wadler \cite{wadler-print}. Implementations of pretty printing combinators include the pretty\footnote{\tt https://hackage.haskell.org/package/pretty} and FPretty\footnote{\tt https://hackage.haskell.org/package/FPretty} libraries in Haskell.

Similar to Table \ref{tab:parser}, I provide the type signatures for printer combinators in Table \ref{tab:printer}. I compare the operations of both sets of combinators in Table \ref{table:unify}.

\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c c l|}
\hline
Pure & \F{pure} &:& $\F{Printer}\ A$ \\
\hline
Token & \F{token} &:& $\F{Printer}$ \F{Char} \\
\hline
Empty & \F{empty} &:& $\F{Printer}\ A$ \\
\hline
Choice & $\_\langle|\rangle\_$ &:& $\F{Printer}\ A \to \F{Printer}\ A \to \F{Printer}\ A$ \\
\hline
Cofunctor
 & $\_\langle\$\rangle\_$ &:& $(B \to A) \to \F{Printer}\ A \to \F{Printer}\ B$ \\
\hline
Sequence & $\_\langle\bullet\rangle\_$ &:& $\F{Printer}\ A \to \F{Printer}\ B \to \F{Printer}\ (A \times B)$ \\
\hline
Repetition & $\ \ \ \! \langle\star\rangle\_$ &:& $\F{Printer}\ A \to \F{Printer}\ (\F{List}\ A)$ \\
\hline
\end{tabular}
\label{tab:printer}
\caption{Printer combinators}
\end{center}
\end{table}

Printers can be applied to input objects by making use of the \F{print} function:

\begin{code}
\>\AgdaFunction{print} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaPostulate{Char}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{print} \AgdaSymbol{(}\AgdaInductiveConstructor{printer} \AgdaBound{p}\AgdaSymbol{)} \AgdaBound{a} \AgdaSymbol{=} \AgdaBound{p} \AgdaBound{a}\<%
\end{code}

This function applies the internal printing function $p$ to the input $a$.

\section{Syntax descriptions -- unifying parsing and printing} \label{unify}

Having observed how parsing and pretty printing can be decomposed into relatively simple combinators, we arrive at the main idea underlying the unification of parsing and printing, which I have based this project on. This idea comes from Rendel and Ostermann in their paper titled \emph{Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing} \cite{invert}, where they accomplished this unification in Haskell.

Rendel and Ostermann make use of two observations in this paper. The first is that a common set of combinators can be used to represent parsing and printing combinators. This is achieved by overloading the combinators with the two respective functionalities of parsing and printing and invoking the required methods accordingly, which they call ``syntax description combinators''. The second observation links the unification of the functor and cofunctor combinators for parsers and printers to the notion of partial isomorphisms. I describe both these observations below.

\subsection{Overloading combinators} \label{overload}

Previously, I presented a set of example combinators for parsers and pretty printers from which other combinators can be constructed.
% Note that these are not the only set of combinators that can be used, but they are sufficient to be able to parse and print context free grammars \cite{context}.
% With these combinators as primitives, many combinators can be built on top of them.
I list these combinators in Table \ref{table:unify} and compare their actions on parsers and pretty printers. The operation of the functor and cofunctor combinators has been omitted and is discussed in \autoref{partialiso}.

\begin{table}[H]
\def\tabularxcolumn#1{m{#1}}
\begin{tabularx}{\textwidth}{| p{1.7in} | X | X |}
\hline
\multicolumn{1}{|c|}{Combinator} &
\multicolumn{1}{c|}{$\delta$ = Parser} &
\multicolumn{1}{c|}{$\delta$ = Printer} \\
\hline
\F{pure} : $\delta\ A$&
\F{pure} $c$ is the elementary parser which always succeeds, returning $c$ as the result on any input (which remains unconsumed) &
\F{pure} $c$ compares the input to $c$, and returns \C{just} {\tt ""} if true, and \C{nothing} otherwise \\

\hline
\F{token} : $\delta$ \F{Char}&
\F{token} fails if there is no input, and returns the first character of the input otherwise &
\F{token} simply returns its input character as a single-character string\\

\hline
\F{empty} : $\delta\ A$&
\F{empty} is the elementary parser that always fails, i.e., returns the empty list on any input &
\F{empty} is the elementary printer that always fails, i.e., returns \C{nothing} on any input \\

\hline
$\langle | \rangle$ : $\delta\ A \to \delta\ A \to \delta\ A$&
$\langle | \rangle$ takes two parsers and returns their concatenated individual results for any input &
$\langle | \rangle$ takes two printers; given an input, it uses either printer that doesn't fail, starting with the first one\\

\hline
$\langle \bullet \rangle$ : $\delta\ A \to \delta\ B \to \delta\ (A \times B)$&
$\langle \bullet \rangle$ takes two parsers; it runs its input string through the first parser, threading the remainder string to the second parser and returning the pair of values parsed &
$\langle \bullet \rangle$ takes two printers; if either printer fails on the input then it fails overall, otherwise it returns the concatenated results of the printers\\

\hline
$\langle \star \rangle$ : $\delta\ A \to \delta\ (\F{List}\ A)$&
given a parser {$p$}, $\langle\star\rangle$ {$p$} is a parser that runs {$p$} sequentially on the input until it reaches the end of the strings &
given a printer {$p$}, $\langle\star\rangle$ {$p$} is a printer that can be applied to a list of items to print sequentially; it fails overall if any one fails to get printed \\
\hline
\end{tabularx} 
\caption{Comparison of parser and printer combinators}
\label{table:unify}
\end{table}
Comparing the actions of the combinators on parsers and printers, we can observe that there is a symmetry behind how they work. This observation motivates the idea of reducing the redundancy of providing both, a parser and a printer, by assigning a common set of combinators, which we shall call ``syntax descriptions''. 
By using syntax description combinators, the syntax of the language will only need to be detailed \emph{once}, from which its parser and printer, respectively, can be derived automatically. This is achieved by function overloading (ad-hoc polymorphism), where each combinator is given a parsing and a printing implementation.

Formally, we define a type constructor $\delta$ to be an instance of a syntax description if it is possible to construct the six combinators below with the given type signatures:

\begin{code}
\>\F{pure} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{δ} \AgdaBound{A}\<%
\\
\>\F{token} \AgdaSymbol{:} $\delta$ \F{Char}
\\
\>\F{empty} \AgdaSymbol{:} $\delta$ \AgdaBound{A}
\\
\>{$\_\langle|\rangle\_$} \AgdaSymbol{:} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \AgdaBound{A}
\\
\>{$\_\langle\bullet\rangle\_$} \AgdaSymbol{:} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \AgdaBound{B} \AgdaSymbol{→} $\delta$ \AgdaBound{$(A \times B)$}
\\
\>{$\langle\star\rangle\_$} \AgdaSymbol{:} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \F{List} \AgdaBound{A} 
\end{code}

% The parser and printer instances are obtained by substituting $\delta$ with {\tt Parser} and {\tt Printer}, respectively.

In the next Section I extend this idea to the functor and cofunctor combinators.

\subsection{Partial isomorphisms} \label{partialiso}

Recall the type signatures of the parser (subscript $a$) and printer (subscript $i$) functor and cofunctor combinators, respectively.

\begin{code}
\>{$\_\langle\$\rangle_a\_$} \AgdaSymbol{:} (\AgdaBound{A} $\to$ \AgdaBound{B}) \AgdaSymbol{→} \F{Parser} \AgdaBound{A} \AgdaSymbol{→} \F{Parser} \AgdaBound{B} 
\\
\>{$\_\langle\$\rangle_i\_$} \AgdaSymbol{:} (\AgdaBound{B} $\to$ \AgdaBound{A}) \AgdaSymbol{→} \F{Printer} \AgdaBound{A} \AgdaSymbol{→} \F{Printer} \AgdaBound{B} 
\end{code}

Both combinators take a function $f$ and a parser (resp. printer) $p$ as input.

The functor combinator for parsers first parses an input string, returning values of type {$A$}. These values are then transformed using $f$ to values of type {$B$}, which are the final results.

Conversely, the cofunctor combinator for printers first applies $f$ to the input argument of type {$B$}, transforming it to a value of type {$A$}. This value of type {$A$} is then printed by using $p$, which is the final result of the printer.

Combining these two combinators, then, would require us to combine a function of type $A \to B$ with that of type $B \to A$. Unifying this pair of types implies the ability to use a function in a bidirectional manner, i.e., it would need to be invertible (also known as an isomorphism).  
Since not all functions expressible in general programming languages are invertible, we define the notion of a partial isomorphism such that only functions which can be used forwards and backwards can be considered.

% Rather than working with \emph{total} isomorphisms, however, we will be using \emph{partial} ones. The reasoning behind this is that each constructor of an algebraic data type has an associated partial isomorphism. In the end, these partial isomorphisms will be composed together to give a total isomorphism (and will fail if invalid inputs are provided -- this failure can be indicated by using the {\tt option} type.).

Formally, a partial isomorphism between types A and B is defined as a pair of functions $f : A \to \F{Maybe}\ B$ and $g : B \to \F{Maybe}\ A$ so that $$f\ a \equiv \C{just}\ b \iff g\ b \equiv \C{just}\ a$$ (where $a$ and $b$ are values of types $A$ and $B$ respectively).
A partial isomorphism is then defined as a pair of functions of type $A \to \F{Maybe}\ B$ and $B \to \F{Maybe}\ A$ satisfying these two properties.

Partial isomorphisms enable us to use a function in its forward direction when we are working in the context of parsers, and its backward direction when we are working in a printer context. With this notion of partial isomorphisms, all our syntax descriptions can be unified.

\subsection{Overall}

Finally, the complete definition for syntax descriptions is given by a set of functions satisfying the following type signatures for both $\delta$ = \F{Parser} and $\delta$ = \F{Printer}.
Define \F{Iso} $A$ $B$ to be a partial isomorphism between $A$ and $B$.

\begin{code}
\>\F{pure} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{δ} \AgdaBound{A}\<%
\\
\>\F{token} \AgdaSymbol{:} $\delta$ \F{Char}
\\
\>\F{empty} \AgdaSymbol{:} $\delta$ \AgdaBound{A}
\\
\>{$\_\langle|\rangle\_$} \AgdaSymbol{:} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \AgdaBound{A}
\\
\>{$\_\langle\$\rangle\_$} \AgdaSymbol{:} \F{Iso} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{→} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \AgdaBound{B} 
\\
\>{$\_\langle\bullet\rangle\_$} \AgdaSymbol{:} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \AgdaBound{B} \AgdaSymbol{→} $\delta$ \AgdaBound{$(A \times B)$}
\\
\>{$\langle\star\rangle\_$} \AgdaSymbol{:} $\delta$ \AgdaBound{A} \AgdaSymbol{→} $\delta$ \F{List} \AgdaBound{A} 
\end{code}

Call {$\_\langle\$\rangle\_$} the \emph{iso}functor combinator.

With this definition it is now possible to represent the parser and printer for any grammar by providing a single implementation with the syntax description combinators above. I describe the syntax for the language of primitive recursive functions and the language of arithmetic expressions in \autoref{use} using these combinators.

\section{Requirements analysis} \label{bs}

Analysing the requirements of my project indicated that the development process would be split into two phases -- the combinator construction phase, and the correctness proving phase.

As part of the first phase of development, my aim was to create a platform in Agda which could facilitate the construction of syntax description combinators. This included implementing a library of frequently used functions and defining partial isomorphisms. The second phase, concerned with validating these combinators, would provide machine checked proofs of their invertibility.

The sequential nature of this project where the second phase could only be worked on after the completion of the first phase inspired me to follow the iterative development model. The first phase recursively followed an iterative model for each combinator that I implemented. This development model proved to be beneficial as a result of the relatively small size of each combinator. This enabled me to first ensure their correctness by running them through a set of tests, and finally guaranteeing this correctness by proving it in Agda in the second phase.

Apart from the use of Agda's standard library, this project was implemented from scratch.

\section{Summary}

In this Chapter I have discussed the work undertaken before I started the implementation. I began by introducing Agda (\autoref{agda}), and showed how it can be used as a theorem prover by presenting an example proof. I followed this by describing how the actions of parsing (\autoref{parse}) and printing (\autoref{print}) can be accomplished using a set of combinators (namely, the pure, token, empty, choice, isofunctor, sequence, and repetition combinators).
Finally, I detailed Rendel and Ostermann's technique of combining the set of combinators for parsers and printers into a common set called ``syntax description combinators'' (\autoref{unify}).
% Due to Rendel and Ostermann, we have a technique to combine the set of combinators for parsers and for printers into a single set of seven combinators, called the ``syntax description combinators''.

In the next Chapter I give my implementation of syntax description combinators, following which I prove the correctness of my implementation.

\chapter{Implementation} \label{chap3}

In this Chapter I detail the construction of syntax description combinators and prove their invertibility. I begin this Chapter by presenting a set of helper functions and lemmas in \autoref{help} that I used throughout the implementation. Using these functions and the Agda definition of partial isomorphisms which I discuss in \autoref{iso}, I describe how I implemented all my syntax description combinators in \autoref{syndesc}. In \autoref{strict} and \autoref{mon} I introduce two algebraic properties, namely, strictness and monotonicity, which I show to hold for all parsers. Using these algebraic properties and previously demonstrated lemmas, I state and prove my theorem of invertibility in Agda, which certifies the correctness of my implementation. I summarise this in the dependency graph below:\\

\begin{figure}[H] 
\begin{center}
      \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.3]
          \node[draw,minimum size=1.2cm] (1)  at (-4,0)  {3.1 -- Helper functions and lemmas};
          \node[draw,minimum size=1.2cm] (2)  at (1.6,0)  {3.2 -- Partial isomorphisms};
          \node[draw,minimum size=1.2cm] (3)  at (2.5,-1.5)  {3.3 -- Syntax descriptions};
          \node[draw,minimum size=1.2cm] (4)  at (-3,-3.5) {3.4 -- Strictness};
          \node[draw,minimum size=1.2cm] (5)  at (0,-3.5) {3.5 -- Monotonicity};
          \node[draw,minimum size=1.2cm] (6)  at (0,-6) {3.6 -- Invertibility};

%         \path[line width=0.7mm] (1)  edge [bend right] node {} (2);
          \path (1)  edge node {} (4);
          \path (1)  edge node {} (5);
          \path (2)  edge node {} (3);
          \path (3)  edge [bend right] node {} (4);
          \path (3)  edge node {} (5);
          \path (3)  edge [bend left] node {} (6);
          \path (4)  edge [bend right] node {} (6);
          \path (5)  edge node {} (6);
%         \path[line width=0.7mm] (2)  edge node {} (7);
%         \path (2)  edge node {} (6);
%         \path[line width=0.7mm] (5)  edge [bend right] node {} (1);
%         \path[line width=0.7mm] (7)  edge [bend right] node {} (5);
%         \path (17) edge node {} (6);
%         \path (6)  edge node {} (9);
%         \path (9)  edge node {} (10);
      \end{tikzpicture}
\end{center}
\end{figure}


\section{Helper functions and lemmas} \label{help}

In this Section I describe the implementation of list comprehensions in Agda (used in implementing parsers), reasoning about list membership (used in proofs of monotonicity and invertibility), defining functions to operate on \F{Maybe} types (used in implementing printers), and show results related to partitioning of lists (used in proofs relating to the repetition combinator).

\subsection{Defining list comprehensions in Agda} \label{list}

List comprehensions --- a feature available in some programming languages, such as Python and Haskell --- are expressions that are used for defining lists based on some decidable property. While the syntax of list comprehensions can vary across languages, it is primarily based on set comprehension notation (also known as set-builder notation), such as:
$$ \{ x + y\  |\  x,y \in [0,100],\ x^2 \equiv 3\ (\textrm{mod}\ 4),\ \sin(\pi y) = -1\} $$
List comprehensions in Haskell have a syntax similar to that of set comprehensions. The above example in Haskell would look like:
$$[\ x+y\ |\ x \leftarrow [0..100],\ y \leftarrow [0..100],\ x*x\ \textrm{`mod`}\ 4 == 3,\ \sin{(pi*y)} == -1\ ]$$
In general, a Haskell list comprehension is of the form $[\ X\ |\ Y\ ]$, where $X$ is an expression in terms of the variables introduced in $Y$, and $Y$ is a comma separated list of generators ($x \leftarrow [0..100]$) and predicates ($\sin{(pi * y)} == -1$). 

Rendel and Ostermann made extensive use of list comprehensions in their work. When porting their Haskell code in the syntax descriptions library to Agda, I needed to ensure that my definitions matched those of the authors'. This implied the heavy use of list comprehensions in my codebase, a feature which Agda does not provide by default. Therefore, one of my initial aims in this project was to create a means of being able to describe and use list comprehensions in Agda, which I detail below. 

My implementation of list comprehensions was inspired from the one used in Haskell \cite{monad-comps}, where the list comprehension notation is simply syntactic sugar for a combination of two functions that operate on lists: the monadic bind function on lists \F{>\!\!>\!=$_l$} (implemented using \F{concat} and \F{map}) and \F{return}. They are defined as:

% List comprehensions can therefore be defined in a stateless manner (despite their seemingly imperative interface). 

\begin{code}
\>\AgdaFunction{concat} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A}\<%
\\
\>\AgdaFunction{concat} \AgdaInductiveConstructor{[]} \AgdaSymbol{=} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{concat} \AgdaSymbol{(}\AgdaBound{xs} \AgdaInductiveConstructor{∷} \AgdaBound{xss}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaBound{xs} \AgdaFunction{++} \AgdaFunction{concat} \AgdaBound{xss}\<%
\\
%
\\
\>\AgdaFunction{\_>\!\!>\!=ₗ\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{B}\<%
\\
\>\AgdaBound{xs} \AgdaFunction{>\!\!>\!=ₗ} \AgdaBound{f} \AgdaSymbol{=} \AgdaFunction{concat} \AgdaSymbol{(}\AgdaFunction{map} \AgdaBound{f} \AgdaBound{xs}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{return} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A}\<%
\\
\>\AgdaFunction{return} \AgdaBound{x} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{x} \AgdaFunction{]}\<%
\end{code}

Before showing how these functions can form list comprehensions, I apply an initial simplification to the task: I consider list comprehensions that consist solely of generators. Such an assumption is valid because predicate clauses present inside comprehensions can always be converted to filtering functions which can be applied outside the comprehension. This shows that generator-only comprehensions and full-fledged list comprehensions are equally expressive. As an example, the list comprehension
$$[\ x\ |\ x \leftarrow [0..100],\ \textrm{\tt isOdd}\ x\ ]$$
can be written in a generator-only style as
$${\tt filter\ isOdd}\ [\ x\ |\ x \leftarrow [0..100]\ ]$$
% Note that the filtering functions may sometimes need to be modified, and aren't always the same as the original predicate inside (such as in the case when we replace {\tt x} by {\tt 2*x} in the example above).

And so (without any loss of generality) to be able to describe list comprehensions I made use of the observation that comprehensions of the form:
$$[\ f\ x\ y\ ...\ z\ |\ x \leftarrow xs,\ y \leftarrow ys,\ ...,\ z \leftarrow zs\ ]$$
can be desugared to the following expression.

\begin{code}
\>\AgdaBound{xs} \AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→}\<%
\\
\>\AgdaBound{ys} \AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{y} \AgdaSymbol{→}\<%
\\
\>...
\\
\>\AgdaBound{zs} \AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{z} \AgdaSymbol{→} \AgdaFunction{return} \AgdaSymbol{(}\AgdaBound{f} \AgdaBound{x} \AgdaBound{y} ...\ \AgdaBound{z}\AgdaSymbol{))...))}\<%
\end{code}

I will use ``list comprehension expression'' to refer to the equivalent representation of a list comprehension obtained by desugaring it into its basic functions. From here on I will write $\F{[}\ x\ \F{]}$ instead of \F{return} $x$ in list comprehension expressions.

Using this method I was able to express all the original definitions that made use of list comprehensions in terms of bind, \F{return}, and their respective filtering functions. Note, however, that although this technique makes describing list comprehensions convenient, it makes reasoning about them difficult. This is due to the complexity of the expression that represents the given list comprehension, which contains many nested invocations of the bind function.

With a view to make reasoning about such expressions feasible, I proved a set of lemmas which demonstrate how certain list comprehension expressions are equivalent to more familiar forms, which are easier to work with. I discuss one such lemma in this section.

\begin{lemma}
For any list $xs$ and function $f$, the expression
$$xs\ \F{$>\!\!>\!=_l$}\ (\lambda\ y \to [\ f\ y\ ])$$
is equivalent to
$$\text{\F{map}}\ f\ xs.$$
\end{lemma}
The proof of this lemma follows by structural induction on $xs$ and makes use of \F{cong}, which was introduced in \autoref{agda}. Recall its type signature:

\begin{code}%
\>\AgdaFunction{cong} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{≡} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{f} \AgdaBound{x} \AgdaDatatype{≡} \AgdaBound{f} \AgdaBound{y}\<%
\end{code}
\F{cong} states that any Agda function $f$ is well-defined with respect to propositional equality.

This lemma can be expressed as the following type signature:

\begin{code}
\>\AgdaFunction{>\!\!>\!=ₗ-map} \AgdaSymbol{:} \>[16]\AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→}\<
\\
\>[2]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaBound{xs} \AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{f} \AgdaBound{y} \AgdaFunction{]}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaFunction{map} \AgdaBound{f} \AgdaBound{xs}\<%
\end{code}

Our base case is the case when {$xs$} is the empty list -- its proof follows trivially since Agda automatically reduces both sides, leaving us to show that \C{[]} \F{$\equiv$} \C{[]}.

\begin{code}
\>\AgdaFunction{>\!\!>\!=ₗ-map} \AgdaInductiveConstructor{[]} \AgdaBound{f} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}

For the inductive step, let the list be of the form {$x\ \C{$\dblcolon$}\ xs$}. Assume that a proof for {$xs$} exists, which is given by \F{>\!\!>\!=$_l$-map} $xs$. It is then required to prove that
$${(x\ \C{$\dblcolon$}\ xs)\ \F{$>\!\!>\!=_l$}\ (\lambda\ y \to [\ f\ y\ ])} \equiv {\textrm{\F{map}}\ f\ (x\ \F{$\dblcolon$}\ xs)}.$$
Agda automatically reduces the expressions on both sides as much as possible according to their definitions, and the expression we are left to prove is
$$(f\ x)\ \C{$\dblcolon$}\ (xs\ \F{$>\!\!>\!=_l$}\ (\lambda\ y \to [\ f\ y\ ])) \equiv (f\ x)\ \C{$\dblcolon$}\ \textrm{\F{map}}\ f\ xs$$
This expression is similar to the inductive hypothesis, but with $f\ x$ prepended to both sides. So, this lemma is finally proved by making use of \F{cong} to prepend ${f\ x}$ to both sides of the inductive hypothesis.

\begin{code}
\>\AgdaFunction{>\!\!>\!=ₗ-map} \AgdaSymbol{:} \>[16]\AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaBound{xs} \AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{f} \AgdaBound{y} \AgdaFunction{]}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaFunction{map} \AgdaBound{f} \AgdaBound{xs}\<%
\\
\>\AgdaFunction{>\!\!>\!=ₗ-map} \AgdaInductiveConstructor{[]} \AgdaBound{f} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{>\!\!>\!=ₗ-map} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaBound{f} \AgdaSymbol{=} \AgdaFunction{cong} \AgdaSymbol{(}\AgdaInductiveConstructor{\_∷\_} \AgdaSymbol{(}\AgdaBound{f} \AgdaBound{x}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaFunction{>\!\!>\!=ₗ-map} \AgdaBound{xs} \AgdaBound{f}\AgdaSymbol{)}\<%
\end{code}

This lemma can alternatively be verified by sugaring the list comprehension expression into list comprehension notation. On conversion, the list comprehension obtained looks like:
$$[\ f\ y\ |\ y\ \leftarrow xs\ ].$$
We can see that this is indeed equal to \F{map} $f$ $xs$.
\hfill{$\blacksquare$}\\

A result similar to the lemma above, but one that I did not need to prove was:
$$([\ x\ ]\ \F{$>\!\!>\!=_l$}\ f) \equiv [\ f\ x\ ]$$
This equality automatically follows by definition of \F{concat} and \F{map}, and so no proof was required by Agda. I encountered such expressions in proofs of edge cases.

Overall, I made use of list comprehension expressions throughout my implementation. In addition to other similar lemmas, \F{>\!\!>\!=$_l$-map} proved to be useful in efficiently reasoning about them. 

I proved the results in the remainder of this section in a similar inductive manner.

\subsection{List membership} \label{member}

Proofs of monotonicity and invertibility (\autoref{mon} and \autoref{invertible}) require reasoning about list membership. I now define the list membership relation in Agda and present some useful lemmas.

Intuitively, an element is a member of a list if it is either the head of the list or is a member of the tail of the list. This inductive definition is the motivation behind the way the list membership predicate has been defined:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{\_∈\_} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{here} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{∈} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{there} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{x₁} \AgdaBound{x₂} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{x₁} \AgdaDatatype{∈} \AgdaBound{xs} \AgdaSymbol{→} \AgdaBound{x₁} \AgdaDatatype{∈} \AgdaSymbol{(}\AgdaBound{x₂} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)}\<%
\end{code}

The constructor \C{here} allows the programmer to construct a proof of $x$ $\in$ ($x$ $\dblcolon$ $xs$), for arbitrary $xs$, if the head of a list $x$ is a member of the list (which is then, by definition $x$ $\dblcolon$ $xs$).  
The \C{there} constructor is used to construct proofs of $x_1$ $\in$ ($x_2$ $\dblcolon$ $xs$), provided $x_1$ $\in$ $xs$, for arbitrary $x_2$.

Given a list and an element in it, the membership of that element can be proved using only the \C{here} and \C{there} constructors.
For example:

\begin{code}
\>\AgdaFunction{example-prf} \AgdaSymbol{:} \AgdaNumber{3} \AgdaDatatype{∈} \AgdaSymbol{(}\AgdaNumber{1} \AgdaInductiveConstructor{∷} \AgdaNumber{2} \AgdaInductiveConstructor{∷} \AgdaNumber{3} \AgdaInductiveConstructor{∷} \AgdaNumber{4} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{example-prf} \AgdaSymbol{=} \AgdaInductiveConstructor{there} \AgdaSymbol{\_} \AgdaSymbol{\_} \AgdaSymbol{\_} \AgdaSymbol{(}\AgdaInductiveConstructor{there} \AgdaSymbol{\_} \AgdaSymbol{\_} \AgdaSymbol{\_} \AgdaSymbol{(}\AgdaInductiveConstructor{here} \AgdaSymbol{\_} \AgdaSymbol{\_))}\<%
\end{code}
The underscores are arguments that can be inferred by Agda and therefore need not be passed explicitly.  
In general, the proof that an element is present in the $n^\textrm{th}$ position in a list will consist of $n-1$ uses of \C{there} and one use of \C{here}.

I list below some results based on proving list membership which I made use of in proofs later on. All these results were proved by induction on the structure of the lists involved, similar to the proof of \F{>\!\!>\!=$_l$-map}.

{\bf Mapping a function over a list:}
Consider $x$ and $xs$ such that $x \in xs$. From this we can conclude that  $(f\ x) \in (\textrm{\F{map}}\ f\ xs)$. The type signature of the proof is given by:

\begin{code}
\>\AgdaFunction{∈-map} \AgdaSymbol{:} \>[16]\AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \<
\\
\>[2]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaBound{x} \AgdaDatatype{∈} \AgdaBound{xs} \AgdaSymbol{→} \AgdaBound{f} \AgdaBound{x} \AgdaDatatype{∈} \AgdaFunction{map} \AgdaBound{f} \AgdaBound{xs}\<%
\end{code}

{\bf Concatenating two lists:}
Consider an element $x$ and lists $xs$ and $ys$ such that $x \in xs$. From this we can conclude that $x \in xs +\!\!+\ ys$. The proof has the following type signature:

\begin{code}
\>\AgdaFunction{∈-++ˡ} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} $\to$ \AgdaSymbol{(}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} $\to$ \AgdaSymbol{(}\AgdaBound{xs} \AgdaBound{ys} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{∈} \AgdaBound{xs} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{∈} \AgdaSymbol{(}\AgdaBound{xs} \AgdaFunction{++} \AgdaBound{ys}\AgdaSymbol{)}\<%
\end{code}

Similarly, if $x \in ys$, then we have $x \in xs +\!\!+\ ys$.

\begin{code}
\>\AgdaFunction{∈-++ʳ} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} $\to$ \AgdaSymbol{(}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} $\to$ \AgdaSymbol{(}\AgdaBound{xs} \AgdaBound{ys} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{∈} \AgdaBound{ys} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{∈} \AgdaSymbol{(}\AgdaBound{xs} \AgdaFunction{++} \AgdaBound{ys}\AgdaSymbol{)}\<%
\end{code}

{\bf Computing the \F{concat} of a list:}
If  $[\ x\ ] \in xs$, then $x \in \textrm{\F{concat}}\ xs$ as the \F{concat} function concatenates all the sublists together. This was shown by proving:

\begin{code}
\>\AgdaFunction{∈-concat} \AgdaSymbol{:} \>[16]\AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{))} \AgdaSymbol{→} \>\AgdaFunction{[} \AgdaBound{x} \AgdaFunction{]} \AgdaDatatype{∈} \AgdaBound{xs} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{∈} \AgdaFunction{concat} \AgdaBound{xs}\<%
\end{code}

{\bf Filtering lists:}
If $(\textrm{\C{just}}\ x , y) \in xs$ then {$(x , y) \in \textrm{\F{$\langle\$\rangle${-filter}}}\ xs$ (see \autoref{iso-imp} for the operation of $\langle\$\rangle$-filter).

\begin{code}
\>\AgdaFunction{∈-⟨\$⟩-filter} \AgdaSymbol{:} \>[15]\AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{b} \AgdaSymbol{:} \AgdaFunction{String}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{Maybe} \AgdaBound{A} \AgdaFunction{×} \AgdaFunction{String}\AgdaSymbol{))} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaDatatype{∈} \AgdaBound{xs} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaDatatype{∈} \AgdaFunction{⟨\$⟩-filter} \AgdaBound{xs}\<%
\end{code}


\subsection{{\tt Maybe} functions} \label{maybe}

Recall the definition of \F{Maybe}:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{Maybe} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{just} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{nothing} \AgdaSymbol{:} \AgdaDatatype{Maybe} \AgdaBound{A}\<%
\end{code}

\F{Maybe} is a type constructor. An example use case for \F{Maybe} is to introduce a value to an existing type, to represent failed computations on that type, without reserving any particular value from the original type.

In this Section I look at functions that make it possible to operate on values of type \F{Maybe} without having to explicitly pattern match on the inputs.
%Here I look at some functions that make working with values and transformations involving {\tt Maybe} convenient to use.

The monadic bind function on \F{Maybe}, \F{$>\!\!>\!=_m$} (pronounced ``maybe bind''), allows passing values of type $A$ to functions $f$ when only values of type \F{Maybe} $A$ are available. It is defined as:

\begin{code}
\>\AgdaFunction{\_>\!\!>\!=ₘ\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{B}\<%
\\
\>\AgdaInductiveConstructor{just} \AgdaBound{x} \AgdaFunction{>\!\!>\!=ₘ} \AgdaBound{f} \AgdaSymbol{=} \AgdaBound{f} \AgdaBound{x}\<%
\\
\>\AgdaInductiveConstructor{nothing} \AgdaFunction{>\!\!>\!=ₘ} \AgdaBound{f} \AgdaSymbol{=} \AgdaInductiveConstructor{nothing}\<%
\end{code}

In the case of the input being a meaningful value wrapped in the \C{just} constructor, the bind function applies $f$ to the inner value $x$. Otherwise it returns \C{nothing}. In other words, the bind function permits sequencing of \F{Maybe}-valued functions.

The bind function is associative. One interpretation of the bind function is that it introduces sequentiality in code. Under this interpretation, the associativity of the bind operator implies that it only cares about the order of computations, and not about their nesting. The proof of associativity follows by pattern matching the argument to split it into two cases. In each case Agda can deduce that the left-hand side and right-hand side reduce to the same value, and so the equality holds.

\begin{code}
\>\AgdaFunction{>\!\!>\!=ₘ-assoc} \AgdaSymbol{:} \>[13]\AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaBound{C} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{m} \AgdaSymbol{:} \AgdaDatatype{Maybe} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \<
\\
\>[2]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{g} \AgdaSymbol{:} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{C}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaBound{m} \AgdaFunction{>\!\!>\!=ₘ} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{>\!\!>\!=ₘ} \AgdaBound{g} \AgdaDatatype{≡} \AgdaBound{m} \AgdaFunction{>\!\!>\!=ₘ} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaBound{f} \AgdaBound{x} \AgdaFunction{>\!\!>\!=ₘ} \AgdaBound{g}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{>\!\!>\!=ₘ-assoc} \AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaBound{m}\AgdaSymbol{)} \AgdaBound{f} \AgdaBound{g} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{>\!\!>\!=ₘ-assoc} \AgdaInductiveConstructor{nothing} \AgdaBound{f} \AgdaBound{g} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}

Functions of the form $A \to \textrm{\F{Maybe}}\ B$ can be composed by using the Kleisli composition function \F{$\_\!\!>\!=\!>_m\!\!\_$} defined below:

\begin{code}
\>\AgdaFunction{\_>\!=\!>ₘ\_} \AgdaSymbol{:} \>[13]\AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaBound{C} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{C}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{13}{}\<[13]%
\>[13] \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{C}\AgdaSymbol{)}\<
\\
\>\AgdaFunction{\_>\!=\!>ₘ\_} \AgdaBound{f} \AgdaBound{g} \AgdaBound{a} \AgdaSymbol{=} \AgdaBound{f} \AgdaBound{a} \AgdaFunction{>\!\!>\!=ₘ} \AgdaBound{g}\<%
\end{code}

It is common to apply an operator expecting arguments of type $A$ to values of type \F{Maybe} $A$. \F{liftM2} enables such a functionality, by evaluating to \C{nothing} if either argument is \C{nothing}, and otherwise computing the result and wrapping it in the \C{just} constructor.

\begin{code}
\>\AgdaFunction{liftM2} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaBound{C} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B} \AgdaSymbol{→} \AgdaBound{C}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{C}\<%
\\
\>\AgdaFunction{liftM2} \AgdaBound{f} \AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{just} \AgdaSymbol{(}\AgdaBound{f} \AgdaBound{x} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{liftM2} \AgdaBound{f} \AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaBound{x}\AgdaSymbol{)} \AgdaInductiveConstructor{nothing} \AgdaSymbol{=} \AgdaInductiveConstructor{nothing}\<%
\\
\>\AgdaFunction{liftM2} \AgdaBound{f} \AgdaInductiveConstructor{nothing} \AgdaBound{y} \AgdaSymbol{=} \AgdaInductiveConstructor{nothing}\<%
\end{code}

The \F{mplus} function returns either argument if the argument has a \C{just} constructor (if both arguments satisfy this criterion, then the first is returned), and returns \C{nothing} otherwise.

\begin{code}
\>\AgdaFunction{mplus} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A}\<%
\\
\>\AgdaFunction{mplus} \AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{\_} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{mplus} \AgdaInductiveConstructor{nothing} \AgdaBound{y} \AgdaSymbol{=} \AgdaBound{y}\<%
\end{code}

\F{mplus} is an associative function, which I proved in Agda. The proof follows by case splitting the first argument so that Agda can deduce that in both cases, the left-hand side and right-hand side reduce to the same value.

\begin{code}
\>\AgdaFunction{mplus-assoc} \AgdaSymbol{:} \>[13]\AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{:} \AgdaDatatype{Maybe} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \<%
\\
\>[13] \AgdaFunction{mplus} \AgdaBound{x} \AgdaSymbol{(}\AgdaFunction{mplus} \AgdaBound{y} \AgdaBound{z}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaFunction{mplus} \AgdaSymbol{(}\AgdaFunction{mplus} \AgdaBound{x} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{z}\<
\\
\>\AgdaFunction{mplus-assoc} \AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaBound{x}\AgdaSymbol{)} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{mplus-assoc} \AgdaInductiveConstructor{nothing} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}

I made use of all these functions and their properties in the implementation related to printers.

\subsection{Partitions of a list} \label{parts}

Partitioning a list into contiguous sublists played an important role in the implementation of the repetition combinator $\langle\star\rangle$. Since one of my aims was to prove the invertibility of $\langle\star\rangle$, proving certain properties about my partitioning function consequently followed. Here I discuss one such lemma that I had to prove: 
%(1) showing that none of the sublists returned by the partitioning function could be empty and (2) that
the set of all partitions of a list contains the list itself.

\begin{definition}
Define a partition of a list to be a list of non-empty contiguous sublists, which when concatenated together form the original list. Let the function \F{parts} return all such partitions of the list.
\end{definition}

For example, \F{parts} $[1,2,3] = [[[1],[2],[3]],\ [[1],[2,3]],\ [[1,2],[3]],\ [[1,2,3]]].$ Note that
%(1) none of the sublists contain the empty list, and that (2)
the input list is contained in the results.

\F{parts} can be defined recursively.

\begin{code}
\>\AgdaFunction{parts-filter} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{y} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)))} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{parts-filter} \AgdaSymbol{\_} \AgdaInductiveConstructor{[]} \AgdaSymbol{=} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{parts-filter} \AgdaBound{y} \AgdaSymbol{(}\AgdaInductiveConstructor{[]} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{parts-filter} \AgdaBound{y} \AgdaBound{xs}\<%
\\
\>\AgdaFunction{parts-filter} \AgdaBound{y} \AgdaSymbol{((}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaInductiveConstructor{∷} \AgdaBound{xss}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{((}\AgdaBound{y} \AgdaInductiveConstructor{∷} \AgdaBound{x}\AgdaSymbol{)} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaInductiveConstructor{∷} \AgdaFunction{parts-filter} \AgdaBound{y} \AgdaBound{xss}\<%
\\
%
\\
\>\AgdaFunction{parts} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{parts} \AgdaInductiveConstructor{[]} \AgdaSymbol{=} \AgdaInductiveConstructor{[]} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{parts} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{map} \AgdaSymbol{(}\AgdaInductiveConstructor{\_∷\_} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaFunction{parts} \AgdaBound{xs}\AgdaSymbol{))} \AgdaFunction{++} \AgdaFunction{parts-filter} \AgdaBound{x} \AgdaSymbol{(}\AgdaFunction{parts} \AgdaBound{xs}\AgdaSymbol{)}\<%
\end{code}

In the case of an empty list, there is only one partition which is the list containing only \C{[]}. When the list is non-empty, its partitions are defined in terms of the head and the partitions of the tail. 

With the definition established, we can begin to prove the following lemma.

\begin{lemma}
The set of all partitions of a list also contains the list itself.
$$[\ xs\ ] \in \textrm{\F{parts}}\ xs$$
\end{lemma}

By careful analysis and experimentation of the \F{parts} function it can be concluded that the original list always appears last in the list of all partitions. With the help of this observation I could transform the proof of showing that {\F{[} $xs$ \F{]}} is the last element of \F{parts} $xs$ to an inductive proof. The proof by induction is based on the invariant that at each recursive stage if {$xs$} is at the end of \F{parts} $xs$, then it must be present in the second half of the definition, i.e., {$xs$} must be a member of \F{parts-filter} $x$ (\F{parts} $xs$)}. This idea is illustrated in Figure \ref{fig:parts}, where I show how the statement ``the element lies in the second half'' remains invariant iff it is the last element.
\begin{figure}[t] 
\begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.5]
 \coordinate (bottom left) at (-8,0.5);
 \coordinate (top right) at (0,0);
 \draw[dashed] (bottom left) rectangle (top right);

 \coordinate (bottom left) at (-4,1.5);
 \coordinate (top right) at (0,1);
 \draw[dashed] (bottom left) rectangle (top right);

 \coordinate (bottom left) at (-2,2.5);
 \coordinate (top right) at (0,2);
 \draw[dashed] (bottom left) rectangle (top right);

 \node[circle,draw,minimum size=0.2cm,fill=black] (1)  at (-0.2,0.25)  {};
 \node[circle,draw,minimum size=0.2cm,fill=black] (1)  at (-0.2,2.25)  {};
 \node[circle,draw,minimum size=0.2cm,fill=black] (1)  at (-0.2,1.25)  {};
 \node[minimum size=0.2cm] (1)  at (-0.2,3.1)  {$\vdots$};
 \node[circle,draw,minimum size=0.2cm,fill=black] (1)  at (-0.2,3.7)  {};

 \coordinate (bottom left) at (-0.4,3.5);
 \coordinate (top right) at (0,4);
 \draw[dashed] (bottom left) rectangle (top right);

 \end{tikzpicture}
\end{center}
\caption{Inductive hypothesis for {\tt parts} proof}
\label{fig:parts}
\end{figure}

The following sub-lemma was crucial in being able to prove this result:

\begin{code}
\>\AgdaFunction{∈-filter-parts} \AgdaSymbol{:} \>[3]\AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→}
\>[17]\AgdaSymbol{(}\AgdaBound{ys} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)))} \AgdaSymbol{→}\<%
\\
\>[3]\AgdaFunction{[} \AgdaBound{xs} \AgdaFunction{]} \AgdaDatatype{∈} \AgdaBound{ys} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{xs} \AgdaFunction{]} \AgdaDatatype{∈} \AgdaFunction{parts-filter} \AgdaBound{x} \AgdaBound{ys}\<%
\end{code}

\F{$\in$-filter-parts} shows that if a singleton list \F{[} $xs$ \F{]} is in $ys$, then the list \F{[} $x \dblcolon xs$ \F{]} is in \F{parts-filter} $x$ $ys$. The list membership result this lemma states is very similar to the definition of \F{parts}, which is why \F{$\in$-filter-parts} proved to be useful.  
I proved it by case-splitting $ys$; each case either held trivially or followed by induction on the list.

The outline of the inductive step of the proof is as follows:
\begin{enumerate}
\item Assume ${\F{[ } xs\ \F{]} \in \textrm{\F{parts}}\ xs}$.
\item Then by \F{$\in$-filter-parts}, we have {\F{[} $x$ $\dblcolon$ $xs$ \F{]}} $\in$ {\F{parts-filter} $x$ (\F{parts} $xs$)}
\item {\F{[} $x$ $\dblcolon$ $xs$ \F{]} $\in$ \F{parts-filter} $x$ (\F{parts}\ $xs$)} $\implies$ \\
{\F{[} $x$ $\dblcolon$ $xs$ \F{]} $\in$ (\textrm{\F{map}} (\F{[} $x$ \F{]} $\dblcolon$) (\textrm{\F{parts}}\ $xs$)) $+\!\!+$ (\F{parts-filter} $x$ (\F{parts} $xs$))} \\
(Concatenating preserves the elements in both lists.)
\item Therefore, {\F{[} $x$ $\dblcolon$ $xs$ \F{]} $\in$ \F{parts} ($x$ $\dblcolon$ $xs$)}
\end{enumerate}
Point (3) made use of the \F{$\in$-++$^{r}$} result shown earlier.

I arrived at the complete the proof for {\F{[} $xs$ \F{]} $\in$ \F{parts}\ $xs$} by invoking all the sub-lemmas above.

\begin{code}
\>\AgdaPostulate{∈-parts} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{xs} \AgdaFunction{≢} \AgdaInductiveConstructor{[]} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{xs} \AgdaFunction{]} \AgdaDatatype{∈} \AgdaFunction{parts} \AgdaBound{xs}\<%
\end{code}
\hfill{$\blacksquare$}

Another result which was crucial to proving the monotonicity and invertibility of the repetition combinator was \F{parts-map}, which states that \F{map} (\C{$\_\!\!\dblcolon\!\!\_$} $x$) (\F{parts} $xs$) is an order-preserving sublist of \F{parts} ($x$ \F{++} $xs$) (for non-empty $xs$).

\begin{code}
\> \AgdaPostulate{parts-map} \AgdaSymbol{:} \>[15]\AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{xs} \AgdaBound{ys} \AgdaSymbol{:} \AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{xs} \AgdaFunction{≢} \AgdaInductiveConstructor{[]} \AgdaSymbol{→} 
\\
\>[15]\AgdaFunction{map} \AgdaSymbol{(}\AgdaInductiveConstructor{\_∷\_} \AgdaBound{xs}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{parts} \AgdaBound{ys}\AgdaSymbol{)} \AgdaDatatype{⊆} \AgdaFunction{parts} \AgdaSymbol{(}\AgdaBound{xs} \AgdaFunction{++} \AgdaBound{ys}\AgdaSymbol{)}\<%
\end{code}

\F{parts-map} was useful in simplifying proofs where I needed to show the existence of an element in \F{parts} ($xs$ \F{++}\ $ys$). Demonstrating this is not easy as \F{parts} ($xs$ \F{++}\ $ys$) is not defined solely in terms of the partitions of $xs$ and $ys$. \F{map} (\C{$\_\!\!\dblcolon\!\!\_$}\ $xs$)\ (\F{parts} $ys$), on the other hand, satisfies this criterion, and so is easier to reason about.

\section{Partial isomorphisms} \label{iso}
Recall partial isomorphisms from \autoref{partialiso}. In this section I present their definition in Agda, extending the Haskell definition given in \cite{invert} to include their invertibility property.
\begin{definition}
A partial isomorphism is a pair of functions -- $f : A \to \textrm{\F{Maybe }} B$ and $g : B \to \textrm{\F{Maybe }} A$ -- such that for all a : A and b : B
$$f(a) \equiv \textrm{\C{just }} b \iff g(b) \equiv \textrm{\C{just }} a$$
\end{definition}

I implemented partial isomorphisms in Agda via records, as dependent records make it possible to package functions together with their properties. I split my definition of partial isomorphisms into two records -- one to contain the functions (\F{Iso}), and the other to contain the two properties (\F{IsIso}). Such a separation of objects from their properties is standard practice in Agda's libraries\footnote{The \F{Algebra} library for example: {\tt www.cse.chalmers.se/\~{}nad/listings/lib-0.7/Algebra.html}}.

\begin{code}
\>\AgdaKeyword{record} \AgdaRecord{IsIso} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{g} \AgdaSymbol{:} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{constructor}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_,\_}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{prop₁} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{b} \AgdaSymbol{:} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{f} \AgdaBound{a} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{b} \AgdaSymbol{→} \AgdaBound{g} \AgdaBound{b} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{a}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{prop₂} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{b} \AgdaSymbol{:} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{g} \AgdaBound{b} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{a} \AgdaSymbol{→} \AgdaBound{f} \AgdaBound{a} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{b}\<%
\\
%
\\
\>\AgdaKeyword{record} \AgdaRecord{Iso} \AgdaSymbol{(}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{constructor}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_,\_⟨\_⟩}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{f} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{B}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{g} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{is-iso} \AgdaSymbol{:} \AgdaRecord{IsIso} \AgdaBound{f} \AgdaBound{g}\<%
\end{code}

The \K{constructor} field makes it possible to define records in mixfix syntax. That is, given functions $f$ and {$g$} and properties {$p_1$} and {$p_2$} with the appropriate type signatures, we can construct its partial isomorphism as:
$$ f\ ,\ g\ \langle\ p_1\ ,\ p_2\ \rangle$$
We can then define the following functions to use partial isomorphisms:

\begin{code}
\>\AgdaFunction{inverse} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{B} \AgdaBound{A}\<%
\\
\>\AgdaFunction{inverse} \AgdaSymbol{(}\AgdaBound{f} \AgdaInductiveConstructor{,} \AgdaBound{g} \AgdaInductiveConstructor{⟨} \AgdaBound{p₁} \AgdaInductiveConstructor{,} \AgdaBound{p₂} \AgdaInductiveConstructor{⟩}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaBound{g} \AgdaInductiveConstructor{,} \AgdaBound{f} \AgdaInductiveConstructor{⟨} \AgdaBound{p₂} \AgdaInductiveConstructor{,} \AgdaBound{p₁} \AgdaInductiveConstructor{⟩}\<%
\\
%
\\
\>\AgdaFunction{apply} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{B}\<%
\\
\>\AgdaFunction{apply} \AgdaSymbol{(}\AgdaBound{f} \AgdaInductiveConstructor{,} \AgdaSymbol{\_} \AgdaInductiveConstructor{⟨} \AgdaSymbol{\_} \AgdaInductiveConstructor{⟩}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaBound{f}\<%
\\
%
\\
\>\AgdaFunction{unapply} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{→} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{A}\<%
\\
\>\AgdaFunction{unapply} \AgdaSymbol{(\_} \AgdaInductiveConstructor{,} \AgdaBound{g} \AgdaInductiveConstructor{⟨} \AgdaSymbol{\_} \AgdaInductiveConstructor{⟩}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaBound{g}\<%
\end{code}

The above definition of partial isomorphisms forces programmers to prove their claims about the invertibility of their functions before they can use them. This is unlike most other languages, where the programmer can only \emph{assume} such claims, but cannot mechanically verify them.

\subsection{Algebra of partial isomorphisms} \label{isoalg}

Partial isomorphisms are central to programming with invertible syntax descriptions. I discuss here how programming with partial isomorphisms can be accomplished while maintaining invertibility guarantees and maximising convenience of use. Although programmers do have the option of writing new partial isomorphisms each time one is required, this approach necessitates proving the invertibility of every isomorphism defined, which soon becomes cumbersome.

Rather than defining partial isomorphisms from scratch every time, it is more convenient to have a set of defined primitive partial isomorphisms along with some functions that let us combine them in different ways. Rendel and Ostermann provide such functions in \cite{invert}.  
I ported these functions to my partial isomorphism library and extended them by providing mechanically checked proofs of correctness, showing that their resultant values are indeed always partial isomorphisms. I list below two such functions; the complete set can be found in Appendix A.

{\bf The identity partial isomorphism}:

\begin{code}
\>\AgdaFunction{id} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{A}\<%
\\
\>\AgdaFunction{id} \AgdaSymbol{=} \AgdaInductiveConstructor{just} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{just} \AgdaInductiveConstructor{⟨} \AgdaSymbol{(λ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{prf} \AgdaSymbol{→} \AgdaFunction{sym} \AgdaBound{prf}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaSymbol{(λ} \AgdaBound{b} \AgdaBound{a} \AgdaBound{prf} \AgdaSymbol{→} \AgdaFunction{sym} \AgdaBound{prf}\AgdaSymbol{)} \AgdaInductiveConstructor{⟩}\<%
\end{code}
\F{id} is the identity partial isomorphism (it is analogous to the identity function $f(x) = x$). Both the functions of \F{id} simply wrap their argument in a \C{just} constructor. Its proofs of invertibility require us to show that $x \equiv y \implies y \equiv x$ and vice-versa, i.e., that propositional equality is symmetric, which is shown by the standard library function \F{sym}.  
I prove in \autoref{laws} that \F{id} applied to any syntax description combinator returns the unmodified combinator.

{\bf Composition:}

\begin{code}
\>\AgdaFunction{\_∘\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaBound{C} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{B} \AgdaBound{C} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{C}\<%
\\
\>\AgdaFunction{\_∘\_} \AgdaSymbol{(}\AgdaBound{g} \AgdaInductiveConstructor{,} \AgdaBound{g⁻¹} \AgdaInductiveConstructor{⟨} \AgdaBound{gp₁} \AgdaInductiveConstructor{,} \AgdaBound{gp₂} \AgdaInductiveConstructor{⟩}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{f} \AgdaInductiveConstructor{,} \AgdaBound{f⁻¹} \AgdaInductiveConstructor{⟨} \AgdaBound{fp₁} \AgdaInductiveConstructor{,} \AgdaBound{fp₂} \AgdaInductiveConstructor{⟩}\AgdaSymbol{)} \AgdaSymbol{=} 
\>[82]\AgdaSymbol{(}\AgdaBound{f} \AgdaFunction{>\!=\!>ₘ} \AgdaBound{g}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{g⁻¹} \AgdaFunction{>\!=\!>ₘ} \AgdaBound{f⁻¹}\AgdaSymbol{)} \AgdaInductiveConstructor{⟨} \AgdaFunction{...} \AgdaInductiveConstructor{⟩}\<%
\end{code}

\F{$\_\!\!\circ\!\!\_$} is the composition function for partial isomorphisms. The implementation of \F{$\_\!\!\circ\!\!\_$} uses the Kleisli composition operator discussed in \autoref{maybe}. I proved the invertibility of composition by making use of two lemmas: \F{compose} and \F{interpolate}.

\begin{code}
\>\AgdaFunction{compose} \AgdaSymbol{:} \>[14]\AgdaSymbol{\{}\AgdaBound{X} \AgdaBound{Y} \AgdaBound{Z} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} (\AgdaBound{x} : $X$) $\to$ (\AgdaBound{y} : $Y$) $\to$ (\AgdaBound{z} : $Z$) \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{(}\AgdaBound{u} \AgdaSymbol{:} \AgdaBound{X} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{Y}\AgdaSymbol{)} $\to$ \AgdaSymbol{(}\AgdaBound{v} \AgdaSymbol{:} \AgdaBound{Y} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{Z}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{(}\AgdaBound{u} \AgdaBound{x} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{v} \AgdaBound{y} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{z}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{(}\AgdaBound{u} \AgdaFunction{>\!=\!>ₘ} \AgdaBound{v}\AgdaSymbol{)} \AgdaBound{x} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{z}\<%
\end{code}
\begin{code}
\>\AgdaFunction{interpolate} \AgdaSymbol{:} \>[18]\AgdaSymbol{\{}\AgdaBound{X} \AgdaBound{Y} \AgdaBound{Z} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} (\AgdaBound{x} : $X$) $\to$ (\AgdaBound{z} : $Z$) \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaSymbol{(}\AgdaBound{u} \AgdaSymbol{:} \AgdaBound{X} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{Y}\AgdaSymbol{)} $\to$ \AgdaSymbol{(}\AgdaBound{v} \AgdaSymbol{:} \AgdaBound{Y} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaBound{Z}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaSymbol{(}\AgdaBound{u} \AgdaFunction{>\!=\!>ₘ} \AgdaBound{v}\AgdaSymbol{)} \AgdaBound{x} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{z} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaFunction{∃} \AgdaSymbol{λ} \AgdaBound{y} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{u} \AgdaBound{x} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{y}\AgdaSymbol{)} \AgdaFunction{×} \AgdaSymbol{(}\AgdaBound{v} \AgdaBound{y} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{z}\AgdaSymbol{)}\<%
\end{code}

\F{interpolate} is an existential proof which shows the existence of an intermediate value $y$ when the Kleisli composition of two \F{Maybe} values is given.
Recall from \autoref{agda} that proofs of existential statements in Agda are encoded as pairs where the second value depends on the first. The statement ``$\exists x. P(x)$'' (where $P$ is a predicate) is written in Agda as:

\begin{code}
\>[2]\AgdaPostulate{existential} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{P} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{∃} \AgdaSymbol{λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaBound{P} \AgdaBound{x}\<%
\end{code}
A proof for this statement would be a pair where the first element is a satisfying value of $x$ (say $x_0$) and the second element is a proof demonstrating that $P(x_0)$ holds.
Proving \F{interpolate} consisted of presenting such a pair. I showed this by case-splitting on the result of $u\ x$ in order to indicate to Agda what the interpolating value could be.

I pass the value $y$, computed using \F{interpolate}, to \F{compose} which uses it to glue two other Kleisli compositions together, thereby completing the proof.% I proved both these lemmas by pattern matching on their respective arguments.
% 
% The proof for {\tt compose} was similarly shown by pattern matching the arguments until each case trivially held.

\section{Syntax description combinators} \label{syndesc}
In \autoref{unify} I presented all the syntax description combinators and their respective meanings. Here I show the details of how I constructed these combinators in Agda. The implementations of the elementary, isofunctor, choice, and sequence combinators are based on the ones given in \emph{Invertible Syntax Descriptions} \cite{invert}, whereas the repetition combinator was designed and implemented from scratch. I implemented all the combinators using functions introduced in \autoref{list} and \autoref{maybe}. \autoref{chap4} shows these combinators in use.

\subsection{Elementary combinators\\ \small{{\tt pure}, {\tt token}, and {\tt empty}}}

\paragraph{Pure} The \F{pure} elementary combinator is parametrised by an existing value $x$. Its resulting parser and printer relate the empty input with $x$.

A \F{pure} $x$ parser returns {$x$} without consuming any input.

\begin{code}
\>\AgdaFunction{parser-pure} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{Decidable} \AgdaDatatype{\_≡\_} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A}\<%
\\
\>\AgdaFunction{parser-pure} \AgdaBound{dec} \AgdaBound{x} \AgdaSymbol{=} \AgdaInductiveConstructor{parser} \AgdaSymbol{(λ} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{[} (\AgdaBound{x} \AgdaInductiveConstructor{,} \AgdaBound{y}) \AgdaFunction{]}\AgdaSymbol{)}\<%
\end{code}

A \F{pure} $x$ printer discards values that are equal to {$x$}. Equality is tested by ${dec}$, a function of type \F{Decidable} $\_\!\!\equiv\!\!\_$ which compares {$x$} to {$y$}, given an equality relation ($\_\!\!\equiv\!\!\_$) for them, and returns explicit proofs of whether or not $x$ and $y$ are equal. Values of type \F{Decidable} have two constructors: \C{yes} and \C{no}, corresponding to whether or not the two arguments are equal. Then, by pattern matching on the comparison, the appropriate results are returned.

\begin{code}
\>\AgdaFunction{pure-internal} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{Decidable} \AgdaDatatype{\_≡\_} 
\>[16]\AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaPostulate{Char}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{pure-internal} \AgdaBound{dec} \AgdaBound{x} \AgdaBound{y} \AgdaKeyword{with} \AgdaBound{dec} \AgdaBound{x} \AgdaBound{y}\<%
\\
\>\AgdaFunction{pure-internal} \AgdaBound{dec} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{|} \AgdaInductiveConstructor{yes} \AgdaBound{p} \AgdaSymbol{=} \AgdaInductiveConstructor{just} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{pure-internal} \AgdaBound{dec} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{|} \AgdaInductiveConstructor{no} \AgdaBound{¬p} \AgdaSymbol{=} \AgdaInductiveConstructor{nothing}\<%
%
\end{code}
\begin{code}
\>\AgdaFunction{printer-pure} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{Decidable} \AgdaDatatype{\_≡\_} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A}\<%
\\
\>\AgdaFunction{printer-pure} \AgdaBound{dec} \AgdaBound{x} \AgdaSymbol{=} \AgdaInductiveConstructor{printer} \AgdaSymbol{(λ} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{pure-internal} \AgdaBound{dec} \AgdaBound{x} \AgdaBound{y}\AgdaSymbol{)}\<%
\end{code}

\paragraph{Token} The \F{token} combinator relates each character with itself.

As a parser, \F{token} returns the first character of its input string. \F{parser-token} therefore succeeds if a single character string is given to it, and fails otherwise.

\begin{code}
\>\AgdaFunction{token-internal} \AgdaSymbol{:} \AgdaFunction{String} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaPostulate{Char} \AgdaFunction{×} \AgdaFunction{String}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{token-internal} \AgdaInductiveConstructor{[]} \AgdaSymbol{=} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{token-internal} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{xs}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{x} \AgdaInductiveConstructor{,} \AgdaBound{xs} \AgdaFunction{]}\<%
\\
%
\\
\>\AgdaFunction{parser-token} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaPostulate{Char}\<%
\\
\>\AgdaFunction{parser-token} \AgdaSymbol{=} \AgdaInductiveConstructor{parser} \AgdaFunction{token-internal}\<%
\end{code}

The printer instance just returns its input character as a single-character string.

\begin{code}
\>\AgdaFunction{printer-token} \AgdaSymbol{:} \AgdaDatatype{Printer} \AgdaPostulate{Char}\<%
\\
\>\AgdaFunction{printer-token} \AgdaSymbol{=} \AgdaInductiveConstructor{printer} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaInductiveConstructor{just} \AgdaFunction{[} \AgdaBound{x} \AgdaFunction{]}\AgdaSymbol{)}\<%
\end{code}

\paragraph{Empty} The \F{empty} combinator always fails. Both its parser and printer instances reflect this by returning their respective failure values -- the parser returns the empty list and the printer returns \C{nothing}.

\begin{code}
\>[0]\AgdaFunction{parser-empty} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A}\<%
\\
\>[4]\AgdaFunction{parser-empty} \AgdaSymbol{=} \AgdaInductiveConstructor{parser} \AgdaSymbol{(λ} \AgdaBound{s} \AgdaSymbol{→} \AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\end{code}

\begin{code}
\>[0]\AgdaFunction{printer-empty} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A}\<%
\\
\>[4]\AgdaFunction{printer-empty} \AgdaSymbol{=} \AgdaInductiveConstructor{printer} \AgdaSymbol{(λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaInductiveConstructor{nothing}\AgdaSymbol{)}\<%
\end{code}

\subsection{Choice combinator $\langle|\rangle$}

\paragraph{Parsing}
{The choice parser combinator, $\langle | \rangle$, takes two parsers and returns their concatenated individual results for any input}.

\begin{code}
\>\AgdaFunction{\_⟨∣⟩\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A}\<%
\\
\>\AgdaInductiveConstructor{parser} \AgdaBound{p₁} \AgdaFunction{⟨∣⟩} \AgdaInductiveConstructor{parser} \AgdaBound{p₂} \AgdaSymbol{=} \AgdaInductiveConstructor{parser} \AgdaSymbol{(λ} \AgdaBound{s} \AgdaSymbol{→} \AgdaBound{p₁} \AgdaBound{s} \AgdaFunction{++} \AgdaBound{p₂} \AgdaBound{s}\AgdaSymbol{)}\<%
\end{code}

\paragraph{Printing}
{The choice printer combinator, $\langle | \rangle$, takes two printers; given an input, it uses either printer that doesn't fail, starting with the first one}.

\begin{code}
\>\AgdaFunction{\_⟨∣⟩\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A}\<%
\\
\>\AgdaInductiveConstructor{printer} \AgdaBound{p₁} \AgdaFunction{⟨∣⟩} \AgdaInductiveConstructor{printer} \AgdaBound{p₂} \AgdaSymbol{=} \AgdaInductiveConstructor{printer} \AgdaSymbol{(λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{mplus} \AgdaSymbol{(}\AgdaBound{p₁} \AgdaBound{a}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{p₂} \AgdaBound{a}\AgdaSymbol{))}\<%
\end{code}

See \autoref{maybe} for the definition of \F{mplus}.

\subsection{Isofunctor combinator $\langle\$\rangle$} \label{iso-imp}
\paragraph{Parsing}
{Given a partial isomorphism {$iso$} and a parser {$p$}, the parser {$p$} $\langle\$\rangle$ {$iso$} runs its input through {$p$} and transforms the resultant values by applying {$iso$} in the \underline{forward} direction}.

\begin{code}
\>\AgdaFunction{\_⟨\$⟩\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{B}\<%
\\
\>\AgdaBound{iso} \AgdaFunction{⟨\$⟩} \AgdaSymbol{(}\AgdaInductiveConstructor{parser} \AgdaBound{p}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{parser} \AgdaSymbol{(λ} \AgdaBound{s} \AgdaSymbol{→} \AgdaFunction{⟨\$⟩-filter} \>[50]\AgdaSymbol{(}\AgdaBound{p} \AgdaBound{s} \<[76]%
\>[76]\AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{50}{}\<[50]%
\>[50]\AgdaFunction{[} \AgdaSymbol{(}\AgdaFunction{apply} \AgdaBound{iso}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaField{proj₁} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{]} \>[76]\AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{y} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{50}{}\<[50]%
\>[50]\AgdaFunction{[} \AgdaBound{y} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaField{proj₂} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{]}\AgdaSymbol{))))}\<%
\end{code}

The above code can be viewed alternatively as a list comprehension in Haskell (see \autoref{list} for an explanation of the conversion):
$$\F{$\langle\$\rangle$-{filter}}\ [\ (y,\ proj_2\ x)\ |\ x \leftarrow (p\ s),\ y \leftarrow (apply\ iso)\ (proj_1\ x)\ ]$$
Description: the pair $x$ contains the results of applying {$p$} to the input string {$s$}. The partial isomorphism is applied in the forward direction to each parsed value (note that \F{apply} $iso$ returns the first function of the pair). Finally, all the \C{nothing}s are removed and the values inside \C{just} constructors are extracted using \F{$\langle\$\rangle$-filter}. I illustrate this process in Figure \ref{fig:iso}.

\begin{figure}[t] 
\begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.7]
 \node[circle,draw,minimum size=1.2cm] (1)  at (0,-1)  {$str$};
 \node[draw,minimum size=1.2cm] (2)  at (2,-1)  {Parser};
 \node[minimum size=1.2cm] (3)  at (4,0.3)  {$ast_1$};
 \node[minimum size=1.2cm] (7)  at (4,-1) {$ast_k$};
 \node[minimum size=1.2cm] (6)  at (4,-2.2) {$ast_n$};
 \node[minimum size=1.2cm] (8)  at (5.5,0.3)  {\C{just} $ast'_1$};
 \node[minimum size=1.2cm] (9)  at (5.5,-1) {\C{nothing}};
 \node[minimum size=1.2cm] (10)  at (5.5,-2.2) {\C{just} $ast'_n$};
 \node[minimum size=1.2cm] (11)  at (6.9,0.3)  {};
 \node[minimum size=1.2cm] (12)  at (6.9,-1) {};
 \node[minimum size=1.2cm] (13)  at (6.9,-2.2) {};
 \node[minimum size=1.2cm] (21)  at (6.8,0.3)  {};
 \node[minimum size=1.2cm] (23)  at (7.9,0.3) {$ast'_1$};
 \node[minimum size=1.2cm] (31)  at (6.8,-2.2)  {};
 \node[minimum size=1.2cm] (33)  at (7.9,-2.2) {$ast'_n$};
 \node[minimum size=1.3cm,rotate=270] (14)  at (6.85,-1.0) {\F{$\langle\$\rangle$-{filter}}};
 \node[circle,minimum size=1.2cm] (110) at (4,-0.3) {$\vdots$};
 \node[circle,minimum size=1.2cm] (19)  at (4,-1.5) {$\vdots$};
 \node[circle,minimum size=1.2cm] (110) at (5.5,-0.3) {$\vdots$};
 \node[circle,minimum size=1.2cm] (19)  at (5.5,-1.5) {$\vdots$};
 \node[circle,minimum size=1.2cm] (110) at (7.9,-0.9) {$\vdots$};

 \path (21)  edge node {} (23);
 \path (31)  edge node {} (33);
 \path (8)  edge node {} (11);
 \path (9)  edge node {} (12);
 \path (10) edge node {} (13);
 \path (3)  edge node {$iso$} (8);
 \path (7)  edge node {$iso$} (9);
 \path (6)  edge node {$iso$} (10);
 \path (1)  edge node {} (2);
 \path (2)  edge node {} (3);
 \path (2)  edge node {} (7);
 \path (2)  edge node {} (6);
%\path (17) edge node {} (6);
%\path (6)  edge node {} (9);
%\path (9)  edge node {} (10);
 \coordinate (bottom left) at (6.6,-2.5);
 \coordinate (top right) at (7.1,0.6);
 \draw[dashed] (bottom left) rectangle (top right);
 \end{tikzpicture}
\end{center}
\caption{Operation of isofunctor parser combinator}
\label{fig:iso}
\end{figure}

\paragraph{Printing}
{Given a partial isomorphism {$iso$} and a printer {$p$}, the printer {$p$} $\langle\$\rangle$ {$iso$} transforms its input by applying {$iso$} in the \underline{reverse} direction, and then prints it using {$p$}}.

\begin{code}
\>\AgdaFunction{\_⟨\$⟩\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{B}\<%
\\
\>\AgdaBound{iso} \AgdaFunction{⟨\$⟩} \AgdaSymbol{(}\AgdaInductiveConstructor{printer} \AgdaBound{p}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{printer} \AgdaSymbol{(λ} \AgdaBound{b} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaFunction{unapply} \AgdaBound{iso}\AgdaSymbol{)} \AgdaBound{b} \AgdaFunction{>\!\!>\!=ₘ} \AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}

Description: the printer is given a value {$b$} of type {$B$} as input. It applies the partial isomorphism in the reverse direction (\F{unapply} $iso$), transforming it to type \F{Maybe} $A$, which is passed to {$p$} via the bind function (discussed in \autoref{maybe}).

\subsection{Sequence combinator $\langle\bullet\rangle$}

\paragraph{Parsing}
{The sequence parser combinator, $\langle\bullet\rangle$, takes two parsers; it runs its input string through the first parser, threading the remainder string to the second parser and returning the pair of values parsed}.

\begin{code}
\>\AgdaFunction{\_⟨•⟩\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{×} \AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>\AgdaInductiveConstructor{parser} \AgdaBound{p₁} \AgdaFunction{⟨•⟩} \AgdaInductiveConstructor{parser} \AgdaBound{p₂} \AgdaSymbol{=} \AgdaInductiveConstructor{parser} \>[44]\AgdaSymbol{(λ} \AgdaBound{s} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{p₁} \AgdaBound{s}\AgdaSymbol{)} \<[59]%
\>[59]\AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{44}{}\<[44]%
\>[44]\AgdaSymbol{(}\AgdaBound{p₂} \AgdaSymbol{(}\AgdaField{proj₂} \AgdaBound{x}\AgdaSymbol{))} \>[59]\AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{y} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{44}{}\<[44]%
\>[44]\AgdaFunction{[} \AgdaSymbol{((}\AgdaField{proj₁} \AgdaBound{x}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaField{proj₁} \AgdaBound{y}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaField{proj₂} \AgdaBound{y} \AgdaFunction{]}\AgdaSymbol{)))}\<%
\end{code}

This parser makes use of the technique to describe list comprehensions (discussed in \autoref{list}). It can alternatively be viewed as:
$$[\ ((proj_1\ x,\ proj_1\ y),\ proj_2\ y)\ |\ x \leftarrow (p_1\ s),\ y \leftarrow p_2\ (proj_2\ x)\ ]$$
\paragraph{Printing}
{The sequence printer combinator, $\langle\bullet\rangle$, takes two printers; if either printer fails on the input then it fails overall, otherwise it returns the concatenated results of the printers}.

\begin{code}
\>\AgdaFunction{\_⟨•⟩\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{×} \AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{\_⟨•⟩\_} \AgdaSymbol{(}\AgdaInductiveConstructor{printer} \AgdaBound{p₁}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{printer} \AgdaBound{p₂}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{printer} \AgdaSymbol{(λ} \AgdaBound{ab} \AgdaSymbol{→} \AgdaFunction{liftM2} \>[54]\AgdaFunction{\_++\_}\<%
\\
\>[54]\AgdaSymbol{(}\AgdaBound{p₁} \AgdaSymbol{(}\AgdaField{proj₁} \AgdaBound{ab}\AgdaSymbol{))}\<%
\\
\>[54]\AgdaSymbol{(}\AgdaBound{p₂} \AgdaSymbol{(}\AgdaField{proj₂} \AgdaBound{ab}\AgdaSymbol{)))}\<%
\end{code}

See \autoref{maybe} for the definition of \F{liftM2}.

\subsection{Repetition combinator $\langle\star\rangle$}

\paragraph{Parsing}
{Given a parser $p$, {$\langle\star\rangle$ $p$} is a parser that runs {$p$} sequentially on the input, threading the remaining string to itself until it reaches the end}.

\begin{minipage}{\linewidth}
\begin{code}
\>\AgdaFunction{parseList} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaFunction{String}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A} \AgdaFunction{×} \AgdaFunction{String}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{parseList} \AgdaSymbol{\_} \AgdaInductiveConstructor{[]} \AgdaSymbol{=} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{parseList} \AgdaSymbol{(}\AgdaInductiveConstructor{parser} \AgdaBound{p}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{str} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{map} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaFunction{[} \AgdaField{proj₁} \AgdaBound{x} \AgdaFunction{]} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaField{proj₂} \AgdaBound{x}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaBound{p} \AgdaBound{str}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{parseList} \AgdaBound{par} \AgdaSymbol{(}\AgdaBound{str} \AgdaInductiveConstructor{∷} \AgdaBound{strs}\AgdaSymbol{)} \AgdaSymbol{=} \>[29]\AgdaSymbol{(}\AgdaFunction{parse} \AgdaBound{par} \AgdaBound{str}\AgdaSymbol{)}
\>[50]\AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→}\<%
\\
\>[10]\AgdaIndent{29}{}\<[29]%
\>[29]\AgdaSymbol{(}\AgdaFunction{parseList} \AgdaBound{par} \AgdaBound{strs}\AgdaSymbol{)} \>[50]\AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{ys} \AgdaSymbol{→}\<%
\\
\>[10]\AgdaIndent{29}{}\<[29]%
\>[29]\AgdaFunction{[} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaSymbol{(}\AgdaField{proj₁} \AgdaBound{ys}\AgdaSymbol{))} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaField{proj₂} \AgdaBound{ys}\AgdaSymbol{)} \AgdaFunction{]}\AgdaSymbol{))}\<%
\\
\\
\>\AgdaFunction{⟨⋆⟩\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{⟨⋆⟩\_} \AgdaBound{p} \AgdaSymbol{=} \AgdaInductiveConstructor{parser} \AgdaSymbol{(λ} \AgdaBound{str} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaFunction{parts} \AgdaBound{str}\AgdaSymbol{)} \AgdaFunction{>\!\!>\!=ₗ} \AgdaSymbol{(λ} \AgdaBound{s} \AgdaSymbol{→} \AgdaFunction{parseList} \AgdaBound{p} \AgdaBound{s}\AgdaSymbol{))}\<%
\end{code}
\end{minipage}

The repetition combinator makes use of the partitioning function defined in \autoref{parts}. It partitions the input string into all possible tokens and passes that list to the \F{parseList} function. The \F{parseList} function parses each token with the given parser resulting in a set of parses for each token. Finally it computes the Cartesian product of all those sets and returns the list of results. The reason I implemented this combinator in this manner and not in a recursive one was because the recursive definition does not terminate if given a non-consuming combinator. Due to the finiteness of my definition, non-consuming combinators simply fail when provided to the repetition combinator, which matches their expected semantics (since in the case for parsing, non-termination is equivalent to failure).

% There is one important difference between my implementation of the repetition combinator and the one constructed in Invertible:
% the Haskell version of the repetition combinator takes advantage of Haskell's lazy evaluation, and so it is defined as an infinite application of the sequence combinator. This leads non-terminating behaviour if the combinator is given a parser which does not consume any of its input (such as the {\tt pure} parser). My repetition parser, on the other hand, terminates for any parser given to it -- this is attested by Agda's termination checker which determines that each recursive call to $\langle\star\rangle$ has a smaller input than before, and so the computation must terminate. When given a non-consuming parser, this implementation of $\langle\star\rangle$ just returns the empty list, which matches the semantics of parsers (i.e., parsers that don't terminate are, in some way, failing).


\paragraph{Printing}
{Given a printer $p$, {$\langle\star\rangle$ $p$} is a printer that can be applied to a list of items to print sequentially; it fails overall if any one element fails to get printed}.

\begin{code}
\>\AgdaFunction{⟨⋆⟩\_} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaSymbol{(}\AgdaDatatype{List} \AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>[4]\AgdaFunction{⟨⋆⟩\_} \AgdaSymbol{(}\AgdaInductiveConstructor{printer} \AgdaBound{p}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{printer} \AgdaSymbol{(λ} \AgdaBound{as} \AgdaSymbol{→} \AgdaFunction{foldr} \AgdaSymbol{(}\AgdaFunction{liftM2} \AgdaFunction{\_++\_}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{just} \AgdaInductiveConstructor{[]}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{map} \AgdaBound{p} \AgdaBound{as}\AgdaSymbol{))}\<%
\end{code}

The repetition printer first applies the given printer to each element of the list. The resultant list of \F{Maybe String}s is then printed by concatenating all the values inside \C{just} constructors together, which makes use of the standard \F{foldr} function and \F{liftM2} (discussed in \autoref{maybe}). Note that if any value in the list is \C{nothing}, the entire result of concatenation will be \C{nothing} due to the definition of \F{liftM2}. I illustrate this in Figure \ref{fig:repprint}.

\begin{figure}[t] 
\begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.7]
 \node[minimum size=1.2cm] (1)  at (0.5,0)  {$\Big [$};
 \node[minimum size=1.2cm] (2)  at (1,0)  {$ast_1$};
 \node[minimum size=1.2cm] (12)  at (1,-1.5)  {$str_1$};
 \node[minimum size=1.2cm] (c)  at (1.5,-0.1)  {,};
 \node[minimum size=1.2cm] (c)  at (1.5,-1.5)  {+\!+};
 \node[minimum size=1.2cm] (3)  at (2,0)  {$ast_2$};
 \node[minimum size=1.2cm] (13)  at (2,-1.5)  {$str_2$};
 \node[minimum size=1.2cm] (c)  at (2.5,-0.1)  {,};
 \node[minimum size=1.2cm] (c)  at (2.5,-1.5)  {+\!+};
 \node[minimum size=1.2cm] (4)  at (3,0)  {$\hdots$};
 \node[minimum size=1.2cm] (c)  at (3.0,-1.5)  {$\hdots$};
 \node[minimum size=1.2cm] (c)  at (3.5,-0.1)  {,};
 \node[minimum size=1.2cm] (c)  at (3.5,-1.5)  {+\!+};
 \node[minimum size=1.2cm] (5)  at (4,0)  {$ast_n$};
 \node[minimum size=1.2cm] (15)  at (4,-1.5)  {$str_n$};
 \node[minimum size=1.2cm] (16)  at (5,-1.5)  {$\equiv \quad str$};
 \node[minimum size=1.2cm] (1)  at (4.5,0)  {$\Big ]$};

 \path (2)  edge node {$p$} (12);
 \path (3)  edge node {$p$} (13);
 \path (5)  edge node {$p$} (15);
 \end{tikzpicture}\\ 
\end{center}
\caption{Repetition printer combinator}
\label{fig:repprint}
\end{figure}

\section{Strictness} \label{strict}
The property of strictness of parsers demonstrates that consuming parsers, when given the empty input, return the empty string. This property shows that parsers are well-behaved on null inputs. I use the strictness of parsers to show the invertibility of the repetition combinator in \autoref{invertible}.

A function $f : X \to Y$ is defined to be strict if it maps the least value of $X$ to the least value of $Y$. I show that all consuming parsers $p$ are strict by proving that \F{unParser} $p$ $[]$ $\equiv$ $[]$. Recall that \F{unParser} extracts the internal parsing function from a parser.

I packaged the property of strictness of a parser in a \F{Strict} data type. \F{Strict} has one constructor which allows us to show that a parser is strict if the internal function (returned by \F{unParser}) applied to the empty list returns the empty list.

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{Strict} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{strict} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{unParser} \AgdaBound{p} \AgdaInductiveConstructor{[]} \AgdaDatatype{≡} \AgdaInductiveConstructor{[]} \AgdaSymbol{→} \AgdaDatatype{Strict} \AgdaBound{p}\<%
\end{code}

\begin{lemma}[Strictness]
All consuming parsers $p : \F{Parser}\ A$ are strict.
\end{lemma}

I proved this lemma by case analysis and showed it holds for each combinator.
% the elementary combinators (except for {\tt pure}, as it is non-consuming) are considered as the base cases, and the remaining combinators (which take other combinators as input) form the inductive steps.

The proof of each case followed by definition. This was because Agda automatically performs the necessary reductions when the parsers are given the empty list as input. This resulted in showing for each case that {\C{$[]$} \F{$\equiv$} \C{$[]$}}, which is true by \C{refl}. I list all the proofs in Agda below, which are universally quantified for all parsers ($p$, $p_1$, $p_2$) and partial isomorphisms ($iso$).

\begin{code}
\>\AgdaFunction{token-strict} \>[18]\AgdaSymbol{:} \>[20]\AgdaDatatype{Strict} \AgdaFunction{token}\<%
\\
\>\AgdaFunction{empty-strict} \>[18]\AgdaSymbol{:} \>[20]\AgdaDatatype{Strict} \AgdaFunction{empty}\<%
\\
\>\AgdaFunction{choice-strict} \>[18]\AgdaSymbol{:} 
\>[20]\AgdaDatatype{Strict} \AgdaBound{p₁} \>[40]\AgdaSymbol{→} \AgdaDatatype{Strict} \AgdaBound{p₂} \AgdaSymbol{→} \AgdaDatatype{Strict} \AgdaSymbol{(}\AgdaBound{p₁} \AgdaFunction{⟨∣⟩} \AgdaBound{p₂}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{isofunctor-strict} \>[18]\AgdaSymbol{:}
\>[20]\AgdaDatatype{Strict} \AgdaBound{p} \>[40]\AgdaSymbol{→} \AgdaDatatype{Strict} \AgdaSymbol{(}\AgdaBound{iso} \AgdaFunction{⟨\$⟩} \AgdaBound{p}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{sequence-strict} \>[18]\AgdaSymbol{:}
\>[20]\AgdaDatatype{Strict} \AgdaBound{p₁} \>[40]\AgdaSymbol{→} \AgdaDatatype{Strict} \AgdaBound{p₂} \AgdaSymbol{→} \AgdaDatatype{Strict} \AgdaSymbol{(}\AgdaBound{p₁} \AgdaFunction{⟨•⟩} \AgdaBound{p₂}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{repetition-strict} \>[18]\AgdaSymbol{:} \>[20]\AgdaDatatype{Strict} \AgdaBound{p} \>[40]\AgdaSymbol{→} \AgdaDatatype{Strict} \AgdaSymbol{(}\AgdaFunction{⟨⋆⟩} \AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}

We can show any consuming parser to be strict using the cases above.

\hfill{$\blacksquare$}

\section{Monotonicity} \label{mon}
An assumption that is central to proving the invertibility of the sequence combinator is the property that parsers only parse characters in order of their appearance in the input string. 

This is equivalent to saying that if a parser on input ${str} : \F{String}$ parses a value ${ast} : {A}$, then on an input of ${str +\!\!+\  str'}$ its list of unfiltered results \emph{must} contain {$(ast , str')$} for any string {$str'$} (that is, {$str'$} remains unconsumed in at least one case). In other words, such a property guarantees that the results of a parser cannot get deleted on providing it with additional input. Define this property as the \emph{monotonicity} of a parser:

\begin{definition}[Monotonicity]
A consuming parser {$p$} \emph{:} \F{Parser} $A$ is monotonic on input string {$str$} \emph{:} \F{String} and parsed value {$ast$} \emph{:} {$A$}  if for all input strings {$str'$} \emph{:} \F{String},
$$(ast , str') \in \textrm{\F{unParser}}\ p\ (str +\!\!+\ str')$$
\end{definition}
Recall that \F{unParser} $p\ (str +\!\!+\ str')$ returns all the parsed results along with their respective remainder strings -- in the statement above, {$ast$} is the parsed value and {$str'$} is the remainder string.

Such a definition translates to the following predicate in Agda:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{⟦\_⟧⟨\_⇒\_⟩} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaFunction{String} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where} \<[60]%
\>[60]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{monotonic} \AgdaSymbol{:} \>[14]\AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{str} \AgdaSymbol{:} \AgdaFunction{String}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{ast} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{((}\AgdaBound{str′} \AgdaSymbol{:} \AgdaFunction{String}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{ast} \AgdaInductiveConstructor{,} \AgdaBound{str′}\AgdaSymbol{)} \AgdaDatatype{∈} \AgdaFunction{unParser} \AgdaBound{p} \AgdaSymbol{(}\AgdaBound{str} \AgdaFunction{++} \AgdaBound{str′}\AgdaSymbol{))} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaDatatype{⟦} \AgdaBound{p} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast} \AgdaDatatype{⟩}\<%
\end{code}

And so, we can show a parser {$p$} to be monotonic on {$str$} and {$ast$} if we can construct an object of type {$\llbracket\ p\ \rrbracket\langle\ str\ \Rightarrow\ ast\ \rangle$} in Agda.  
This is read as ``the parser {$p$} mapping {$str$} to {$ast$} is monotonic''. I illustrate monotonicity in Figure \ref{fig:mono}, where we can see that apart from newly parsed results, the previously parsed results still exist with the new string $str'$ concatenated to the end.

\begin{figure}[t] 
\begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.7]
 \node[minimum size=1.2cm] (1)  at (0,-1)  {$str$};
 \node[dotted,draw,minimum size=1.2cm] (2)  at (2,-1)  {Unfiltered parser};
 \node[minimum size=1.2cm] (3)  at (4.5,0.3)  {($ast_1,str_1)$};
 \node[minimum size=1.2cm] (7)  at (4.5,-1) {$(ast_k,str_k)$};
 \node[minimum size=1.2cm] (6)  at (4.5,-2.2) {$(ast_n,str_n)$};
 \node[circle,minimum size=1.2cm] (10) at (4.5,-0.3) {$\vdots$};
 \node[circle,minimum size=1.2cm] (9)  at (4.5,-1.5) {$\vdots$};

 \path (1)  edge node {} (2);
 \path (2)  edge node {} (3);
 \path (2)  edge node {} (7);
 \path (2)  edge node {} (6);
%\path (17) edge node {} (6);
%\path (6)  edge node {} (9);
%\path (9)  edge node {} (10);
 \end{tikzpicture}\\ 
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.7]
 \node[minimum size=1.2cm] (1)  at (-1,-1)  {$str +\!\!+\ str'$};
 \node[dotted,draw,minimum size=1.2cm] (2)  at (2,-1)  {Unfiltered parser};
 \node[minimum size=1.2cm] (3)  at (5.1,0.3)  {($ast_1,str_1 +\!\!+\ str')$};
 \node[minimum size=1.2cm] (7)  at (5.1,-1) {$(ast_k,str_k +\!\!+\ str')$};
 \node[minimum size=1.2cm] (6)  at (5.1,-2.2) {$(ast_n,str_n +\!\!+\ str')$};
 \node[circle,minimum size=1.2cm] (10) at (5.1,-0.3) {$\vdots$};
 \node[circle,minimum size=1.2cm] (9)  at (5.1,-1.5) {$\vdots$};

 \path (1)  edge node {} (2);
 \path (2)  edge node {} (3);
 \path (2)  edge node {} (7);
 \path (2)  edge node {} (6);
%\path (17) edge node {} (6);
%\path (6)  edge node {} (9);
%\path (9)  edge node {} (10);
 \end{tikzpicture}\\ 
\end{center}
\caption{Monotonicity of a parser}
\label{fig:mono}
\end{figure}


\begin{theorem}[Monotonicity]
All consuming parsers are monotonic.
\end{theorem}

I proved this theorem by case analysis. From the elementary combinators, monotonicity only holds for \F{token} as it is the only non-consuming non-failing elementary combinator.
%The remaining combinators (which take other combinators as input) form the inductive steps.
All the proofs below are universally quantified over their input parsers ($p$, $p_1$, $p_2$), strings ($str$, $str_1$, $str_2$), and parsed values ($ast$, $ast_1$, $ast_2$). I explain in detail here the proof of monotonicity for the isofunctor combinator. The remaining proofs followed similarly.

{\bf Token:} The proof followed by definition of the \F{token} combinator.

\begin{code}
\>\AgdaFunction{token-monotonic} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{ch} \AgdaSymbol{:} \AgdaPostulate{Char}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{⟦} \AgdaFunction{token} \AgdaDatatype{⟧⟨} \AgdaFunction{[} \AgdaBound{ch} \AgdaFunction{]} \AgdaDatatype{⇒} \AgdaBound{ch} \AgdaDatatype{⟩}\<%
\end{code}

{\bf Choice:} There are two proofs of monotonicity of the choice combinator due to the two branches it can choose between.

\begin{code}
\>\AgdaFunction{choice-monotonic₁} \AgdaSymbol{:} \>[20]\AgdaDatatype{⟦} \AgdaBound{p₁} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast₁} \AgdaDatatype{⟩} \AgdaSymbol{→} \AgdaDatatype{⟦} \AgdaBound{p₂} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast₂} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{20}{}\<[20]%
\>[20]\AgdaDatatype{⟦} \AgdaBound{p₁} \AgdaFunction{⟨∣⟩} \AgdaBound{p₂} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast₁} \AgdaDatatype{⟩}\<%
\\
\\
\>\AgdaFunction{choice-monotonic₂} \AgdaSymbol{:} \>[20]\AgdaDatatype{⟦} \AgdaBound{p₁} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast₁} \AgdaDatatype{⟩} \AgdaSymbol{→} \AgdaDatatype{⟦} \AgdaBound{p₂} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast₂} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[0]\AgdaIndent{20}{}\<[20]%
\>[20]\AgdaDatatype{⟦} \AgdaBound{p₁} \AgdaFunction{⟨∣⟩} \AgdaBound{p₂} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast₂} \AgdaDatatype{⟩}\<%
\end{code}

For both proofs I showed that if an element is a member of one list, then it is also a member of that list concatenated with any other list. This used the lemmas \F{$\in$-++$^l$} and \F{$\in$-++$^r$} (introduced in \autoref{member}).

{\bf Isofunctor:} 
I proved that if a partial isomorphism transforms {$ast$} to {$ast'$}, then the transformed parser is also monotonic on the same input string. The proof of this case has the following type signature:

\begin{code}
\>\AgdaFunction{isofunctor-monotonic} \AgdaSymbol{:} \>[23]\AgdaSymbol{(}\AgdaBound{iso} \AgdaSymbol{:} \AgdaRecord{Iso} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{apply} \AgdaBound{iso} \AgdaBound{ast} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{ast′} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{23}{}\<[23]%
\>[23]\AgdaDatatype{⟦} \AgdaBound{p} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast} \AgdaDatatype{⟩} \AgdaSymbol{→} \AgdaDatatype{⟦} \AgdaBound{iso} \AgdaFunction{⟨\$⟩} \AgdaBound{p} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast′} \AgdaDatatype{⟩}\<%
\end{code}

% I first made use of {\tt >\!\!>\!=$_l$-map} to simplify the list comprehension expression. I then invoked {\tt $\in$-map} to reason about the membership of {\tt (just ast', b)} in the simplified expression. Finally, using {\tt $\in$-concat} and {\tt $\in$-$\langle\$\rangle$-filter}, I was able to prove this case by constructing the required list comprehension expression.

Given the inductive hypothesis that $p$ mapping {$str$} to {$ast$} is monotonic, I demonstrated using \F{$\in$-map} and \F{$\in$-concat} that \F{apply} $iso\ (ast , str')$ is an element of the unfiltered resultant parser. By the assumption that {$iso$} when applied to {$ast$} returns \C{just} $ast'$, I could demonstrate that this value is equivalent to $(\C{just}\ ast' , str')$. The statement to prove is that ${(ast' , str')}$ is a member of the final parser -- I showed this by applying \F{$\langle\$\rangle$-filter-lemma} (defined in \autoref{member}) to the previously proved result, thereby arriving at the required list comprehension expression.

{\bf Sequence:}
If two parsers are monotonic on values {$ast_1$} and {$ast_2$} with inputs {$str_1$} and {$str_2$} respectively, then the combined parser is monotonic on the concatenated input.

\begin{code}
\>\AgdaFunction{sequence-monotonic} \AgdaSymbol{:} 
\>[21]\AgdaDatatype{⟦} \AgdaBound{p₁} \AgdaDatatype{⟧⟨} \AgdaBound{str₁} \AgdaDatatype{⇒} \AgdaBound{ast₁} \AgdaDatatype{⟩} \AgdaSymbol{→} \AgdaDatatype{⟦} \AgdaBound{p₂} \AgdaDatatype{⟧⟨} \AgdaBound{str₂} \AgdaDatatype{⇒} \AgdaBound{ast₂} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{21}{}\<[21]%
\>[21]\AgdaDatatype{⟦} \AgdaBound{p₁} \AgdaFunction{⟨•⟩} \AgdaBound{p₂} \AgdaDatatype{⟧⟨} \AgdaBound{str₁} \AgdaFunction{++} \AgdaBound{str₂} \AgdaDatatype{⇒} \AgdaSymbol{(}\AgdaBound{ast₁} \AgdaInductiveConstructor{,} \AgdaBound{ast₂}\AgdaSymbol{)} \AgdaDatatype{⟩}\<%
\end{code}

This was proved in a manner similar to the monotonicity of the isofunctor combinator. I started out with the assumption of the inductive hypothesis and then invoked \F{$\in$-map} and \F{$\in$-concat} as necessary to build the final expression. 

{\bf Repetition:} There are two proofs for the repetition combinator, corresponding to the two cases in the \F{parseList} function. In the first case:
if a parser {$p$} parses {$ast$} on input {$str$}, then $\langle\star\rangle$ {$p$} is monotonic on parse value \F{[} {$ast$} \F{]} and the input {$str$}. This proof made use of the fact that all parsers are strict, which I showed in \autoref{strict}.

\begin{code}
\>\AgdaFunction{repetition-monotonic$_1$} \AgdaSymbol{:} 
\>\AgdaDatatype{Strict} \AgdaBound{p} \AgdaSymbol{→} 
\>\AgdaDatatype{⟦} \AgdaBound{p} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast} \AgdaDatatype{⟩} \AgdaSymbol{→} \AgdaDatatype{⟦} \AgdaFunction{⟨⋆⟩} \AgdaBound{p} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaFunction{[} \AgdaBound{ast} \AgdaFunction{]} \AgdaDatatype{⟩} \<[71]%
\>[71]\<%
\end{code}

The second case shows how the monotonicity of a parser and a repeated parser can be combined to prove the monotonicity for the repeated parser on a different input.

\begin{code}
\>[2]\AgdaPostulate{repetition-monotonic₂} \AgdaSymbol{:} 
\>[26]\AgdaDatatype{⟦} \AgdaBound{p} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaDatatype{⇒} \AgdaBound{ast} \AgdaDatatype{⟩} \AgdaSymbol{→} \AgdaDatatype{⟦} \AgdaFunction{⟨⋆⟩} \AgdaBound{p} \AgdaDatatype{⟧⟨} \AgdaBound{strs} \AgdaDatatype{⇒} \AgdaBound{asts} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{26}{}\<[26]%
\>[26]\AgdaDatatype{⟦} \AgdaFunction{⟨⋆⟩} \AgdaBound{p} \AgdaDatatype{⟧⟨} \AgdaBound{str} \AgdaFunction{++} \AgdaBound{strs} \AgdaDatatype{⇒} \AgdaBound{ast} \AgdaInductiveConstructor{∷} \AgdaBound{asts} \AgdaDatatype{⟩}\<%
\end{code}

I proved both these cases by using \F{$\in$-parts}, \F{$\in$-map}, \F{$\in$-++$^l$}, and \F{$\in$-++$^r$} as required in order to build the final expressions to prove. They were similar to the isofunctor and sequence monotonicity proofs.

With all the individual cases proved, this proof is complete. I have summarised this proof in Figure \ref{fig:mon}, where I evaluate the usefulness of monotonicity.
\hfill{$\blacksquare$}\\

\section{Invertibility} \label{invertible}
In this Section I establish the validity of all the parsers and printers that have been constructed so far by proving that they fulfill their intended purpose. Before starting, I first formalise the statement to be proved.

A central aim of this project was to show that for any input the action of printing it as a string and then immediately parsing that string will result in the original input.  
Call this property of being able to retrieve the original argument after the combined action of printing and parsing the \emph{invertibility} of syntax descriptions. In the formal definition of invertibility, I took the following points into consideration:
\begin{itemize}
\item The \F{parse} and \F{print} functions cannot simply be composed with each other due to their different type signatures. To parse a printed value one needs to unwrap the \C{just} constructor first.
\item A parser may return multiple parses if the defined grammar is ambiguous.
\item A printer can fail returning \C{nothing}, in which case a parser will not be able to parse anything.
\end{itemize}

This brings us to the definition of invertibility of a parser-printer pair.
%{discussion of structure of proofs}
% ambiguous grammars are bad, assume unambig
% proof by structural induction 
From here on I will refer to the input given to the printer as the ``abstract syntax tree'' (or AST in short) out of convention -- this does not indicate the input necessarily being a tree. Combinators with the subscript $a$ refer to p\textbf{\textit{a}}rsers and those with subscript $i$ refer to pr\textbf{\textit{i}}nters.

\begin{definition}[Invertibility]
A parser {$par$} \emph{:} \F{Parser} $A$ and a printer {$pri$} \emph{:} \F{Printer} $A$ form an invertible pair with values {$ast$} \emph{:} {$A$} and {$str$} \emph{:} \F{String} if it can be shown that:
\begin{itemize}
\item {\F{print} $pri$ $ast$ $\equiv$ \C{just} $str$} -- i.e., the printer can successfully print {$ast$} to the string {$str$}.
\item {$ast$ $\in$ \F{parse} $par$ $str$} -- i.e., {$ast$} is included in the set of results returned on parsing the string {$str$}.
\end{itemize}
\end{definition}

I defined the following notation to show that {$par$}, {$pri$}, {$ast$}, and {$str$} satisfy the property of invertibility -- it indicates that the parsed value {$ast$} and the string {$str$} are inter-convertible via the parser-printer pair of {$par$} and {$pri$}. 
$$\langle {ast}\ \llbracket {par}\! \iff\! {pri} \rrbracket\ {str} \rangle $$
I provide another visualisation of the property of invertibility in Figure \ref{fig:round-trip}, where I show what invertibility means for ambiguous and unambiguous grammars. In the ambiguous case, there always exists at least one parsed result ($ast_k$) which can be printed back as $str$.  
This definition and notation correspond to the following definition in Agda:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{⟨\_⟦\_⇔\_⟧\_⟩} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Parser} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Printer} \AgdaBound{A} \AgdaSymbol{→} \AgdaFunction{String} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{invertible} \AgdaSymbol{:} \>[15]\AgdaSymbol{(}\AgdaBound{ast} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{par} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{pri} \AgdaSymbol{:} \AgdaDatatype{Printer} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{str} \AgdaSymbol{:} \AgdaFunction{String}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaFunction{print} \AgdaBound{pri} \AgdaBound{ast} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{str} \AgdaSymbol{→} \AgdaBound{ast} \AgdaDatatype{∈} \AgdaFunction{parse} \AgdaBound{par} \AgdaBound{str} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaDatatype{⟨} \AgdaBound{ast} \AgdaDatatype{⟦} \AgdaBound{par} \AgdaDatatype{⇔} \AgdaBound{pri} \AgdaDatatype{⟧} \AgdaBound{str} \AgdaDatatype{⟩}\<%
\end{code}

\begin{figure}[t] 
\begin{center}
      \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.5]
          \node[circle,draw,minimum size=1.2cm] (1)  at (0,0)  {$str$};
          \node[draw,minimum size=1.2cm] (2)  at (2,-1)  {Parser};
          \node[circle,draw,minimum size=1.2cm] (3)  at (3,0)  {$ast_1$};
          \node[circle,draw,minimum size=1.2cm] (7)  at (4.5,-1) {$ast_k$};
          \node[circle,draw,minimum size=1.2cm] (6)  at (3,-2) {$ast_n$};
          \node[draw,minimum size=1.2cm] (5)  at (2,1) {Printer};
          \node[circle,minimum size=1.2cm] (10) at (3.6,-0.4) {$\ddots$};
          \node[circle,minimum size=1.2cm] (9)  at (3.6,-1.5) {$\iddots$};

          \path[] (1)  edge [bend right] node {} (2);
          \path[dashed] (2)  edge node {} (3);
          \path[] (2)  edge node {} (7);
          \path[dashed] (2)  edge node {} (6);
          \path[] (5)  edge [bend right] node {} (1);
          \path[] (7)  edge [bend right] node {} (5);
%         \path (17) edge node {} (6);
%         \path (6)  edge node {} (9);
%         \path (9)  edge node {} (10);
      \end{tikzpicture}\\ 
\ \\\ \\
      \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.7]
          \node[circle,draw,minimum size=1.2cm] (1)  at (0,1)  {$str$};
          \node[draw,minimum size=1.2cm] (2)  at (2,0)  {Parser};
          \node[circle,draw,minimum size=1.2cm] (7)  at (4,1) {$ast$};
          \node[draw,minimum size=1.2cm] (5)  at (2,2) {Printer};

          \path[] (1)  edge [bend right] node {} (2);
          \path[] (2)  edge [bend right] node {} (7);
          \path[] (5)  edge [bend right] node {} (1);
          \path[] (7)  edge [bend right] node {} (5);
%         \path (17) edge node {} (6);
%         \path (6)  edge node {} (9);
%         \path (9)  edge node {} (10);
      \end{tikzpicture}
\end{center}
\caption{Top: ambiguous grammar. Bottom: unambiguous grammar. Undashed arcs indicate paths satisfying invertibility.}
\label{fig:round-trip}
\end{figure}


This brings us to the main result which certifies the correctness of my implementation.

\begin{theorem}[Invertibility]
For any syntax description combinator, the parser-printer pair extracted from it form an invertible pair for some values {$ast$} and {$str$}.
\end{theorem}

Similar to the proofs before, I proved this theorem by case analysis. As in the proof of monotonicity, all the input values of the statements below have been universally quantified.

For each case I had to provide two proofs: (1) a proof of the printer successfully printing the AST into a string and (2) a proof of the AST being a member of the list of parsed results.

{\bf Empty:}
There is no proof of invertibility of the \F{empty} combinator as it always fails.

{\bf Pure:} Given {$ast$} : {$A$} (and a function {$dec$} to compute equality between values of type {$A$}), the \F{pure} parser and printer form an invertible pair with {$ast$} and the empty string.

\begin{code}
\>\AgdaFunction{pure-invertible} \AgdaSymbol{:} \>[18]\AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{ast} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \<[43]%
\>[43]\AgdaSymbol{(}\AgdaBound{dec} \AgdaSymbol{:} \AgdaFunction{Decidable} \AgdaSymbol{(}\AgdaDatatype{\_≡\_} \AgdaSymbol{\{}\AgdaArgument{A} \AgdaSymbol{=} \AgdaBound{A}\AgdaSymbol{\}))} \AgdaSymbol{→}\<%
\\
\>[2]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaKeyword{let} \AgdaBound{par} \AgdaSymbol{=} \AgdaFunction{parser-pure} \AgdaBound{dec} \AgdaBound{ast}\<%
\\
\>[18]\AgdaIndent{22}{}\<[22]%
\>[22]\AgdaBound{pri} \AgdaSymbol{=} \AgdaFunction{printer-pure} \AgdaBound{dec} \AgdaBound{ast}\<%
\\
\>[0]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaKeyword{in} \<[22]%
\>[22]\AgdaDatatype{⟨} \AgdaBound{ast} \AgdaDatatype{⟦} \AgdaBound{par} \AgdaDatatype{⇔} \AgdaBound{pri} \AgdaDatatype{⟧} \AgdaInductiveConstructor{[]} \AgdaDatatype{⟩}\<%
\end{code}

The proof followed by definition.

{\bf Token:} Given a character {$ch$}, the \F{token} parser and printer form an invertible pair with the character {$ch$} and the singleton string {$[ ch ]$}.

\begin{code}
\>\AgdaFunction{token-invertible} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{ch} \AgdaSymbol{:} \AgdaPostulate{Char}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\>[19]\AgdaDatatype{⟨} \AgdaBound{ch} \AgdaDatatype{⟦} \AgdaFunction{tokenₐ} \AgdaDatatype{⇔} \AgdaFunction{tokenᵢ} \AgdaDatatype{⟧} \AgdaFunction{[} \AgdaBound{ch} \AgdaFunction{]} \AgdaDatatype{⟩}\<%
\end{code}

The proof followed by definition.

{\bf Choice:} The choice combinator has two proofs, one for each branch it can take. 
Each branch corresponds to the following proof in Agda:
% \begin{itemize}
% \item First branch:
% $$\langle {\tt ast}_1\ \llbracket {\tt par}_1\! \iff\! {\tt pri}_1 \rrbracket\ {\tt str}_1 \rangle \land \langle {\tt ast}_2\ \llbracket {\tt par}_2\! \iff\! {\tt pri}_2 \rrbracket\ {\tt str}_2 \rangle \implies $$
% $$ \langle {\tt ast}_1\ \llbracket {\tt par}_1\ \langle|\rangle_a\ {\tt par}_2 \! \iff\! {\tt pri}_1\ \langle|\rangle_i\ {\tt pri}_2 \rrbracket\ {\tt str}_1 \rangle$$
% \item Second branch: assume {\tt print pri$_1$ ast$_2$ $\equiv$ nothing}. Then --
% $$\langle {\tt ast}_1\ \llbracket {\tt par}_1\! \iff\! {\tt pri}_1 \rrbracket\ {\tt str}_1 \rangle \land \langle {\tt ast}_2\ \llbracket {\tt par}_2\! \iff\! {\tt pri}_2 \rrbracket\ {\tt str}_2 \rangle \implies $$
% $$ \langle {\tt ast}_2\ \llbracket {\tt par}_1\ \langle|\rangle_a\ {\tt par}_2 \! \iff\! {\tt pri}_1\ \langle|\rangle_i\ {\tt pri}_2 \rrbracket\ {\tt str}_2 \rangle$$
% \end{itemize}


\begin{code}
\>\AgdaFunction{choice-inv₁} \AgdaSymbol{:} 
\>[14]\AgdaDatatype{⟨} \AgdaBound{ast₁} \AgdaDatatype{⟦} \AgdaBound{par₁} \AgdaDatatype{⇔} \AgdaBound{pri₁} \AgdaDatatype{⟧} \AgdaBound{str₁} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaDatatype{⟨} \AgdaBound{ast₂} \AgdaDatatype{⟦} \AgdaBound{par₂} \AgdaDatatype{⇔} \AgdaBound{pri₂} \AgdaDatatype{⟧} \AgdaBound{str₂} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaKeyword{let} \AgdaBound{par} \AgdaSymbol{=} \AgdaBound{par₁} \AgdaFunction{⟨∣⟩ₐ} \AgdaBound{par₂}\<%
\\
\>[14]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaBound{pri} \AgdaSymbol{=} \AgdaBound{pri₁} \AgdaFunction{⟨∣⟩ᵢ} \AgdaBound{pri₂}\<%
\\
\>[0]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaKeyword{in} \<[18]%
\>[18]\AgdaDatatype{⟨} \AgdaBound{ast₁} \AgdaDatatype{⟦} \AgdaBound{par} \AgdaDatatype{⇔} \AgdaBound{pri} \AgdaDatatype{⟧} \AgdaBound{str₁} \AgdaDatatype{⟩} \<[46]%
\>[46]\<%
\\
\\
\>\AgdaFunction{choice-inv₂} \AgdaSymbol{:} 
\>[14]\AgdaDatatype{⟨} \AgdaBound{ast₁} \AgdaDatatype{⟦} \AgdaBound{par₁} \AgdaDatatype{⇔} \AgdaBound{pri₁} \AgdaDatatype{⟧} \AgdaBound{str₁} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[8]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaDatatype{⟨} \AgdaBound{ast₂} \AgdaDatatype{⟦} \AgdaBound{par₂} \AgdaDatatype{⇔} \AgdaBound{pri₂} \AgdaDatatype{⟧} \AgdaBound{str₂} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[8]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaKeyword{let} \AgdaBound{par} \AgdaSymbol{=} \AgdaBound{par₁} \AgdaFunction{⟨∣⟩ₐ} \AgdaBound{par₂}\<%
\\
\>[14]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaBound{pri} \AgdaSymbol{=} \AgdaBound{pri₁} \AgdaFunction{⟨∣⟩ᵢ} \AgdaBound{pri₂}\<%
\\
\>[0]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaKeyword{in} \<[18]%
\>[18]\AgdaFunction{print} \AgdaBound{pri₁} \AgdaBound{ast₂} \AgdaDatatype{≡} \AgdaInductiveConstructor{nothing} \AgdaSymbol{→} \AgdaDatatype{⟨} \AgdaBound{ast₂} \AgdaDatatype{⟦} \AgdaBound{par} \AgdaDatatype{⇔} \AgdaBound{pri} \AgdaDatatype{⟧} \AgdaBound{str₂} \AgdaDatatype{⟩} \<[74]%
\>[74]\<%
\end{code}
The proofs for both branches are similar; we have the precondition in the second proof ({\F{print} $pri_1$ $ast_2$ $\equiv$ \C{nothing}}) to force it to take the second branch when printing. This precondition is always satisfied as long as the two combinators combined by the choice combinator do not operate on similar inputs (which is the case for unambiguous grammars).

Both the proofs of successful printing followed by definition of \F{mplus}. I showed the proofs of membership by invoking \F{$\in$-++$^l$} and \F{$\in$-++$^r$}, similar to the proofs of monotonicity.

{\bf Isofunctor:}
The proof of invertibility of the isofunctor combinator states that if {$ast$} and {$str$} are inter-convertible using a parser-printer pair, then we can deduce that $ast'$ and {$str$} are inter-convertible for the parser-printer pair on which the appropriate partial isomorphism has been applied. I formulated this in Agda as:

\begin{code}
\>\AgdaFunction{isofunctor-inv} \AgdaSymbol{:} 
\>[17]\AgdaDatatype{⟨} \AgdaBound{ast} \AgdaDatatype{⟦} \AgdaBound{par} \AgdaDatatype{⇔} \AgdaBound{pri} \AgdaDatatype{⟧} \AgdaBound{str} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaKeyword{let} \AgdaBound{par\! ′} \AgdaSymbol{=} \AgdaBound{iso} \AgdaFunction{⟨\$⟩ₐ} \AgdaBound{par}\<%
\\
\>[17]\AgdaIndent{21}{}\<[21]%
\>[21]\AgdaBound{pri\! ′} \AgdaSymbol{=} \AgdaBound{iso} \AgdaFunction{⟨\$⟩ᵢ} \AgdaBound{pri}\<%
\\
\>[0]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaKeyword{in} \<[21]%
\>[21]\AgdaFunction{apply} \AgdaBound{iso} \AgdaBound{ast} \AgdaDatatype{≡} \AgdaInductiveConstructor{just} \AgdaBound{ast\! ′} \AgdaSymbol{→}\<%
\\
\>[17]\AgdaIndent{21}{}\<[21]%
\>[21]\AgdaDatatype{⟨} \AgdaBound{ast\! ′} \AgdaDatatype{⟦} \AgdaBound{par\! ′} \AgdaDatatype{⇔} \AgdaBound{pri\! ′} \AgdaDatatype{⟧} \AgdaBound{str} \AgdaDatatype{⟩}\<%
\end{code}

The proof of successful printing was shown by invoking the invertibility property of partial isomorphisms, which in this case produced: {\F{unapply} $iso$ $ast'$ $\equiv$ \C{just} $ast$}.

I showed that {$ast'$} is a result on parsing {$str$} by making use of the fact that {\F{apply} $iso$ $ast$ $\equiv$ \C{just} $ast'$} and the results \F{$\in$-map} and \F{>\!\!>\!=$_l$-map} to arrive at the correct expression (similar to the proof of monotonicity).

{\bf Sequence:}
The proof of invertibility of the sequence combinator shows the desired form of sequential behaviour in parsing and printing, which I show in the Agda snippet below:

% For all {\tt par$_1$}, {\tt par$_2$}, {\tt pri$_1$}, {\tt pri$_2$}, {\tt ast$_1$}, {\tt ast$_2$}, {\tt str$_1$}, {\tt str$_2$}:
% $$\langle {\tt ast}_1\ \llbracket {\tt par}_1\! \iff\! {\tt pri}_1 \rrbracket\ {\tt str}_1 \rangle \land \langle {\tt ast}_2\ \llbracket {\tt par}_2\! \iff\! {\tt pri}_2 \rrbracket\ {\tt str}_2 \rangle \implies $$
% $$ \langle ({\tt ast}_1 , {\tt ast}_2)\ \llbracket {\tt par}_1\ \langle\bullet\rangle_a\ {\tt par}_2 \! \iff\! {\tt pri}_1\ \langle\bullet\rangle_i\ {\tt pri}_2 \rrbracket\ {\tt str}_1\ {\tt ++}\ {\tt str}_2 \rangle$$

\begin{code}
\>\AgdaFunction{sequence-inv} \AgdaSymbol{:} 
\>[15]\AgdaDatatype{⟦} \AgdaBound{par₁} \AgdaDatatype{⟧⟨} \AgdaBound{str₁} \AgdaDatatype{⇒} \AgdaBound{ast₁} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaDatatype{⟨} \AgdaBound{ast₁} \AgdaDatatype{⟦} \AgdaBound{par₁} \AgdaDatatype{⇔} \AgdaBound{pri₁} \AgdaDatatype{⟧} \AgdaBound{str₁} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaDatatype{⟨} \AgdaBound{ast₂} \AgdaDatatype{⟦} \AgdaBound{par₂} \AgdaDatatype{⇔} \AgdaBound{pri₂} \AgdaDatatype{⟧} \AgdaBound{str₂} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaKeyword{let} \AgdaBound{par} \AgdaSymbol{=} \AgdaBound{par₁} \AgdaFunction{⟨•⟩ₐ} \AgdaBound{par₂}\<%
\\
\>[15]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaBound{pri} \AgdaSymbol{=} \AgdaBound{pri₁} \AgdaFunction{⟨•⟩ᵢ} \AgdaBound{pri₂}\<%
\\
\>[0]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaKeyword{in} \<[19]%
\>[19]\AgdaDatatype{⟨} \AgdaBound{ast₁} \AgdaInductiveConstructor{,} \AgdaBound{ast₂} \AgdaDatatype{⟦} \AgdaBound{par} \AgdaDatatype{⇔} \AgdaBound{pri} \AgdaDatatype{⟧} \AgdaBound{str₁} \AgdaFunction{++} \AgdaBound{str₂} \AgdaDatatype{⟩}\<%
\end{code}

The proof of successful printing followed by definition of \F{liftM2} and the induction hypothesis.

Showing that the pair {$(ast_1 , ast_2)$} was one of the parsed results made use of the fact that all parsers (specifically {$par_1$} in our case) are monotonic. This result followed as a special case of the monotonicity of the sequence combinator.

{\bf Repetition:} There are two proofs for the repetition combinator, which is due to the two cases in the \F{parseList} function.  
In the first case I demonstrated that applying the repeated parser on the same string returns the original AST as a singleton list. This was written in Agda as:

\begin{code}
\>\AgdaFunction{repetition-inv₁} \AgdaSymbol{:} 
\>[18]\AgdaDatatype{⟨} \AgdaBound{ast} \AgdaDatatype{⟦} \AgdaBound{par} \AgdaDatatype{⇔} \AgdaBound{pri} \AgdaDatatype{⟧} \AgdaBound{str} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaKeyword{let} \AgdaBound{par′} \AgdaSymbol{=} \AgdaFunction{⟨⋆⟩ₐ} \AgdaBound{par}\<%
\\
\>[18]\AgdaIndent{22}{}\<[22]%
\>[22]\AgdaBound{pri′} \AgdaSymbol{=} \AgdaFunction{⟨⋆⟩ᵢ} \AgdaBound{pri}\<%
\\
\>[0]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaKeyword{in} \<[22]%
\>[22]\AgdaDatatype{⟨} \AgdaFunction{[} \AgdaBound{ast} \AgdaFunction{]} \AgdaDatatype{⟦} \AgdaBound{par′} \AgdaDatatype{⇔} \AgdaBound{pri′} \AgdaDatatype{⟧} \AgdaBound{str} \AgdaDatatype{⟩}\<%
\end{code}

The printing proof was shown by definition of \F{liftM2}, and the parsing proof was demonstrated using \F{$\in$-parts} and \F{$\in$-map} to construct the final expression.  
In the second case I showed that if a parser-printer pair parses and prints a pair of values and if the repeated parser-printer pair parses and prints another pair, then the repeated parser-printer pair should be able to parse and print the combined pairs. In Agda:

\begin{code}
\>\AgdaFunction{repetition-inv₂} \AgdaSymbol{:} 
\>[18]\AgdaDatatype{⟨} \AgdaBound{ast} \AgdaDatatype{⟦} \AgdaBound{par} \AgdaDatatype{⇔} \AgdaBound{pri} \AgdaDatatype{⟧} \AgdaBound{str} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[8]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaKeyword{let} \AgdaBound{par\! ′} \AgdaSymbol{=} \AgdaFunction{⟨⋆⟩ₐ} \AgdaBound{par}\<%
\\
\>[18]\AgdaIndent{22}{}\<[22]%
\>[22]\AgdaBound{pri\! ′} \AgdaSymbol{=} \AgdaFunction{⟨⋆⟩ᵢ} \AgdaBound{pri}\<%
\\
\>[0]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaKeyword{in} \<[22]%
\>[22]\AgdaBound{strs} \AgdaFunction{≢} \AgdaInductiveConstructor{[]} \AgdaSymbol{→}\<%
\\
\>[18]\AgdaIndent{22}{}\<[22]%
\>[22]\AgdaDatatype{⟨} \AgdaBound{asts} \AgdaDatatype{⟦} \AgdaBound{par\! ′} \AgdaDatatype{⇔} \AgdaBound{pri\! ′} \AgdaDatatype{⟧} \AgdaBound{strs} \AgdaDatatype{⟩} \AgdaSymbol{→}\<%
\\
\>[18]\AgdaIndent{22}{}\<[22]%
\>[22]\AgdaDatatype{⟨} \AgdaBound{ast} \AgdaInductiveConstructor{∷} \AgdaBound{asts} \AgdaDatatype{⟦} \AgdaBound{par\! ′} \AgdaDatatype{⇔} \AgdaBound{pri\! ′} \AgdaDatatype{⟧} \AgdaBound{str} \AgdaFunction{++} \AgdaBound{strs} \AgdaDatatype{⟩}\<%
\end{code}

The proof of successful printing followed by definition of \F{liftM2} and the inductive hypotheses.

In the proof of parsing I needed to show that {$ast$ $\dblcolon$ $asts$} is an element of (a transformation of) {\F{parts} ($str +\!\!+\ strs$)}. Since the expression {\F{parts} $(str +\!\!+\ strs)$} cannot be written as an expression only in terms of {\F{parts} $str$} and {\F{parts} $strs$}, I considered a sublist of {\F{parts} $(str +\!\!+\ strs)$}. I showed that:
$$(ast \dblcolon asts) \in (\F{map}\ (str \dblcolon)\ (\F{parts}\ strs))$$
which is a sublist of {\F{parts} $(str +\!\!+\ strs)$}, which I showed by \F{parts-map}. For this case overall, I made use of \F{$\in$-parts} and \F{$\in$-map} as in the first case, which completed the proof. 

With all the individual cases proved, this proof is complete. I have summarised this proof in Figure \ref{fig:inv} where I discuss its effectiveness.

\hfill{$\blacksquare$}\\

\section{Summary}
In this Chapter I have shown the implementations of the basic syntax description combinators. In the second half of the Chapter I provided mechanically checked proofs of their strictness, monotonicity, using which I proved their invertibility. I proved all these results by structural induction.

In the following Chapter I discuss the effectiveness of these proofs and evaluate the practicality of my syntax description library by constructing syntax descriptions for the grammars of primitive recursive functions and arithmetic expressions.

\chapter{Evaluation} \label{chap4}

In \autoref{chap3} I described how I constructed each syntax description combinator and showed that the parsers and printers they generated were inverses of each other. In this Chapter I evaluate my implementation from three different perspectives. In \autoref{disc} I discuss the effectiveness of the proofs presented at the end of the \autoref{chap3}, and show that they indeed state the invertibility guarantees expected from syntax descriptions. I discuss how I tested and validated my implementation during development (and before formally proving correctness) by unit testing (\autoref{unittest}) and demonstrating the combinators' satisfiability of some algebraic laws (\autoref{laws}). Finally, I use these syntax description combinators to describe the syntax of primitive recursive functions and arithmetic expressions (\autoref{use}), thereby evaluating the practicality of my combinators.

\section{Discussion of proofs} \label{disc}

Recall the definitions of monotonicity of parsers and invertibility of syntax descriptions from \autoref{mon} and \autoref{invertible}.  
A parser is monotonic if the addition of garbage data at the end of a string does not delete any previously parsed values. Such a property is fundamental to any good parser, and is not immediately apparent from the definition of parser combinators. Affeldt et al. \cite{coq-invert} only postulated the monotonicity of parsers in their work, and never proved it. 
% The notation {\tt $\llbracket$\! p \!$\rrbracket\langle$\! str\! $\Rightarrow$\! ast \!$\rangle$} is read as ``the parser {\tt p} mapping {\tt str} to {\tt ast} is monotonic''.  
A parser and a printer are defined to be invertible if there exists a parsed value $ast$ and string $str$ such that they are inter-convertible using the parser and the printer. In this project I showed {all} my parser combinators to be monotonic, and all my syntax description combinators to satisfy the property of invertibility. I summarise the proofs of invertibility and monotonicity in Figures \ref{fig:inv} and \ref{fig:mon}, where I present all the cases I proved.

The structure of the proof of invertibility additionally yields an operational semantics for syntax descriptions, which shows the relation between the parsed value and printed string at all stages of the computation.
\emph{Notation}: In the following proof cases, subscripts of $a$ (resp. $i$) correspond to p\textbf{\textit{a}}rser (resp. pr\textbf{\textit{i}}nter) combinators. The proofs are quantified for all strings ($str$) and all parsed ASTs ($ast$).

\begin{figure}[H]
\begin{tabu}{|X[c,m]|}
\hline
% \multicolumn{1}{|c|}{Combinator} &
\vspace{1.9em}
$(\textsc{\textbf{pure}})\ \dfrac{}{
\ \Big \langle ast\ \big \llbracket {pure_a}\ ast\! \iff\! {pure_i}\ ast \big \rrbracket\ [\ ] \Big \rangle\ 
} $ 
\vspace{0.7em}
\\
\vspace{0.7em}
$(\textsc{\textbf{token}})\ \dfrac{}{
\ \Big \langle ch\ \big \llbracket {token_a}\! \iff\! {token_i} \big \rrbracket\ [ch] \Big \rangle\ 
} $
\vspace{0.7em}
\\
\vspace{0.7em}
$ (\textsc{\textbf{choice$_1$}})\ \dfrac{
\ 
\Big \langle ast_1\ \big \llbracket {par_1}\! \iff\! {pri_1} \big \rrbracket\ str_1 \Big \rangle\qquad
\Big \langle ast_2\ \big \llbracket {par_2}\! \iff\! {pri_2} \big \rrbracket\ str_2 \Big \rangle
\ 
}{
\Big \langle ast_1\ \big \llbracket {par_1\ \langle|\rangle_a\ par_2}\! \iff\! {pri_1\ \langle|\rangle_i\ pri_2} \big \rrbracket\ str_1 \Big \rangle
}
\vspace{0.7em}
$
\\
\vspace{0.7em}
$ (\textsc{\textbf{choice$_2$}})\ \dfrac{
\ 
\Big \langle ast_1\ \big \llbracket {par_1}\! \iff\! {pri_1} \big \rrbracket\ str_1 \Big \rangle\qquad
\Big \langle ast_2\ \big \llbracket {par_2}\! \iff\! {pri_2} \big \rrbracket\ str_2 \Big \rangle
\ 
}{
\Big \langle ast_2\ \big \llbracket {par_1\ \langle|\rangle_a\ par_2}\! \iff\! {pri_1\ \langle|\rangle_i\ pri_2} \big \rrbracket\ str_2 \Big \rangle
}
\vspace{0.7em}
$
\\
\vspace{0.7em}
$ (\textsc{\textbf{iso}})\ \dfrac{
\ 
\Big \langle ast\ \big \llbracket {par}\! \iff\! {pri} \big \rrbracket\ str \Big \rangle\qquad
{\tt apply}\ iso\ ast \equiv {\tt just}\ ast'
\ 
}{
\Big \langle ast'\ \big \llbracket iso\ \langle\$\rangle_a\ {par}\! \iff\! iso\ \langle\$\rangle_i\ {pri} \big \rrbracket\ str \Big \rangle
}
\vspace{0.7em}
$
\\
\vspace{0.7em}
$ (\textsc{\textbf{seq}})\ \dfrac{
\ 
\Big \langle ast_1\ \big \llbracket {par_1}\! \iff\! {pri_1} \big \rrbracket\ str_1 \Big \rangle\qquad
\Big \langle ast_2\ \big \llbracket {par_2}\! \iff\! {pri_2} \big \rrbracket\ str_2 \Big \rangle
\ 
}{
\Big \langle (ast_1,ast_2)\ \big \llbracket {par_1\ \langle\bullet\rangle_a\ par_2}\! \iff\! {pri_1\ \langle\bullet\rangle_i\ pri_2} \big \rrbracket\ str_1 +\!\!+\ str_2 \Big \rangle
}
$
\vspace{0.7em}
\\
\vspace{0.7em}
$ (\textsc{\textbf{rep$_1$}})\ \dfrac{
\Big \langle ast\ \big \llbracket {par}\! \iff\! {pri} \big \rrbracket\ str \Big \rangle
}{
\  
\Big \langle\ [ast]\ \big \llbracket {\langle\star\rangle_a\ par}\! \iff\! {\langle\star\rangle_i\ pri} \big \rrbracket\ str \Big \rangle
\ 
}
$
\vspace{0.7em}
\\
\vspace{0.7em}
$ (\textsc{\textbf{rep$_2$}})\ \dfrac{
\ 
\Big \langle ast\ \big \llbracket {par}\! \iff\! {pri} \big \rrbracket\ str \Big \rangle\qquad
\Big \langle\ asts\ \big \llbracket {\langle\star\rangle_a\ par}\! \iff\! {\langle\star\rangle_i\ pri} \big \rrbracket\ strs \Big \rangle
\ 
}{
\Big \langle\ ast \dblcolon asts\ \big \llbracket {\langle\star\rangle_a\ par}\! \iff\! {\langle\star\rangle_i\ pri} \big \rrbracket\ str +\!\!+\ strs \Big \rangle\quad
}
$
\vspace{1.7em}
\\
\hline
\end{tabu}
\caption{Proofs of invertibility of syntax descriptions}
\label{fig:inv}
\end{figure}

\begin{figure}[t]
\begin{tabu}{|X[c,m]|}
\hline
\vspace{1.7em}
$ (\textsc{\textbf{token}}) \dfrac {
}{
\ 
\Big \llbracket token_a \Big \rrbracket \Big \langle [ch] \Rightarrow ch \Big \rangle
\ 
}$
\vspace{0.7em}
\\

\vspace{0.7em}
$ (\textsc{\textbf{choice$_1$}}) \dfrac {
\ 
\Big \llbracket\ \! p_1\ \! \Big \rrbracket \Big \langle str_1 \Rightarrow ast_1 \Big \rangle\qquad
\Big \llbracket\ \! p_2\ \! \Big \rrbracket \Big \langle str_2 \Rightarrow ast_2 \Big \rangle
\ 
}{
\Big \llbracket\ \! p_1\ \langle|\rangle\ p_2\ \! \Big \rrbracket \Big \langle str_1 \Rightarrow ast_1 \Big \rangle
}$ 
\vspace{0.7em}
\\

\vspace{0.7em}
$ (\textsc{\textbf{choice$_2$}}) \dfrac {
\ 
\Big \llbracket\ \! p_1\ \! \Big \rrbracket \Big \langle str_1 \Rightarrow ast_1 \Big \rangle\qquad
\Big \llbracket\ \! p_2\ \! \Big \rrbracket \Big \langle str_2 \Rightarrow ast_2 \Big \rangle
\ 
}{
\Big \llbracket\ \! p_1\ \langle|\rangle\ p_2\ \! \Big \rrbracket \Big \langle str_2 \Rightarrow ast_1 \Big \rangle
}$ 
\vspace{0.7em}
\\

\vspace{0.7em}
$ (\textsc{\textbf{iso}}) \dfrac {
\ \Big \llbracket\ \!p\ \! \Big \rrbracket \Big \langle str \Rightarrow ast \Big \rangle\qquad
{\tt apply}\ iso\ ast \equiv {\tt just}\ ast'\ 
}{
\Big \llbracket\ \! iso\ \! \langle\$\rangle\ \! p\ \! \Big \rrbracket \Big \langle str \Rightarrow ast' \Big \rangle
}$ 
\vspace{0.7em}
\\


\vspace{0.7em}
$ (\textsc{\textbf{seq}}) \dfrac {
\ 
\Big \llbracket\ \! p_1\ \! \Big \rrbracket \Big \langle str_1 \Rightarrow ast_1 \Big \rangle\qquad
\Big \llbracket\ \! p_2\ \! \Big \rrbracket \Big \langle str_2 \Rightarrow ast_2 \Big \rangle
\ 
}{
\Big \llbracket p_1\ \! \langle\bullet\rangle\ \! p_2 \Big \rrbracket \Big \langle str_1 +\!\!+\ str_2 \Rightarrow (ast_1,ast_2) \Big \rangle
}$ 
\vspace{0.7em}
\\


\vspace{0.7em}
$ (\textsc{\textbf{rep$_1$}}) \dfrac {
\Big \llbracket\ \! p\ \! \Big \rrbracket \Big \langle str \Rightarrow ast \Big \rangle
}{
\ 
\Big \llbracket \langle\star\rangle\ p\ \! \Big \rrbracket \Big \langle str \Rightarrow [ast] \Big \rangle
\ 
}$ 
\vspace{0.7em}
\\


\vspace{0.7em}
$ (\textsc{\textbf{rep$_2$}}) \dfrac {
\ 
\Big \llbracket\ \! p\ \! \Big \rrbracket \Big \langle str \Rightarrow ast \Big \rangle\qquad
\Big \llbracket \langle\star\rangle\ p\ \! \Big \rrbracket \Big \langle strs \Rightarrow asts \Big \rangle
\ 
}{
\Big \llbracket \langle\star\rangle\ p\ \! \Big \rrbracket \Big \langle str +\!\!+\ strs \Rightarrow ast \dblcolon asts \Big \rangle
}$ 
\vspace{1.7em}
\\


\hline
\end{tabu}
\caption{Proofs of monotonicity of parsers}
\label{fig:mon}
\end{figure}

I now discuss the complexity of my proofs, for which I use the metric of source lines of code (SLOC). The SLOC blow-up factor after converting unverified Haskell to verified Agda code provides, to an approximation, an indication of the time and effort expended in proving the correctness of the implementation. I list the SLOC blow-up factors for the proofs of monotonicity and invertibility for each combinator in Table \ref{tab:blowup}.

\begin{table}[t]
\begin{center}
\begin{tabular}{ l c c }
\hline
{\bf Combinator} & {\bf Monotonicity} & {\bf Invertibility} \\
\F{pure} & {---} & {$1\times$} \\
\F{token} & {$1\times$} & {$1\times$} \\
Choice & {$4\times$} & {$4\times$} \\
Isofunctor & {60$\times$} & {$99\times$} \\
Sequence & {65$\times$} & {$100\times$} \\
Repetition & {176$\times$} & {230$\times$} \\
\hline
\end{tabular}
\end{center}
\caption{SLOC blow-up factors for proofs of monotonicity and invertibility}
\label{tab:blowup}
\end{table}

From this Table we can observe that the proofs for the repetition combinator were most complex. This is due to the repetition combinator using the list partitioning function \F{parts}, which, as a result of its non-trivial definition, was reasoned about separately (\autoref{parts}). The monotonicity and invertibility of \F{pure}, \F{token}, and \F{empty} were shown to hold by definition, which resulted in very short proofs. Similarly, the relatively simple choice combinator, which I defined using list concatenation and the \F{mplus} function, resulted in straightforward proofs. 
Both the isofunctor and sequence proofs were of similar complexity as a result of being defined using list comprehensions, which involved proving a separate set of lemmas to reason about them ({\autoref{list}).

Overall, the implementation of combinators and partial isomorphisms accounts for 20\% of my source code -- the proofs of correctness form the remaining 80\%. Correctness proofs being the bulk of the implementation is not unusual in formal verification. For example, in CompCert -- a compiler for a subset of C formally verified in Coq -- 76\% of the SLOC corresponded to the correctness proofs \cite{compcert}, as of 2009.

To conclude, the syntax description combinators I implemented fit their expected specification of being able to correctly print and parse data from a single description. I showed this by providing machine checked proofs of an invertibility property which states that any string that is the result of printing some abstract syntax can be parsed to obtain the original abstract syntax unmodified. This invertibility property completely characterises combined parsing and pretty printing for use cases where each string has a unique AST associated with it (such as in network packet processing), and provides a strong guarantee of correct parsing and printing for other grammars. In \autoref{future} I introduce another invertibility property (not explored in this project due to time and scope constraints) which, when combined with the invertibility theorem I proved, fully characterises combined parsing and pretty printing for all grammars.

\section{Unit testing} \label{unittest}

In the combinator-construction phase of the project, the development of the combinators was guided by unit tests I designed. These tests not only found early bugs in the combinator implementations, but also contributed to increased confidence in their correct construction.

I accomplished unit testing for my project using Agda's type system, where I designed the tests as proofs of equality. Each equality compared the expression I wanted to evaluate with its expected result. By setting the proofs of all these tests to \C{refl}, I was able to reduce the process of testing to that of type checking. By this method, Agda would complain if the type checking failed, implying unexpected test results. Here is an example unit test:

\begin{code}
\>\AgdaFunction{parse-test} \AgdaSymbol{:} \>[13]\AgdaKeyword{let} \>[17]\AgdaBound{p} \<[21]%
\>[21]\AgdaSymbol{=} \AgdaFunction{⟨⋆⟩} \AgdaFunction{comb} 
\\
\>[3]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaBound{str} \AgdaSymbol{=} \AgdaString{"AA"}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaKeyword{in} \<[17]%
\>[17]\AgdaFunction{parse} \AgdaBound{p} \AgdaBound{str} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaInductiveConstructor{X} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{X} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{)} \AgdaInductiveConstructor{∷} \AgdaSymbol{(}\AgdaInductiveConstructor{Y} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{)} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{parse-test} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}

In the test above, my combinator \F{comb} maps the single string character ``A'' to the symbol \C{X} and ``AA'' to \C{Y}. This test ensures that if the repeated combinator was given the string ``AA'', then it will parse both [\C{X},\C{X}] and [\C{Y}].

% Although this project depends on validation by formal proof, I still maintained a test-driven approach in the development process. The tests I designed served not only to find early bugs in my combinator implementations, but also contributed to an increased confidence in the combinators' correct construction (which I later proved formally).

\section{Verification of algebraic laws} \label{laws}

Another method of validating my implementation before formally proving its correctness was to check whether or not my combinators satisfied algebraic laws known as the functor and monoid laws, which I explain below.  
The benefit of showing the satisfaction of these laws is twofold: firstly, it indicates that the combinators truly are algebraically well-behaved (due to functor and monoid research \cite{functor}), and secondly it enables programmers to readily use functions and design patterns from functor and monoid libraries, which are present in some languages (such as Haskell \footnote{\tt https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Functor.html} \footnote{\tt https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html}).  
In the proofs below, \F{$\_\!\!\!\approx\!\!\!\_$} is an equality relation on parsers (resp. printers). Two parsers (resp. printers) are equal iff they evaluate to the same result on every input.

\paragraph{Functor laws}

Informally, a functor is a type constructor which contains values, and has an associated function {\tt fmap} (also written as $\langle\$\rangle$) which makes it possible to transform all the contained values by applying a function to the entire container. An example of a functor is \F{List}, for which {\tt fmap} = \F{map}. Formally, a type constructor is said to have a functor instance if there exists a function {\tt fmap} which satisfies two laws: the {\it identity law}
$$\forall p.\ id\ \langle\$\rangle\ p \equiv p$$ 
and the {\it composition law}:
$$\forall p.\ (g \circ f)\ \langle\$\rangle\ p \equiv g\ \langle\$\rangle\ (f\ \langle\$\rangle\ p)$$
where $id$ is the identity function and $f$ and $g$ are arbitrary functions. Figure \ref{fig:functorlaw} depicts the functor composition law for a functor $\delta$ where {\tt fmap} = $\langle\$\rangle$.
\begin{figure}[t] 
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.7]
\node[circle,draw,minimum size=0.7cm] (1)  at (0,0)  {$a$};
\node[circle,draw,minimum size=0.7cm] (2)  at (1.8,1)  {$b$};
\node[circle,draw,minimum size=0.7cm] (3)  at (4,0)  {$c$};
\node[circle,draw,minimum size=0.7cm] (4)  at (0,-2)  {$\delta\ a$};
\node[circle,draw,minimum size=0.7cm] (5)  at (1.8,-1)  {$\delta\ b$};
\node[circle,draw,minimum size=0.7cm] (6)  at (4,-2)  {$\delta\ c$};
%%% \node[circle,draw,minimum size=1.2cm] (1)  at (0,0)  {$str$};
%%% \node[draw,minimum size=1.2cm] (2)  at (2,-1)  {Parser};
%%% \node[circle,draw,minimum size=1.2cm] (3)  at (3,0)  {$ast_1$};
%%% \node[circle,draw,minimum size=1.2cm] (7)  at (4.5,-1) {$ast_k$};
%%% \node[circle,draw,minimum size=1.2cm] (6)  at (3,-2) {$ast_n$};
%%% \node[draw,minimum size=1.2cm] (5)  at (2,1) {Printer};
%%% \node[circle,minimum size=1.2cm] (10) at (3.6,-0.4) {$\ddots$};
%%% \node[circle,minimum size=1.2cm] (9)  at (3.6,-1.5) {$\iddots$};

%%% \path[] (1)  edge [bend right] node {} (2);
%%% \path[dashed] (2)  edge node {} (3);
%%% \path[] (2)  edge node {} (7);
%%% \path[dashed] (2)  edge node {} (6);
%%% \path[] (5)  edge [bend right] node {} (1);
%%% \path[] (7)  edge [bend right] node {} (5);

\path[dashed] (1) edge node {$\delta$} (4);
\path[dashed] (2) edge node [near end] {$\delta$} (5);
\path[dashed] (3) edge node {$\delta$} (6);
\path (1) edge node {$f$} (2);
\path (2) edge node {$g$} (3);
\path (1) edge node [near end] {$f \circ g$} (3);
\path (4) edge node {$\langle\$\rangle f$} (5);
\path (5) edge node {$\langle\$\rangle g$} (6);
\path (4) edge node {$\langle\$\rangle (f \circ g$)} (6);
\end{tikzpicture}\\ 
\caption{Functor composition law}
\end{center}
\label{fig:functorlaw}
\end{figure}


I proved that these laws hold for the isofunctor combinator I constructed. The proof statements are given by the type signatures of the proofs. The definitions for \F{id} and \F{$\_\!\!\circ\!\!\_$} are given in \autoref{isoalg}. The following proofs are quantified over all partial isomorphisms $f$ and $g$.

\begin{code}
\>\AgdaFunction{parser-id-law} \>[10]\AgdaSymbol{:}\>[11] \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{id} \AgdaFunction{⟨\$⟩} \AgdaBound{p} \AgdaDatatype{≈} \AgdaBound{p}\<%
\\
\>\AgdaFunction{parser-comp-law} \>[10]\AgdaSymbol{:}\>[11] \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{g} \AgdaFunction{∘} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{⟨\$⟩} \AgdaBound{p} \AgdaDatatype{≈} \AgdaBound{g} \AgdaFunction{⟨\$⟩} \AgdaSymbol{(}\AgdaBound{f} \AgdaFunction{⟨\$⟩} \AgdaBound{p}\AgdaSymbol{)}
\\
\\
\>\AgdaFunction{printer-id-law} \>[10]\AgdaSymbol{:}\>[11] \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Printer} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{id} \AgdaFunction{⟨\$⟩} \AgdaBound{p} \AgdaDatatype{≈} \AgdaBound{p}\<%
\\
\>\AgdaFunction{printer-comp-law} \>[10]\AgdaSymbol{:}\>[11] \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Printer} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{g} \AgdaFunction{∘} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{⟨\$⟩} \AgdaBound{p} \AgdaDatatype{≈} \AgdaBound{g} \AgdaFunction{⟨\$⟩} \AgdaSymbol{(}\AgdaBound{f} \AgdaFunction{⟨\$⟩} \AgdaBound{p}\AgdaSymbol{)}
\end{code}

Both identity laws followed by definition. I proved the parser composition law by reasoning about nested list comprehensions, for which I required \F{>\!\!>\!=$_l$-map} (\autoref{list}). The composition law for printers followed by the associativity of the \F{Maybe} bind function, which I proved in \autoref{maybe}.

\paragraph{Monoid laws}

In mathematics, a monoid is a set that is closed under an associative binary operation and has an identity element. For example, the set of natural numbers with the addition function -- with zero as the identity element -- form a monoid.

This definition translates to type constructors: a type constructor is defined to have a monoid instance if there exists an associative function {\tt mappend} : {$A$} $\to$  $A$ $\to$  $A$ and a value {\tt mempty} : {$A$} such that {\tt mempty} is the left and right identity for {\tt mappend} (an example is list concatenation and the empty list). Based on this definition, I showed that the choice and empty combinators form a monoid. This resulted in demonstrating the following proofs:

\begin{code}
\>[4]\AgdaFunction{parser-left-id} \>[6]:\>[8] \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A}\AgdaSymbol{)} \>[10]\AgdaSymbol{→}\>[12] \AgdaSymbol{(}\AgdaFunction{empty} \AgdaFunction{⟨∣⟩} \AgdaBound{p}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaBound{p}\<%
\\
\>[4]\AgdaFunction{parser-right-id} \>[6]:\>[8] \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A}\AgdaSymbol{)} \>[10]\AgdaSymbol{→}\>[12] \AgdaSymbol{(}\AgdaBound{p} \AgdaFunction{⟨∣⟩} \AgdaFunction{empty}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaBound{p}\<%
\\
\>\AgdaFunction{parser-assoc} \>[6]:\>[8] \AgdaSymbol{(}\AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{:} \AgdaDatatype{Parser} \AgdaBound{A}\AgdaSymbol{)} \>[10]\AgdaSymbol{→}\>[12] \AgdaSymbol{}\AgdaBound{x} \AgdaFunction{⟨∣⟩} \AgdaSymbol{(}\AgdaBound{y} \AgdaFunction{⟨∣⟩} \AgdaBound{z}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaSymbol{(}\AgdaBound{x} \AgdaFunction{⟨∣⟩} \AgdaBound{y}\AgdaSymbol{)} \AgdaFunction{⟨∣⟩} \AgdaBound{z}\AgdaSymbol{}\<%
\\
\\
\>[4]\AgdaFunction{printer-left-id} \>[6]:\>[8] \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Printer} \AgdaBound{A}\AgdaSymbol{)} \>[10]\AgdaSymbol{→}\>[12] \AgdaSymbol{(}\AgdaFunction{empty} \AgdaFunction{⟨∣⟩} \AgdaBound{p}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaBound{p}\<%
\\
\>\AgdaFunction{printer-right-id} \>[6]:\>[8] \AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaDatatype{Printer} \AgdaBound{A}\AgdaSymbol{)} \>[10]\AgdaSymbol{→}\>[12] \AgdaSymbol{(}\AgdaBound{p} \AgdaFunction{⟨∣⟩} \AgdaFunction{empty}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaBound{p}\<%
\\
\>\AgdaFunction{printer-assoc} \>[6]:\>[8] \AgdaSymbol{(}\AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{:} \AgdaDatatype{Printer} \AgdaBound{A}\AgdaSymbol{)} \>[10]\AgdaSymbol{→}\>[12] \AgdaSymbol{}\AgdaBound{x} \AgdaFunction{⟨∣⟩} \AgdaSymbol{(}\AgdaBound{y} \AgdaFunction{⟨∣⟩} \AgdaBound{z}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaSymbol{(}\AgdaBound{x} \AgdaFunction{⟨∣⟩} \AgdaBound{y}\AgdaSymbol{)} \AgdaFunction{⟨∣⟩} \AgdaBound{z}\AgdaSymbol{}\<%
\end{code}

In general, the proofs of these laws for parsers reduced to showing monoidal properties of list concatenation, which is a result proved in the Agda standard library. Similarly, the proofs for the printer functions reduced to showing that \C{nothing} is the left and right identity element for \F{mplus} and that \F{mplus} is associative (proved in \autoref{maybe}). The associativity of the choice combinator is illustrated in Figure \ref{fig:monoidlaw}.

\begin{figure}[t] 
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,semithick,scale=1.2]
\node[minimum size=0.7cm] (1)  at (0,0)  {$x$};
\node[minimum size=0.7cm] (2)  at (2,0)  {$y$};
\node[minimum size=0.7cm] (3)  at (4,0)  {$z$};
\node[minimum size=0.7cm] (o1)  at (1,1)  {$\langle|\rangle$};
\node[minimum size=0.7cm] (o2)  at (2,2)  {$\langle|\rangle$};
\node[minimum size=0.7cm] (o3)  at (9,1)  {$\langle|\rangle$};
\node[minimum size=0.7cm] (o4)  at (8,2)  {$\langle|\rangle$};
\node[minimum size=0.7cm] (4)  at (6,0)  {$x$};
\node[minimum size=0.7cm] (s)  at (5,1)  {$\equiv$};
\node[minimum size=0.7cm] (5)  at (8,0)  {$y$};
\node[minimum size=0.7cm] (6)  at (10,0)  {$z$};

\path[-] (1) edge node {} (o1);
\path[-] (2) edge node {} (o1);
\path[-] (o1) edge node {} (o2);
\path[-] (3) edge node {} (o2);

\path[-] (4) edge node {} (o4);
\path[-] (5) edge node {} (o3);
\path[-] (o3) edge node {} (o4);
\path[-] (6) edge node {} (o3);

%%% \path[] (1)  edge [bend right] node {} (2);
%%% \path[dashed] (2)  edge node {} (3);
%%% \path[] (2)  edge node {} (7);
%%% \path[dashed] (2)  edge node {} (6);
%%% \path[] (5)  edge [bend right] node {} (1);
%%% \path[] (7)  edge [bend right] node {} (5);

\end{tikzpicture}\\ 
\caption{Monoid associativity law}
\end{center}
\label{fig:monoidlaw}
\end{figure}

\section{Using syntax descriptions} \label{use}

Using the combinators in the previous chapters, I give a brief overview of the construction of syntax descriptions for the grammar describing primitive recursive functions. The complete set of partial isomorphisms and combinators I discuss here can be found in Appendix B.

The general method of building syntax descriptions involves constructing an ADT representing the grammar. The appropriate partial isomorphisms are created for each constructor of the ADT, which are connected to tokens using the isofunctor combinator. Finally, all the individual combinators are combined using the choice, sequencing, and repetition combinators as required.

To begin, recall the syntax of primitive recursive functions \cite{computability}\cite{boolos}:
$$f ::= succ\  |\  proj_i^n\ |\ zero^n\ |\ f \circ [f_1,f_2,\hdots,f_n]\ |\ \rho^n(f_1,f_2)$$
where $i$ and $n$ range over all the natural numbers. This is an unambiguous grammar.

I represent these non-terminals in text as {\tt succ}, {\tt proj\_i\^{}n}, {\tt zero\^{}n}, {\tt f.[f1,f2,...,fn]}, and {\tt rho\^{}n}.

The first step is to convert this grammar into an ADT for which we can create partial isomorphisms. This ADT is given by:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{PrimRec} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{Succ} \AgdaSymbol{:} \AgdaDatatype{PrimRec}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{Proj} \AgdaSymbol{:} \AgdaPostulate{Char} \AgdaSymbol{→} \AgdaPostulate{Char} \AgdaSymbol{→} \AgdaDatatype{PrimRec}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{Zero} \AgdaSymbol{:} \AgdaPostulate{Char} \AgdaSymbol{→} \AgdaDatatype{PrimRec}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{Rec} \AgdaSymbol{:} \AgdaPostulate{Char} \AgdaSymbol{→} \AgdaDatatype{PrimRec} \AgdaSymbol{→} \AgdaDatatype{PrimRec} \AgdaSymbol{→} \AgdaDatatype{PrimRec}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{Comp} \AgdaSymbol{:} \AgdaDatatype{PrimRec} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaDatatype{PrimRec} \AgdaSymbol{→} \AgdaDatatype{PrimRec}\<%
\end{code}

Each constructor in the grammar represents a partial isomorphism. Below is the partial isomorphism for the \F{Comp} constructor -- the rest are defined similarly and can be found in Appendix B. The proofs of invertibility follow trivially by pattern matching, and have been omitted here.

 \begin{code}
 \>\AgdaFunction{comp} \AgdaSymbol{:} \AgdaRecord{Iso} \AgdaSymbol{(}\AgdaDatatype{PrimRec} \AgdaFunction{×} \AgdaDatatype{List} \AgdaDatatype{PrimRec}\AgdaSymbol{)} \AgdaDatatype{PrimRec}\<%
 \\
 \>\AgdaFunction{comp} \AgdaSymbol{=} \AgdaFunction{f} \AgdaInductiveConstructor{,} \AgdaFunction{g} \AgdaInductiveConstructor{⟨} ... \AgdaInductiveConstructor{⟩}\<%
 \\
 \>[0]\AgdaIndent{2}{}\<[2]%
 \>[2]\AgdaKeyword{where}\<%
 \\
 \>[2]\AgdaIndent{4}{}\<[4]%
 \>[4]\AgdaFunction{f} \AgdaSymbol{:} \AgdaDatatype{PrimRec} \AgdaFunction{×} \AgdaDatatype{List} \AgdaDatatype{PrimRec} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaDatatype{PrimRec}\<%
 \\
 \>[2]\AgdaIndent{4}{}\<[4]%
 \>[4]\AgdaFunction{f} \AgdaSymbol{(}\AgdaBound{fun} \AgdaInductiveConstructor{,} \AgdaBound{funs}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{just} \AgdaSymbol{(}\AgdaInductiveConstructor{Comp} \AgdaBound{fun} \AgdaBound{funs}\AgdaSymbol{)}\<%
 \\
 %
 \\
 \>[2]\AgdaIndent{4}{}\<[4]%
 \>[4]\AgdaFunction{g} \AgdaSymbol{:} \AgdaDatatype{PrimRec} \AgdaSymbol{→} \AgdaDatatype{Maybe} \AgdaSymbol{(}\AgdaDatatype{PrimRec} \AgdaFunction{×} \AgdaDatatype{List} \AgdaDatatype{PrimRec}\AgdaSymbol{)}\<%
 \\
 \>[2]\AgdaIndent{4}{}\<[4]%
 \>[4]\AgdaFunction{g} \AgdaSymbol{(}\AgdaInductiveConstructor{Comp} \AgdaBound{fun} \AgdaBound{funs}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{just} \AgdaSymbol{(}\AgdaBound{fun} \AgdaInductiveConstructor{,} \AgdaBound{funs}\AgdaSymbol{)}\<%
 \\
 \>[4]\AgdaFunction{g} \AgdaSymbol{\_} \AgdaSymbol{=} \AgdaInductiveConstructor{nothing}\<%
 \end{code}

In the following examples, each combinator is parametrised by a variable {$s$} : \F{Syntax} $\delta$. Once the final syntax description is obtained, its parser (resp. printer) is extracted by passing to it the \F{Syntax} record for parsers (resp. printers).

In practice, it is sometimes convenient to parse a string as two sequential parses and then discard one of the parses. This commonly occurs when we are parsing keywords -- once they are parsed along with their arguments, the keywords themselves are not required. This is analogous to the case in printers, where specific printers only require the arguments to print, and print keywords on their own. Such functionality can be implemented by the $\_\langle\bullet\_$ and $\_\bullet\rangle\_$ combinators, which return their left and right results respectively. These combinators have been derived from $\_\langle\bullet\rangle\_$ and are defined in Appendix B. Additionally, I make use of the \F{text} combinator, which parses and prints given strings.

I start by defining \F{parens} and \F{sqbracks} -- syntax descriptions which operate on data within a pair of parentheses and square brackets.

\begin{code}
\>\AgdaFunction{parens} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{δ} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{δ} \AgdaBound{A}\<%
\\
\>\AgdaFunction{parens} \AgdaBound{x} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{text} \AgdaString{"("}\AgdaSymbol{)} \AgdaFunction{•⟩} \AgdaBound{x} \AgdaFunction{⟨•} \AgdaSymbol{(}\AgdaFunction{text} \AgdaString{")"}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{sqbracks} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{δ} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{δ} \AgdaBound{A}\<%
\\
\>\AgdaFunction{sqbracks} \AgdaBound{x} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{text} \AgdaString{"["}\AgdaSymbol{)} \AgdaFunction{•⟩} \AgdaBound{x} \AgdaFunction{⟨•} \AgdaSymbol{(}\AgdaFunction{text} \AgdaString{"]"} \AgdaSymbol{)}\<%
\end{code}

Overall, the main description is given by providing descriptions for each non-terminal, which are then combined by the choice combinator. The description for {\tt proj}, for example, looks like the following:

\begin{code}
\>[13]\AgdaFunction{proj} \AgdaFunction{⟨\$⟩} (\AgdaFunction{text} \AgdaString{"proj\_"})\<%
\>\AgdaFunction{•⟩} \AgdaField{token}\<%
\>\AgdaFunction{⟨•} \AgdaSymbol{(}\AgdaFunction{text} \AgdaString{"\textasciicircum"}\AgdaSymbol{)}\<%
\>\AgdaFunction{⟨•⟩} \AgdaField{token}\<%
\end{code}

This code translates to the following procedure: split the input into four parts, discarding the strings {\tt "proj\_"} and {\tt "\^{}"}. The two tokens surrounding {\tt "\^{}"} are the required indices (extracted using \F{token}), which are passed to the \F{proj} partial isomorphism.

Similar descriptions are written for each non-terminal, which combine to result in the final syntax description (Appendix B).
% Note that due to Agda's requirement of function termination, the syntax description is parametrised by a natural number limiting the recursion depth. Using this Agda's termination checker can deduce that this function terminates.

% \begin{code}
% \>[0]\AgdaIndent{2}{}\<[2]%
% \>[2]\AgdaFunction{exp} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaBound{δ} \AgdaDatatype{PrimRec}\<%
% \\
% \>[0]\AgdaIndent{2}{}\<[2]%
% \>[2]\AgdaFunction{exp} \AgdaNumber{0} \AgdaSymbol{=} \<[11]%
% \>[11]\AgdaFunction{succ} \AgdaFunction{⟨\$⟩} \AgdaFunction{text} \AgdaSymbol{(}\AgdaFunction{toList} \AgdaString{"succ"}\AgdaSymbol{)}\<%
% \\
% \>[2]\AgdaIndent{7}{}\<[7]%
% \>[7]\AgdaFunction{⟨∣⟩} \AgdaFunction{proj} \AgdaFunction{⟨\$⟩} \AgdaFunction{text} \AgdaSymbol{(}\AgdaFunction{toList} \AgdaString{"proj\_"}\AgdaSymbol{)}\<%
% \\
% \>[7]\AgdaIndent{17}{}\<[17]%
% \>[17]\AgdaFunction{•⟩} \AgdaSymbol{(}\AgdaField{token}\<%
% \\
% \>[0]\AgdaIndent{16}{}\<[16]%
% \>[16]\AgdaFunction{⟨•} \AgdaFunction{text} \AgdaFunction{[} \AgdaString{'\textasciicircum'} \AgdaFunction{]}\AgdaSymbol{)}\<%
% \\
% \>[0]\AgdaIndent{16}{}\<[16]%
% \>[16]\AgdaFunction{⟨•⟩} \AgdaField{token}\<%
% \\
% \>[0]\AgdaIndent{7}{}\<[7]%
% \>[7]\AgdaFunction{⟨∣⟩} \AgdaFunction{zero} \AgdaFunction{⟨\$⟩} \AgdaFunction{text} \AgdaSymbol{(}\AgdaFunction{toList} \AgdaString{"zero\textasciicircum"}\AgdaSymbol{)}\<%
% \\
% \>[7]\AgdaIndent{17}{}\<[17]%
% \>[17]\AgdaFunction{•⟩} \AgdaField{token}\<%
% \\
% \>[0]\AgdaIndent{2}{}\<[2]%
% \>[2]\AgdaFunction{exp} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{=} \<[17]%
% \>[17]\AgdaFunction{succ} \AgdaFunction{⟨\$⟩} \AgdaSymbol{(}\AgdaFunction{text} \AgdaSymbol{(}\AgdaFunction{toList} \AgdaString{"succ"}\AgdaSymbol{))}\<%
% \\
% \>[2]\AgdaIndent{13}{}\<[13]%
% \>[13]\AgdaFunction{⟨∣⟩} \AgdaFunction{proj} \AgdaFunction{⟨\$⟩} \AgdaFunction{text} \AgdaSymbol{(}\AgdaFunction{toList} \AgdaString{"proj\_"}\AgdaSymbol{)}\<%
% \\
% \>[13]\AgdaIndent{23}{}\<[23]%
% \>[23]\AgdaFunction{•⟩} \AgdaSymbol{(}\AgdaField{token}\<%
% \\
% \>[0]\AgdaIndent{22}{}\<[22]%
% \>[22]\AgdaFunction{⟨•} \AgdaFunction{text} \AgdaFunction{[} \AgdaString{'\textasciicircum'} \AgdaFunction{]}\AgdaSymbol{)}\<%
% \\
% \>[0]\AgdaIndent{22}{}\<[22]%
% \>[22]\AgdaFunction{⟨•⟩} \AgdaField{token}\<%
% \\
% \>[0]\AgdaIndent{13}{}\<[13]%
% \>[13]\AgdaFunction{⟨∣⟩} \AgdaFunction{zero} \AgdaFunction{⟨\$⟩} \AgdaFunction{text} \AgdaSymbol{(}\AgdaFunction{toList} \AgdaString{"zero\textasciicircum"}\AgdaSymbol{)}\<%
% \\
% \>[13]\AgdaIndent{23}{}\<[23]%
% \>[23]\AgdaFunction{•⟩} \AgdaField{token}\<%
% \\
% \>[0]\AgdaIndent{13}{}\<[13]%
% \>[13]\AgdaFunction{⟨∣⟩} \AgdaFunction{comp} \AgdaFunction{⟨\$⟩} \AgdaSymbol{(}\AgdaFunction{exp} \AgdaBound{n}\<%
% \\
% \>[13]\AgdaIndent{22}{}\<[22]%
% \>[22]\AgdaFunction{⟨•} \AgdaFunction{text} \AgdaFunction{[} \AgdaString{'.'} \AgdaFunction{]}\AgdaSymbol{)}\<%
% \\
% \>[13]\AgdaIndent{22}{}\<[22]%
% \>[22]\AgdaFunction{⟨•⟩} \AgdaFunction{sqbracks} \AgdaSymbol{(}\AgdaFunction{cons} \AgdaFunction{⟨\$⟩} \AgdaFunction{exp} \AgdaBound{n}\<%
% \\
% \>[22]\AgdaIndent{41}{}\<[41]%
% \>[41]\AgdaFunction{⟨•⟩} \AgdaFunction{⟨⋆⟩} \AgdaSymbol{(}\AgdaFunction{text} \AgdaFunction{[} \AgdaString{','} \AgdaFunction{]}\AgdaSymbol{)} \AgdaFunction{•⟩} \AgdaSymbol{(}\AgdaFunction{exp} \AgdaBound{n}\AgdaSymbol{))}\<%
% \\
% \>[0]\AgdaIndent{13}{}\<[13]%
% \>[13]\AgdaFunction{⟨∣⟩} \AgdaFunction{rec} \<[22]%
% \>[22]\AgdaFunction{⟨\$⟩} \AgdaFunction{text} \AgdaSymbol{(}\AgdaFunction{toList} \AgdaString{"rho\textasciicircum"}\AgdaSymbol{)} \AgdaFunction{•⟩} \AgdaField{token}\<%
% \\
% \>[13]\AgdaIndent{22}{}\<[22]%
% \>[22]\AgdaFunction{⟨•⟩} \AgdaSymbol{(}\AgdaFunction{parens} \AgdaSymbol{((}\AgdaFunction{exp} \AgdaBound{n} \AgdaFunction{⟨•} \AgdaFunction{text} \AgdaFunction{[} \AgdaString{','} \AgdaFunction{]}\AgdaSymbol{)} \AgdaFunction{⟨•⟩} \AgdaFunction{exp} \AgdaBound{n}\AgdaSymbol{))}\<%
% \end{code}

From this syntax description I can extract functions \F{prim-parser} and \F{prim-printer} which provide parsing and printing functionalities. They can be checked by setting the type signature to an equality and having Agda's type checker mechanically verify it.

\begin{code}
\>\AgdaFunction{prim-ex₁} \AgdaSymbol{:} \>[6]\AgdaFunction{prim-printer} \AgdaSymbol{(}\AgdaInductiveConstructor{Rec} \AgdaString{'2'} \AgdaInductiveConstructor{Succ} \AgdaSymbol{(}\AgdaInductiveConstructor{Proj} \AgdaString{'2'} \AgdaString{'3'}\AgdaSymbol{))} \AgdaDatatype{≡}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaInductiveConstructor{just} \AgdaString{"rho\textasciicircum2(succ,proj\_2\textasciicircum3)"}\<%
\\
\>\AgdaFunction{prim-ex₁} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>\AgdaFunction{prim-ex₂} \AgdaSymbol{:} \>[6]\AgdaFunction{prim-parser} \AgdaString{"proj\_1\textasciicircum5"} \AgdaDatatype{≡}
\AgdaFunction{[} \AgdaInductiveConstructor{Proj} \AgdaString{'1'} \AgdaString{'5'} \AgdaFunction{]}\<%
\\
\>\AgdaFunction{prim-ex₂} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}

With this syntax description I have demonstrated how to build a simple parser and printer without any redundant effort.  We can observe the invertibility of the parser-printer pair in the following example, where I successfully print and parse $succ \circ [proj_1^4,zero^3]$.

\begin{code}
\>\AgdaFunction{prim-ex₃} \AgdaSymbol{:} \>[6]\AgdaFunction{prim-printer} \AgdaSymbol{(}\AgdaInductiveConstructor{Comp} \AgdaInductiveConstructor{Succ} \AgdaSymbol{(}\AgdaInductiveConstructor{Proj} \AgdaString{'1'} \AgdaString{'4'} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{Zero} \AgdaString{'3'} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{))} \AgdaDatatype{≡}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaInductiveConstructor{just} \AgdaString{"succ.[proj\_1\textasciicircum4,zero\textasciicircum3]"}\<%
\\
\>\AgdaFunction{prim-ex₃} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>\AgdaFunction{prim-ex₄} \AgdaSymbol{:} \>[6]\AgdaFunction{prim-parser} \AgdaString{"succ.[proj\_1\textasciicircum4,zero\textasciicircum3]"} \AgdaDatatype{≡}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{Comp} \AgdaInductiveConstructor{Succ} \AgdaSymbol{(}\AgdaInductiveConstructor{Proj} \AgdaString{'1'} \AgdaString{'4'} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{Zero} \AgdaString{'3'} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{))} \AgdaFunction{]}\<%
\\
\>\AgdaFunction{prim-ex₄} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}

Using this method I was also able to produce a syntax description to describe arithmetic expressions. The syntax is given by the grammar below:
$$A ::= n\ |\ A + A\ |\ A \times A$$
This grammar corresponds to the following ADT:

\begin{code}
\>\AgdaKeyword{data} \AgdaDatatype{Expression} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{Literal} \AgdaSymbol{:} \AgdaPostulate{Char} \AgdaSymbol{→} \AgdaDatatype{Expression}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{AddOp} \AgdaSymbol{:} \AgdaDatatype{Expression} \AgdaSymbol{→} \AgdaDatatype{Expression} \AgdaSymbol{→} \AgdaDatatype{Expression}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{MulOp} \AgdaSymbol{:} \AgdaDatatype{Expression} \AgdaSymbol{→} \AgdaDatatype{Expression} \AgdaSymbol{→} \AgdaDatatype{Expression}\<%
\end{code}

I followed a procedure similar to the one above to extract functions \F{arith-parser} and \F{arith-printer} for parsing and printing these expressions. I present examples of these functions in use below:

\begin{code}
\>\AgdaFunction{arith-ex₁} \AgdaSymbol{:} \AgdaFunction{arith-parser} \AgdaString{"1+2*(4+5)"} \AgdaDatatype{≡}\<%
\\
\>[4]\AgdaIndent{11}{}\<[11]%
\>[11]\ \ \ \!\AgdaInductiveConstructor{AddOp} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'1'}\AgdaSymbol{)}\<%
\>\AgdaSymbol{(}\AgdaInductiveConstructor{MulOp} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'2'}\AgdaSymbol{)}\<%
\>\AgdaSymbol{(}\AgdaInductiveConstructor{AddOp} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'4'}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'5'}\AgdaSymbol{)))}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{MulOp} \AgdaSymbol{(}\AgdaInductiveConstructor{AddOp} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'1'}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'2'}\AgdaSymbol{))}\<%
\>[17]\AgdaSymbol{(}\AgdaInductiveConstructor{AddOp} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'4'}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'5'}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\<%
\\
\>\AgdaFunction{arith-ex₁} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}
\F{arith-ex$_1$} illustrates how the parser parses the unambiguous expression of {\tt 1+2*(4+5)} into two results: {\tt 1+(2*(4+5))} and {\tt (1+2)*(4+5)}.

\begin{code}
\>\AgdaFunction{arith-ex₂} \AgdaSymbol{:} \AgdaFunction{arith-printer} \AgdaSymbol{(}\AgdaInductiveConstructor{AddOp} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'1'}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{Literal} \AgdaString{'2'}\AgdaSymbol{))} \AgdaDatatype{≡} \<[63]%
\>\AgdaInductiveConstructor{just} \AgdaString{"1+2"}\<%
\\
\>\AgdaFunction{arith-ex₂} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}

With this I have shown my implementation to meet the success criterion of being able to describe primitive recursive functions and arithmetic expressions. Due to the proof of invertibility presented in \autoref{invertible}, we can assert \emph{formally} that all parser-printer pairs extracted from syntax descriptions in this manner form invertible pairs.

\section{Summary}
In this Chapter I have discussed the evaluation of my implementation in terms of testing during the combinator construction phase (unit tests and the verification of functor and monoid laws) and testing after completing construction (proofs of monotonicity and invertibility). The verification of my combinators satisfying the two laws indicates their generality as functions. Additionally, I assessed the practicality of using my implemented combinators by constructing a single description for arithmetic expressions and primitive recursive functions respectively, from which I could derive parsers and printers with no added effort.

\chapter{Conclusion}

This dissertation has detailed how I designed, implemented, and proved the correctness of a library for combined parsing and pretty printing in the dependently typed language Agda.
I have met all the success criteria initially set out and have extended them by proving additional properties about my implementation.
Compared to the previous work of Affeldt et al. \cite{coq-invert}, my proofs are more general as they are not limited to ambiguous grammars, and are entirely axiom-free.
Their work, to my knowledge, is the only other research that has been done on the formal verification of invertible syntax descriptions.

\section{Results}

I list below all my success criteria (Appendix C) and describe how I met them.


\textbf{\textit{``[To implement a] complete formalisation of partial isomorphisms.''}}

I have defined and extended partial isomorphisms and functions operating on them to contain proofs of their invertibility, which is a guarantee that could not be shown in the original implementation in Haskell (\autoref{invertible}).

\textbf{\textit{``Development of an EDSL to be able to describe the necessary languages.''}}

I developed seven combinators (namely, the {pure}, {token}, {empty}, choice, isofunctor, sequence, and repetition combinators) in \autoref{syndesc}, using which I could describe the languages in the following criterion.

\textbf{\textit{``Having the ability to describe [the syntax of] arithmetic expressions [and] primitive recursive functions.  I should then, without having to do any extra work, be able to use the associated parser and printer that are generated.''}}

In \autoref{use} I provided syntax descriptions for arithmetic expressions and primitive recursive functions using the developed combinators and showed their associated parsers and printers to function as required.
\ \\\ \\
\textbf{\textit{``Having a proof of correctness [and] proofs of termination.''}}

I demonstrated the correctness of my implementation by proving in Agda that the parser and printer extracted from any syntax description are inverses of each other in \autoref{invertible}. In other words, I proved that any string that is the result of printing some abstract syntax can be parsed to obtain the original abstract syntax unmodified.  
All my implemented combinators terminate on any input -- this is attested by Agda's termination checker accepting my definitions.

\emph{Extension:} I showed my combinators to satisfy the algebraic laws known as functor and monoid laws (defined and proved in \autoref{laws}). These laws indicate the universality of my combinators and indicate that they are algebraically well-behaved.

\section{Further work} \label{future}
In this project I only focused on one type of invertibility property, where a parsed result can be obtained by printing it and then parsing it again. Symbolically, I have shown:
$$\forall a.\ a \in \textrm{\tt parse}\ ({\tt print}\ a)$$
This property shows that parsing is the left inverse of printing. Another property of invertibility could look like the following:
$$\forall s.\ {\tt parse}\ ({\tt print}\ ({\tt parse}\ s)) \equiv {\tt parse}\ s$$
where $s$ ranges over all strings. Such a proof could be used to validate code formatters.

\section{Lessons learned}
In the initial stages of proving the correctness of my implementation, I stated the property of invertibility as an equality, such as $$\text{\F{parse}}\ par\ str \equiv [\ ast\ ],$$
 rather than as a statement of list membership,
$$ast \in \text{\F{parse}}\ par\ str.$$
Although (for individual combinators) statements of equality were tighter than their membership-form counterparts, they could not be combined into one general statement for arbitrary combinators. Additionally, their proofs were less elegant and more complicated. I could only learn this by trying first, but having the insight to look into proofs of list membership (rather than proofs of equality) % but if I could give my past self one piece of advice, it would be to look into proving statements of list membership sooner.
earlier would have avoided a great deal of refactoring and made proving correctness easier.

Overall, this project has given me a glimpse into the exciting world of formal verification, and I have gained invaluable experience in the art of theorem proving.

\addcontentsline{toc}{chapter}{Bibliography}

\bibliographystyle{plain}
\bibliography{refs}

\appendix
\chapter{Partial isomorphisms}
\input{appA}
\chapter{Syntax descriptions}
\input{appB}
\chapter{Project Proposal}
\input{proposal}

\end{document}
